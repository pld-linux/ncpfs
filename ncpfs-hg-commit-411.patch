changeset:   411:e04165992166
user:        Petr Vandrovec <petr@vandrovec.name>
date:        Sat May 28 13:45:22 2005 +0000
files:       include/private/libintl.h intl/ChangeLog intl/Makefile.in intl/VERSION intl/bindtextdom.c intl/config.charset intl/dcgettext.c intl/dcigettext.c intl/dcngettext.c intl/dgettext.c intl/dngettext.c intl/eval-plural.h intl/explodename.c intl/finddomain.c intl/gettext.c intl/gettextP.h intl/gmo.h intl/hash-string.h intl/intl-compat.c intl/l10nflist.c intl/langprefs.c intl/libgnuintl.h.in intl/loadinfo.h intl/loadmsgcat.c intl/localcharset.c intl/localcharset.h intl/locale.alias intl/localealias.c intl/localename.c intl/log.c intl/ngettext.c intl/plural-exp.c intl/plural-exp.h intl/plural.c intl/plural.y intl/printf-args.c intl/printf-args.h intl/printf-parse.c intl/printf-parse.h intl/printf.c intl/relocatable.c intl/relocatable.h intl/textdomain.c intl/vasnprintf.c intl/vasnprintf.h intl/vasnwprintf.h intl/wprintf-parse.h intl/xsize.h po/Makefile.in.in po/Makevars
description:
Update gettext to version 0.14.4.


diff -r 4216c218ee44 -r e04165992166 include/private/libintl.h
--- a/include/private/libintl.h	Sat May 28 13:40:15 2005 +0000
+++ b/include/private/libintl.h	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Convenience header for conditional use of GNU <libintl.h>.
-   Copyright (C) 1995-1998, 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2002, 2004 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -22,7 +22,7 @@
 #include "config.h"
 
 /* NLS can be disabled through the configure --disable-nls option.  */
-#if ENABLE_NLS
+#if defined(ENABLE_NLS) && ENABLE_NLS
 
 /* Get declarations of GNU message catalog functions.  */
 # include <libintl.h>
@@ -37,6 +37,16 @@
    is OK.  */
 #if defined(__sun)
 # include <locale.h>
+#endif
+
+/* Many header files from the libstdc++ coming with g++ 3.3 or newer include
+   <libintl.h>, which chokes if dcgettext is defined as a macro.  So include
+   it now, to make later inclusions of <libintl.h> a NOP.  */
+#if defined(__cplusplus) && defined(__GNUG__) && (__GNUC__ >= 3)
+# include <cstdlib>
+# if (__GLIBC__ >= 2) || _GLIBCXX_HAVE_LIBINTL_H
+#  include <libintl.h>
+# endif
 #endif
 
 /* Disabled NLS.
diff -r 4216c218ee44 -r e04165992166 intl/ChangeLog
--- a/intl/ChangeLog	Sat May 28 13:40:15 2005 +0000
+++ b/intl/ChangeLog	Sat May 28 13:45:22 2005 +0000
@@ -1,4 +1,4 @@ 2002-08-06  GNU  <bug-gnu-gettext@gnu.or
-2002-08-06  GNU  <bug-gnu-gettext@gnu.org>
+2005-04-11  GNU  <bug-gnu-gettext@gnu.org>
 
-	* Version 0.11.5 released.
+	* Version 0.14.4 released.
 
diff -r 4216c218ee44 -r e04165992166 intl/Makefile.in
--- a/intl/Makefile.in	Sat May 28 13:40:15 2005 +0000
+++ b/intl/Makefile.in	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
-# Makefile for directory with message catalog handling in GNU NLS Utilities.
-# Copyright (C) 1995-1998, 2000-2002 Free Software Foundation, Inc.
+# Makefile for directory with message catalog handling library of GNU gettext
+# Copyright (C) 1995-1998, 2000-2005 Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of the GNU Library General Public License as published
@@ -24,7 +24,7 @@ srcdir = @srcdir@
 srcdir = @srcdir@
 top_srcdir = @top_srcdir@
 top_builddir = ..
-VPATH = @srcdir@
+VPATH = $(srcdir)
 
 prefix = @prefix@
 exec_prefix = @exec_prefix@
@@ -40,7 +40,7 @@ INSTALL = @INSTALL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 MKINSTALLDIRS = @MKINSTALLDIRS@
-mkinstalldirs = $(SHELL) `case "$(MKINSTALLDIRS)" in /*) echo "$(MKINSTALLDIRS)" ;; *) echo "$(top_builddir)/$(MKINSTALLDIRS)" ;; esac`
+mkinstalldirs = $(SHELL) $(MKINSTALLDIRS)
 
 l = @INTL_LIBTOOL_SUFFIX_PREFIX@
 
@@ -52,89 +52,205 @@ YFLAGS = --name-prefix=__gettext
 YFLAGS = --name-prefix=__gettext
 
 DEFS = -DLOCALEDIR=\"$(localedir)\" -DLOCALE_ALIAS_PATH=\"$(aliaspath)\" \
--DLIBDIR=\"$(libdir)\" -DIN_LIBINTL @DEFS@
+-DLIBDIR=\"$(libdir)\" -DIN_LIBINTL \
+-DENABLE_RELOCATABLE=1 -DIN_LIBRARY -DINSTALLDIR=\"$(libdir)\" -DNO_XMALLOC \
+-Dset_relocation_prefix=libintl_set_relocation_prefix \
+-Drelocate=libintl_relocate \
+-DDEPENDS_ON_LIBICONV=1 @DEFS@
 CPPFLAGS = @CPPFLAGS@
 CFLAGS = @CFLAGS@
 LDFLAGS = @LDFLAGS@
+LIBS = @LIBS@
 
 COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS)
 
-HEADERS = $(COMHDRS) libgnuintl.h loadinfo.h
-COMHDRS = gmo.h gettextP.h hash-string.h plural-exp.h eval-plural.h os2compat.h
-SOURCES = $(COMSRCS) intl-compat.c
-COMSRCS = bindtextdom.c dcgettext.c dgettext.c gettext.c \
-finddomain.c loadmsgcat.c localealias.c textdomain.c l10nflist.c \
-explodename.c dcigettext.c dcngettext.c dngettext.c ngettext.c plural.y \
-plural-exp.c localcharset.c localename.c osdep.c os2compat.c
-OBJECTS = @INTLOBJS@ bindtextdom.$lo dcgettext.$lo dgettext.$lo gettext.$lo \
-finddomain.$lo loadmsgcat.$lo localealias.$lo textdomain.$lo l10nflist.$lo \
-explodename.$lo dcigettext.$lo dcngettext.$lo dngettext.$lo ngettext.$lo \
-plural.$lo plural-exp.$lo localcharset.$lo localename.$lo osdep.$lo
-GETTOBJS = intl-compat.$lo
+HEADERS = \
+  gmo.h \
+  gettextP.h \
+  hash-string.h \
+  loadinfo.h \
+  plural-exp.h \
+  eval-plural.h \
+  localcharset.h \
+  relocatable.h \
+  xsize.h \
+  printf-args.h printf-args.c \
+  printf-parse.h wprintf-parse.h printf-parse.c \
+  vasnprintf.h vasnwprintf.h vasnprintf.c \
+  os2compat.h \
+  libgnuintl.h.in
+SOURCES = \
+  bindtextdom.c \
+  dcgettext.c \
+  dgettext.c \
+  gettext.c \
+  finddomain.c \
+  loadmsgcat.c \
+  localealias.c \
+  textdomain.c \
+  l10nflist.c \
+  explodename.c \
+  dcigettext.c \
+  dcngettext.c \
+  dngettext.c \
+  ngettext.c \
+  plural.y \
+  plural-exp.c \
+  localcharset.c \
+  relocatable.c \
+  langprefs.c \
+  localename.c \
+  log.c \
+  printf.c \
+  osdep.c \
+  os2compat.c \
+  intl-compat.c
+OBJECTS = \
+  bindtextdom.$lo \
+  dcgettext.$lo \
+  dgettext.$lo \
+  gettext.$lo \
+  finddomain.$lo \
+  loadmsgcat.$lo \
+  localealias.$lo \
+  textdomain.$lo \
+  l10nflist.$lo \
+  explodename.$lo \
+  dcigettext.$lo \
+  dcngettext.$lo \
+  dngettext.$lo \
+  ngettext.$lo \
+  plural.$lo \
+  plural-exp.$lo \
+  localcharset.$lo \
+  relocatable.$lo \
+  langprefs.$lo \
+  localename.$lo \
+  log.$lo \
+  printf.$lo \
+  osdep.$lo \
+  intl-compat.$lo
 DISTFILES.common = Makefile.in \
 config.charset locale.alias ref-add.sin ref-del.sin $(HEADERS) $(SOURCES)
 DISTFILES.generated = plural.c
 DISTFILES.normal = VERSION
-DISTFILES.gettext = COPYING.LIB-2.0 COPYING.LIB-2.1 libintl.glibc
+DISTFILES.gettext = COPYING.LIB-2.0 COPYING.LIB-2.1 libintl.glibc \
+libgnuintl.h_vms Makefile.vms \
+libgnuintl.h.msvc-static libgnuintl.h.msvc-shared README.woe32 Makefile.msvc
 DISTFILES.obsolete = xopen-msg.sed linux-msg.sed po2tbl.sed.in cat-compat.c \
-COPYING.LIB-2 gettext.h libgettext.h plural-eval.c
+COPYING.LIB-2 gettext.h libgettext.h plural-eval.c libgnuintl.h
+
+all: all-@USE_INCLUDED_LIBINTL@
+all-yes: libintl.$la libintl.h charset.alias ref-add.sed ref-del.sed
+all-no: all-no-@BUILD_INCLUDED_LIBINTL@
+all-no-yes: libgnuintl.$la
+all-no-no:
+
+libintl.a libgnuintl.a: $(OBJECTS)
+	rm -f $@
+	$(AR) cru $@ $(OBJECTS)
+	$(RANLIB) $@
+
+libintl.la libgnuintl.la: $(OBJECTS)
+	$(LIBTOOL) --mode=link \
+	  $(CC) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS) $(LDFLAGS) -o $@ \
+	  $(OBJECTS) @LTLIBICONV@ @INTL_MACOSX_LIBS@ $(LIBS) -lc \
+	  -version-info $(LTV_CURRENT):$(LTV_REVISION):$(LTV_AGE) \
+	  -rpath $(libdir) \
+	  -no-undefined
 
 # Libtool's library version information for libintl.
 # Before making a gettext release, the gettext maintainer must change this
 # according to the libtool documentation, section "Library interface versions".
 # Maintainers of other packages that include the intl directory must *not*
 # change these values.
-LTV_CURRENT=4
-LTV_REVISION=0
-LTV_AGE=2
+LTV_CURRENT=7
+LTV_REVISION=3
+LTV_AGE=4
 
 .SUFFIXES:
 .SUFFIXES: .c .y .o .lo .sin .sed
+
 .c.o:
 	$(COMPILE) $<
-.c.lo:
-	$(LIBTOOL) --mode=compile $(COMPILE) $<
 
 .y.c:
 	$(YACC) $(YFLAGS) --output $@ $<
 	rm -f $*.h
 
-.sin.sed:
-	sed -e '/^#/d' -e 's/@''PACKAGE''@/@PACKAGE@/g' $< > t-$@
-	mv t-$@ $@
-
-INCLUDES = -I.. -I. -I$(top_srcdir)/intl -I../include
-
-all: all-@USE_INCLUDED_LIBINTL@
-all-yes: libintl.$la libintl.h charset.alias ref-add.sed ref-del.sed
-all-no: all-no-@BUILD_INCLUDED_LIBINTL@
-all-no-yes: libgnuintl.$la
-all-no-no:
-
-libintl.a libgnuintl.a: $(OBJECTS)
-	rm -f $@
-	$(AR) cru $@ $(OBJECTS)
-	$(RANLIB) $@
-
-libintl.la libgnuintl.la: $(OBJECTS)
-	$(LIBTOOL) --mode=link \
-	  $(CC) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS) $(LDFLAGS) -o $@ \
-	  $(OBJECTS) @LTLIBICONV@ -lc \
-	  -version-info $(LTV_CURRENT):$(LTV_REVISION):$(LTV_AGE) \
-	  -rpath $(libdir) \
-	  -no-undefined
+bindtextdom.lo: $(srcdir)/bindtextdom.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/bindtextdom.c
+dcgettext.lo: $(srcdir)/dcgettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/dcgettext.c
+dgettext.lo: $(srcdir)/dgettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/dgettext.c
+gettext.lo: $(srcdir)/gettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/gettext.c
+finddomain.lo: $(srcdir)/finddomain.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/finddomain.c
+loadmsgcat.lo: $(srcdir)/loadmsgcat.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/loadmsgcat.c
+localealias.lo: $(srcdir)/localealias.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/localealias.c
+textdomain.lo: $(srcdir)/textdomain.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/textdomain.c
+l10nflist.lo: $(srcdir)/l10nflist.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/l10nflist.c
+explodename.lo: $(srcdir)/explodename.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/explodename.c
+dcigettext.lo: $(srcdir)/dcigettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/dcigettext.c
+dcngettext.lo: $(srcdir)/dcngettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/dcngettext.c
+dngettext.lo: $(srcdir)/dngettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/dngettext.c
+ngettext.lo: $(srcdir)/ngettext.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/ngettext.c
+plural.lo: $(srcdir)/plural.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/plural.c
+plural-exp.lo: $(srcdir)/plural-exp.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/plural-exp.c
+localcharset.lo: $(srcdir)/localcharset.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/localcharset.c
+relocatable.lo: $(srcdir)/relocatable.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/relocatable.c
+langprefs.lo: $(srcdir)/langprefs.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/langprefs.c
+localename.lo: $(srcdir)/localename.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/localename.c
+log.lo: $(srcdir)/log.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/log.c
+printf.lo: $(srcdir)/printf.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/printf.c
+osdep.lo: $(srcdir)/osdep.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/osdep.c
+intl-compat.lo: $(srcdir)/intl-compat.c
+	$(LIBTOOL) --mode=compile $(COMPILE) $(srcdir)/intl-compat.c
+
+ref-add.sed: $(srcdir)/ref-add.sin
+	sed -e '/^#/d' -e 's/@''PACKAGE''@/@PACKAGE@/g' $(srcdir)/ref-add.sin > t-ref-add.sed
+	mv t-ref-add.sed ref-add.sed
+ref-del.sed: $(srcdir)/ref-del.sin
+	sed -e '/^#/d' -e 's/@''PACKAGE''@/@PACKAGE@/g' $(srcdir)/ref-del.sin > t-ref-del.sed
+	mv t-ref-del.sed ref-del.sed
+
+INCLUDES = -I. -I$(srcdir) -I$(top_builddir)/include
+
+libgnuintl.h: $(srcdir)/libgnuintl.h.in
+	sed -e 's,@''HAVE_POSIX_PRINTF''@,@HAVE_POSIX_PRINTF@,g' \
+	    -e 's,@''HAVE_ASPRINTF''@,@HAVE_ASPRINTF@,g' \
+	    -e 's,@''HAVE_SNPRINTF''@,@HAVE_SNPRINTF@,g' \
+	    -e 's,@''HAVE_WPRINTF''@,@HAVE_WPRINTF@,g' \
+	  < $(srcdir)/libgnuintl.h.in > libgnuintl.h
 
 libintl.h: libgnuintl.h
-	cp $(srcdir)/libgnuintl.h libintl.h
-
-charset.alias: config.charset
+	cp libgnuintl.h libintl.h
+
+charset.alias: $(srcdir)/config.charset
 	$(SHELL) $(srcdir)/config.charset '@host@' > t-$@
 	mv t-$@ $@
 
 check: all
-
-# This installation goal is only used in GNU gettext.  Packages which
-# only use the library should use install instead.
 
 # We must not install the libintl.h/libintl.a files if we are on a
 # system which has the GNU gettext() function in its C library or in a
@@ -143,12 +259,31 @@ check: all
 # package, you have to use `configure --with-included-gettext'.
 install: install-exec install-data
 install-exec: all
-	if test "$(PACKAGE)" = "gettext" \
-	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	if { test "$(PACKAGE)" = "gettext-runtime" || test "$(PACKAGE)" = "gettext-tools"; } \
+	   && test '@USE_INCLUDED_LIBINTL@' = yes; then \
 	  $(mkinstalldirs) $(DESTDIR)$(libdir) $(DESTDIR)$(includedir); \
 	  $(INSTALL_DATA) libintl.h $(DESTDIR)$(includedir)/libintl.h; \
 	  $(LIBTOOL) --mode=install \
 	    $(INSTALL_DATA) libintl.$la $(DESTDIR)$(libdir)/libintl.$la; \
+	  if test "@RELOCATABLE@" = yes; then \
+	    dependencies=`sed -n -e 's,^dependency_libs=\(.*\),\1,p' < $(DESTDIR)$(libdir)/libintl.la | sed -e "s,^',," -e "s,'\$$,,"`; \
+	    if test -n "$$dependencies"; then \
+	      rm -f $(DESTDIR)$(libdir)/libintl.la; \
+	    fi; \
+	  fi; \
+	else \
+	  : ; \
+	fi
+	if test "$(PACKAGE)" = "gettext-tools" \
+	   && test '@USE_INCLUDED_LIBINTL@' = no \
+	   && test @GLIBC2@ != no; then \
+	  $(mkinstalldirs) $(DESTDIR)$(libdir); \
+	  $(LIBTOOL) --mode=install \
+	    $(INSTALL_DATA) libgnuintl.$la $(DESTDIR)$(libdir)/libgnuintl.$la; \
+	  rm -f $(DESTDIR)$(libdir)/preloadable_libintl.so; \
+	  $(INSTALL_DATA) $(DESTDIR)$(libdir)/libgnuintl.so $(DESTDIR)$(libdir)/preloadable_libintl.so; \
+	  $(LIBTOOL) --mode=uninstall \
+	    rm -f $(DESTDIR)$(libdir)/libgnuintl.$la; \
 	else \
 	  : ; \
 	fi
@@ -182,7 +317,7 @@ install-exec: all
 	  : ; \
 	fi
 install-data: all
-	if test "$(PACKAGE)" = "gettext"; then \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
 	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
 	  $(INSTALL_DATA) VERSION $(DESTDIR)$(gettextsrcdir)/VERSION; \
 	  $(INSTALL_DATA) ChangeLog.inst $(DESTDIR)$(gettextsrcdir)/ChangeLog; \
@@ -209,9 +344,16 @@ install-strip: install
 install-strip: install
 
 installdirs:
-	if test "$(PACKAGE)" = "gettext" \
-	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	if { test "$(PACKAGE)" = "gettext-runtime" || test "$(PACKAGE)" = "gettext-tools"; } \
+	   && test '@USE_INCLUDED_LIBINTL@' = yes; then \
 	  $(mkinstalldirs) $(DESTDIR)$(libdir) $(DESTDIR)$(includedir); \
+	else \
+	  : ; \
+	fi
+	if test "$(PACKAGE)" = "gettext-tools" \
+	   && test '@USE_INCLUDED_LIBINTL@' = no \
+	   && test @GLIBC2@ != no; then \
+	  $(mkinstalldirs) $(DESTDIR)$(libdir); \
 	else \
 	  : ; \
 	fi
@@ -221,7 +363,7 @@ installdirs:
 	else \
 	  : ; \
 	fi
-	if test "$(PACKAGE)" = "gettext"; then \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
 	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
 	else \
 	  : ; \
@@ -231,11 +373,18 @@ installcheck:
 installcheck:
 
 uninstall:
-	if test "$(PACKAGE)" = "gettext" \
-	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	if { test "$(PACKAGE)" = "gettext-runtime" || test "$(PACKAGE)" = "gettext-tools"; } \
+	   && test '@USE_INCLUDED_LIBINTL@' = yes; then \
 	  rm -f $(DESTDIR)$(includedir)/libintl.h; \
 	  $(LIBTOOL) --mode=uninstall \
 	    rm -f $(DESTDIR)$(libdir)/libintl.$la; \
+	else \
+	  : ; \
+	fi
+	if test "$(PACKAGE)" = "gettext-tools" \
+	   && test '@USE_INCLUDED_LIBINTL@' = no \
+	   && test @GLIBC2@ != no; then \
+	  rm -f $(DESTDIR)$(libdir)/preloadable_libintl.so; \
 	else \
 	  : ; \
 	fi
@@ -265,7 +414,7 @@ uninstall:
 	else \
 	  : ; \
 	fi
-	if test "$(PACKAGE)" = "gettext"; then \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
 	  for file in VERSION ChangeLog COPYING.LIB-2.0 COPYING.LIB-2.1 $(DISTFILES.common) $(DISTFILES.generated); do \
 	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
 	  done; \
@@ -273,20 +422,28 @@ uninstall:
 	  : ; \
 	fi
 
-info dvi:
-
-$(OBJECTS): ../include/config.h libgnuintl.h
-bindtextdom.$lo dcgettext.$lo dcigettext.$lo dcngettext.$lo dgettext.$lo dngettext.$lo finddomain.$lo gettext.$lo intl-compat.$lo loadmsgcat.$lo localealias.$lo ngettext.$lo textdomain.$lo: gettextP.h gmo.h loadinfo.h
-dcigettext.$lo: hash-string.h
-explodename.$lo l10nflist.$lo: loadinfo.h
-dcigettext.$lo loadmsgcat.$lo plural.$lo plural-exp.$lo: plural-exp.h
-dcigettext.$lo: eval-plural.h
+info dvi ps pdf html:
+
+$(OBJECTS): $(top_builddir)/include/config.h libgnuintl.h
+bindtextdom.$lo dcgettext.$lo dcigettext.$lo dcngettext.$lo dgettext.$lo dngettext.$lo finddomain.$lo gettext.$lo intl-compat.$lo loadmsgcat.$lo localealias.$lo ngettext.$lo textdomain.$lo: $(srcdir)/gettextP.h $(srcdir)/gmo.h $(srcdir)/loadinfo.h
+dcigettext.$lo loadmsgcat.$lo: $(srcdir)/hash-string.h
+explodename.$lo l10nflist.$lo: $(srcdir)/loadinfo.h
+dcigettext.$lo loadmsgcat.$lo plural.$lo plural-exp.$lo: $(srcdir)/plural-exp.h
+dcigettext.$lo: $(srcdir)/eval-plural.h
+localcharset.$lo: $(srcdir)/localcharset.h
+localealias.$lo localcharset.$lo relocatable.$lo: $(srcdir)/relocatable.h
+printf.$lo: $(srcdir)/printf-args.h $(srcdir)/printf-args.c $(srcdir)/printf-parse.h $(srcdir)/wprintf-parse.h $(srcdir)/xsize.h $(srcdir)/printf-parse.c $(srcdir)/vasnprintf.h $(srcdir)/vasnwprintf.h $(srcdir)/vasnprintf.c
 
 tags: TAGS
 
 TAGS: $(HEADERS) $(SOURCES)
 	here=`pwd`; cd $(srcdir) && etags -o $$here/TAGS $(HEADERS) $(SOURCES)
 
+ctags: CTAGS
+
+CTAGS: $(HEADERS) $(SOURCES)
+	here=`pwd`; cd $(srcdir) && ctags -o $$here/CTAGS $(HEADERS) $(SOURCES)
+
 id: ID
 
 ID: $(HEADERS) $(SOURCES)
@@ -294,15 +451,15 @@ ID: $(HEADERS) $(SOURCES)
 
 
 mostlyclean:
-	rm -f *.a *.la *.o *.lo core core.*
-	rm -f libintl.h charset.alias ref-add.sed ref-del.sed
+	rm -f *.a *.la *.o *.obj *.lo core core.*
+	rm -f libgnuintl.h libintl.h charset.alias ref-add.sed ref-del.sed
 	rm -f -r .libs _libs
 
 clean: mostlyclean
 
 distclean: clean
 	rm -f Makefile ID TAGS
-	if test "$(PACKAGE)" = gettext; then \
+	if test "$(PACKAGE)" = "gettext-runtime" || test "$(PACKAGE)" = "gettext-tools"; then \
 	  rm -f ChangeLog.inst $(DISTFILES.normal); \
 	else \
 	  : ; \
@@ -317,20 +474,26 @@ maintainer-clean: distclean
 # other files which should not be distributed in other packages.
 distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
 dist distdir: Makefile
-	if test "$(PACKAGE)" = gettext; then \
-	  additional="$(DISTFILES.gettext)"; \
-	else \
-	  additional="$(DISTFILES.normal)"; \
-	fi; \
-	$(MAKE) $(DISTFILES.common) $(DISTFILES.generated) $$additional; \
-	for file in ChangeLog $(DISTFILES.common) $(DISTFILES.generated) $$additional; do \
-	  if test -f $$file; then dir=.; else dir=$(srcdir); fi; \
-	  cp -p $$dir/$$file $(distdir); \
-	done
-
-Makefile: Makefile.in ../config.status
-	cd .. \
-	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+	if test "$(PACKAGE)" = "gettext-tools"; then \
+	  : ; \
+	else \
+	  if test "$(PACKAGE)" = "gettext-runtime"; then \
+	    additional="$(DISTFILES.gettext)"; \
+	  else \
+	    additional="$(DISTFILES.normal)"; \
+	  fi; \
+	  $(MAKE) $(DISTFILES.common) $(DISTFILES.generated) $$additional; \
+	  for file in ChangeLog $(DISTFILES.common) $(DISTFILES.generated) $$additional; do \
+	    if test -f $$file; then dir=.; else dir=$(srcdir); fi; \
+	    cp -p $$dir/$$file $(distdir) || test $$file = Makefile.in || exit 1; \
+	  done; \
+	fi
+
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status
+# This would be more efficient, but doesn't work any more with autoconf-2.57,
+# when AC_CONFIG_FILES([intl/Makefile:somedir/Makefile.in]) is used.
+#	cd $(top_builddir) && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
 
 # Tell versions [3.59,3.63) of GNU make not to export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -r 4216c218ee44 -r e04165992166 intl/VERSION
--- a/intl/VERSION	Sat May 28 13:40:15 2005 +0000
+++ b/intl/VERSION	Sat May 28 13:45:22 2005 +0000
@@ -1,1 +1,1 @@ GNU gettext library from gettext-0.11.5
-GNU gettext library from gettext-0.11.5
+GNU gettext library from gettext-0.14.4
diff -r 4216c218ee44 -r e04165992166 intl/bindtextdom.c
--- a/intl/bindtextdom.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/bindtextdom.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the bindtextdomain(3) function
-   Copyright (C) 1995-1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -58,6 +58,11 @@
 
 /* Contains the default location of the message catalogs.  */
 extern const char _nl_default_dirname[];
+#ifdef _LIBC
+extern const char _nl_default_dirname_internal[] attribute_hidden;
+#else
+# define INTUSE(name) name
+#endif
 
 /* List with bindings of specific domains.  */
 extern struct binding *_nl_domain_bindings;
@@ -80,11 +85,6 @@ __libc_rwlock_define (extern, _nl_state_
 # define BINDTEXTDOMAIN libintl_bindtextdomain
 # define BIND_TEXTDOMAIN_CODESET libintl_bind_textdomain_codeset
 #endif
-
-/* Prototypes for local functions.  */
-static void set_binding_values PARAMS ((const char *domainname,
-					const char **dirnamep,
-					const char **codesetp));
 
 /* Specifies the directory name *DIRNAMEP and the output codeset *CODESETP
    to be used for the DOMAINNAME message catalog.
@@ -93,10 +93,8 @@ static void set_binding_values PARAMS ((
    If DIRNAMEP or CODESETP is NULL, the corresponding attribute is neither
    modified nor returned.  */
 static void
-set_binding_values (domainname, dirnamep, codesetp)
-     const char *domainname;
-     const char **dirnamep;
-     const char **codesetp;
+set_binding_values (const char *domainname,
+		    const char **dirnamep, const char **codesetp)
 {
   struct binding *binding;
   int modified;
@@ -146,8 +144,8 @@ set_binding_values (domainname, dirnamep
 	      char *result = binding->dirname;
 	      if (strcmp (dirname, result) != 0)
 		{
-		  if (strcmp (dirname, _nl_default_dirname) == 0)
-		    result = (char *) _nl_default_dirname;
+		  if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
+		    result = (char *) INTUSE(_nl_default_dirname);
 		  else
 		    {
 #if defined _LIBC || defined HAVE_STRDUP
@@ -162,7 +160,7 @@ set_binding_values (domainname, dirnamep
 
 		  if (__builtin_expect (result != NULL, 1))
 		    {
-		      if (binding->dirname != _nl_default_dirname)
+		      if (binding->dirname != INTUSE(_nl_default_dirname))
 			free (binding->dirname);
 
 		      binding->dirname = result;
@@ -216,7 +214,7 @@ set_binding_values (domainname, dirnamep
     {
       /* Simply return the default values.  */
       if (dirnamep)
-	*dirnamep = _nl_default_dirname;
+	*dirnamep = INTUSE(_nl_default_dirname);
       if (codesetp)
 	*codesetp = NULL;
     }
@@ -238,11 +236,11 @@ set_binding_values (domainname, dirnamep
 
 	  if (dirname == NULL)
 	    /* The default value.  */
-	    dirname = _nl_default_dirname;
+	    dirname = INTUSE(_nl_default_dirname);
 	  else
 	    {
-	      if (strcmp (dirname, _nl_default_dirname) == 0)
-		dirname = _nl_default_dirname;
+	      if (strcmp (dirname, INTUSE(_nl_default_dirname)) == 0)
+		dirname = INTUSE(_nl_default_dirname);
 	      else
 		{
 		  char *result;
@@ -265,7 +263,7 @@ set_binding_values (domainname, dirnamep
 	}
       else
 	/* The default value.  */
-	new_binding->dirname = (char *) _nl_default_dirname;
+	new_binding->dirname = (char *) INTUSE(_nl_default_dirname);
 
       new_binding->codeset_cntr = 0;
 
@@ -321,7 +319,7 @@ set_binding_values (domainname, dirnamep
       if (0)
 	{
 	failed_codeset:
-	  if (new_binding->dirname != _nl_default_dirname)
+	  if (new_binding->dirname != INTUSE(_nl_default_dirname))
 	    free (new_binding->dirname);
 	failed_dirname:
 	  free (new_binding);
@@ -343,9 +341,7 @@ set_binding_values (domainname, dirnamep
 /* Specify that the DOMAINNAME message catalog will be found
    in DIRNAME rather than in the system locale data base.  */
 char *
-BINDTEXTDOMAIN (domainname, dirname)
-     const char *domainname;
-     const char *dirname;
+BINDTEXTDOMAIN (const char *domainname, const char *dirname)
 {
   set_binding_values (domainname, &dirname, NULL);
   return (char *) dirname;
@@ -354,9 +350,7 @@ BINDTEXTDOMAIN (domainname, dirname)
 /* Specify the character encoding in which the messages from the
    DOMAINNAME message catalog will be returned.  */
 char *
-BIND_TEXTDOMAIN_CODESET (domainname, codeset)
-     const char *domainname;
-     const char *codeset;
+BIND_TEXTDOMAIN_CODESET (const char *domainname, const char *codeset)
 {
   set_binding_values (domainname, NULL, &codeset);
   return (char *) codeset;
diff -r 4216c218ee44 -r e04165992166 intl/config.charset
--- a/intl/config.charset	Sat May 28 13:40:15 2005 +0000
+++ b/intl/config.charset	Sat May 28 13:45:22 2005 +0000
@@ -1,7 +1,7 @@
 #! /bin/sh
 # Output a system dependent table of character encoding aliases.
 #
-#   Copyright (C) 2000-2002 Free Software Foundation, Inc.
+#   Copyright (C) 2000-2004 Free Software Foundation, Inc.
 #
 #   This program is free software; you can redistribute it and/or modify it
 #   under the terms of the GNU Library General Public License as published
@@ -30,77 +30,77 @@
 # MIME charset name is preferred.
 # The current list of GNU canonical charset names is as follows.
 #
-#       name                         used by which systems         a MIME name?
-#   ASCII, ANSI_X3.4-1968     glibc solaris freebsd
-#   ISO-8859-1                glibc aix hpux irix osf solaris freebsd   yes
-#   ISO-8859-2                glibc aix hpux irix osf solaris freebsd   yes
-#   ISO-8859-3                glibc solaris                             yes
-#   ISO-8859-4                osf solaris freebsd                       yes
-#   ISO-8859-5                glibc aix hpux irix osf solaris freebsd   yes
-#   ISO-8859-6                glibc aix hpux solaris                    yes
-#   ISO-8859-7                glibc aix hpux irix osf solaris           yes
-#   ISO-8859-8                glibc aix hpux osf solaris                yes
-#   ISO-8859-9                glibc aix hpux irix osf solaris           yes
-#   ISO-8859-13               glibc
-#   ISO-8859-14               glibc
-#   ISO-8859-15               glibc aix osf solaris freebsd
-#   KOI8-R                    glibc solaris freebsd                     yes
-#   KOI8-U                    glibc freebsd                             yes
-#   KOI8-T                    glibc
-#   CP437                     dos
-#   CP775                     dos
-#   CP850                     aix osf dos
-#   CP852                     dos
-#   CP855                     dos
-#   CP856                     aix
-#   CP857                     dos
-#   CP861                     dos
-#   CP862                     dos
-#   CP864                     dos
-#   CP865                     dos
-#   CP866                     freebsd dos
-#   CP869                     dos
-#   CP874                     woe32 dos
-#   CP922                     aix
-#   CP932                     aix woe32 dos
-#   CP943                     aix
-#   CP949                     osf woe32 dos
-#   CP950                     woe32 dos
-#   CP1046                    aix
-#   CP1124                    aix
-#   CP1125                    dos
-#   CP1129                    aix
-#   CP1250                    woe32
-#   CP1251                    glibc woe32
-#   CP1252                    aix woe32
-#   CP1253                    woe32
-#   CP1254                    woe32
-#   CP1255                    glibc woe32
-#   CP1256                    woe32
-#   CP1257                    woe32
-#   GB2312                    glibc aix hpux irix solaris freebsd       yes
-#   EUC-JP                    glibc aix hpux irix osf solaris freebsd   yes
-#   EUC-KR                    glibc aix hpux irix osf solaris freebsd   yes
-#   EUC-TW                    glibc aix hpux irix osf solaris
-#   BIG5                      glibc aix hpux osf solaris freebsd        yes
-#   BIG5-HKSCS                glibc solaris
-#   GBK                       glibc aix osf solaris woe32 dos
-#   GB18030                   glibc solaris
-#   SHIFT_JIS                 hpux osf solaris freebsd                  yes
-#   JOHAB                     glibc solaris woe32
-#   TIS-620                   glibc aix hpux osf solaris
-#   VISCII                    glibc                                     yes
-#   TCVN5712-1                glibc
-#   GEORGIAN-PS               glibc
-#   HP-ROMAN8                 hpux
-#   HP-ARABIC8                hpux
-#   HP-GREEK8                 hpux
-#   HP-HEBREW8                hpux
-#   HP-TURKISH8               hpux
-#   HP-KANA8                  hpux
-#   DEC-KANJI                 osf
-#   DEC-HANYU                 osf
-#   UTF-8                     glibc aix hpux osf solaris                yes
+#       name              MIME?             used by which systems
+#   ASCII, ANSI_X3.4-1968       glibc solaris freebsd darwin
+#   ISO-8859-1              Y   glibc aix hpux irix osf solaris freebsd darwin
+#   ISO-8859-2              Y   glibc aix hpux irix osf solaris freebsd darwin
+#   ISO-8859-3              Y   glibc solaris
+#   ISO-8859-4              Y   osf solaris freebsd darwin
+#   ISO-8859-5              Y   glibc aix hpux irix osf solaris freebsd darwin
+#   ISO-8859-6              Y   glibc aix hpux solaris
+#   ISO-8859-7              Y   glibc aix hpux irix osf solaris darwin
+#   ISO-8859-8              Y   glibc aix hpux osf solaris
+#   ISO-8859-9              Y   glibc aix hpux irix osf solaris darwin
+#   ISO-8859-13                 glibc darwin
+#   ISO-8859-14                 glibc
+#   ISO-8859-15                 glibc aix osf solaris freebsd darwin
+#   KOI8-R                  Y   glibc solaris freebsd darwin
+#   KOI8-U                  Y   glibc freebsd darwin
+#   KOI8-T                      glibc
+#   CP437                       dos
+#   CP775                       dos
+#   CP850                       aix osf dos
+#   CP852                       dos
+#   CP855                       dos
+#   CP856                       aix
+#   CP857                       dos
+#   CP861                       dos
+#   CP862                       dos
+#   CP864                       dos
+#   CP865                       dos
+#   CP866                       freebsd darwin dos
+#   CP869                       dos
+#   CP874                       woe32 dos
+#   CP922                       aix
+#   CP932                       aix woe32 dos
+#   CP943                       aix
+#   CP949                       osf woe32 dos
+#   CP950                       woe32 dos
+#   CP1046                      aix
+#   CP1124                      aix
+#   CP1125                      dos
+#   CP1129                      aix
+#   CP1250                      woe32
+#   CP1251                      glibc solaris darwin woe32
+#   CP1252                      aix woe32
+#   CP1253                      woe32
+#   CP1254                      woe32
+#   CP1255                      glibc woe32
+#   CP1256                      woe32
+#   CP1257                      woe32
+#   GB2312                  Y   glibc aix hpux irix solaris freebsd darwin
+#   EUC-JP                  Y   glibc aix hpux irix osf solaris freebsd darwin
+#   EUC-KR                  Y   glibc aix hpux irix osf solaris freebsd darwin
+#   EUC-TW                      glibc aix hpux irix osf solaris
+#   BIG5                    Y   glibc aix hpux osf solaris freebsd darwin
+#   BIG5-HKSCS                  glibc solaris
+#   GBK                         glibc aix osf solaris woe32 dos
+#   GB18030                     glibc solaris
+#   SHIFT_JIS               Y   hpux osf solaris freebsd darwin
+#   JOHAB                       glibc solaris woe32
+#   TIS-620                     glibc aix hpux osf solaris
+#   VISCII                  Y   glibc
+#   TCVN5712-1                  glibc
+#   GEORGIAN-PS                 glibc
+#   HP-ROMAN8                   hpux
+#   HP-ARABIC8                  hpux
+#   HP-GREEK8                   hpux
+#   HP-HEBREW8                  hpux
+#   HP-TURKISH8                 hpux
+#   HP-KANA8                    hpux
+#   DEC-KANJI                   osf
+#   DEC-HANYU                   osf
+#   UTF-8                   Y   glibc aix hpux osf solaris darwin
 #
 # Note: Names which are not marked as being a MIME name should not be used in
 # Internet protocols for information interchange (mail, news, etc.).
@@ -121,6 +121,105 @@ echo "# It was automatically generated f
 # List of references, updated during installation:
 echo "# Packages using this file: "
 case "$os" in
+    linux-gnulibc1*)
+	# Linux libc5 doesn't have nl_langinfo(CODESET); therefore
+	# localcharset.c falls back to using the full locale name
+	# from the environment variables.
+	echo "C ASCII"
+	echo "POSIX ASCII"
+	for l in af af_ZA ca ca_ES da da_DK de de_AT de_BE de_CH de_DE de_LU \
+	         en en_AU en_BW en_CA en_DK en_GB en_IE en_NZ en_US en_ZA \
+	         en_ZW es es_AR es_BO es_CL es_CO es_DO es_EC es_ES es_GT \
+	         es_HN es_MX es_PA es_PE es_PY es_SV es_US es_UY es_VE et \
+	         et_EE eu eu_ES fi fi_FI fo fo_FO fr fr_BE fr_CA fr_CH fr_FR \
+	         fr_LU ga ga_IE gl gl_ES id id_ID in in_ID is is_IS it it_CH \
+	         it_IT kl kl_GL nl nl_BE nl_NL no no_NO pt pt_BR pt_PT sv \
+	         sv_FI sv_SE; do
+	  echo "$l ISO-8859-1"
+	  echo "$l.iso-8859-1 ISO-8859-1"
+	  echo "$l.iso-8859-15 ISO-8859-15"
+	  echo "$l.iso-8859-15@euro ISO-8859-15"
+	  echo "$l@euro ISO-8859-15"
+	  echo "$l.cp-437 CP437"
+	  echo "$l.cp-850 CP850"
+	  echo "$l.cp-1252 CP1252"
+	  echo "$l.cp-1252@euro CP1252"
+	  #echo "$l.atari-st ATARI-ST" # not a commonly used encoding
+	  echo "$l.utf-8 UTF-8"
+	  echo "$l.utf-8@euro UTF-8"
+	done
+	for l in cs cs_CZ hr hr_HR hu hu_HU pl pl_PL ro ro_RO sk sk_SK sl \
+	         sl_SI sr sr_CS sr_YU; do
+	  echo "$l ISO-8859-2"
+	  echo "$l.iso-8859-2 ISO-8859-2"
+	  echo "$l.cp-852 CP852"
+	  echo "$l.cp-1250 CP1250"
+	  echo "$l.utf-8 UTF-8"
+	done
+	for l in mk mk_MK ru ru_RU; do
+	  echo "$l ISO-8859-5"
+	  echo "$l.iso-8859-5 ISO-8859-5"
+	  echo "$l.koi8-r KOI8-R"
+	  echo "$l.cp-866 CP866"
+	  echo "$l.cp-1251 CP1251"
+	  echo "$l.utf-8 UTF-8"
+	done
+	for l in ar ar_SA; do
+	  echo "$l ISO-8859-6"
+	  echo "$l.iso-8859-6 ISO-8859-6"
+	  echo "$l.cp-864 CP864"
+	  #echo "$l.cp-868 CP868" # not a commonly used encoding
+	  echo "$l.cp-1256 CP1256"
+	  echo "$l.utf-8 UTF-8"
+	done
+	for l in el el_GR gr gr_GR; do
+	  echo "$l ISO-8859-7"
+	  echo "$l.iso-8859-7 ISO-8859-7"
+	  echo "$l.cp-869 CP869"
+	  echo "$l.cp-1253 CP1253"
+	  echo "$l.cp-1253@euro CP1253"
+	  echo "$l.utf-8 UTF-8"
+	  echo "$l.utf-8@euro UTF-8"
+	done
+	for l in he he_IL iw iw_IL; do
+	  echo "$l ISO-8859-8"
+	  echo "$l.iso-8859-8 ISO-8859-8"
+	  echo "$l.cp-862 CP862"
+	  echo "$l.cp-1255 CP1255"
+	  echo "$l.utf-8 UTF-8"
+	done
+	for l in tr tr_TR; do
+	  echo "$l ISO-8859-9"
+	  echo "$l.iso-8859-9 ISO-8859-9"
+	  echo "$l.cp-857 CP857"
+	  echo "$l.cp-1254 CP1254"
+	  echo "$l.utf-8 UTF-8"
+	done
+	for l in lt lt_LT lv lv_LV; do
+	  #echo "$l BALTIC" # not a commonly used encoding, wrong encoding name
+	  echo "$l ISO-8859-13"
+	done
+	for l in ru_UA uk uk_UA; do
+	  echo "$l KOI8-U"
+	done
+	for l in zh zh_CN; do
+	  #echo "$l GB_2312-80" # not a commonly used encoding, wrong encoding name
+	  echo "$l GB2312"
+	done
+	for l in ja ja_JP ja_JP.EUC; do
+	  echo "$l EUC-JP"
+	done
+	for l in ko ko_KR; do
+	  echo "$l EUC-KR"
+	done
+	for l in th th_TH; do
+	  echo "$l TIS-620"
+	done
+	for l in fa fa_IR; do
+	  #echo "$l ISIRI-3342" # a broken encoding
+	  echo "$l.utf-8 UTF-8"
+	done
+	;;
     linux* | *-gnu*)
 	# With glibc-2.1 or newer, we don't need any canonicalization,
 	# because glibc has iconv and both glibc and libiconv support all
@@ -231,6 +330,7 @@ case "$os" in
 	echo "ISO8859-9 ISO-8859-9"
 	echo "ISO8859-15 ISO-8859-15"
 	echo "koi8-r KOI8-R"
+	echo "ansi-1251 CP1251"
 	echo "BIG5 BIG5"
 	echo "Big5-HKSCS BIG5-HKSCS"
 	echo "gb2312 GB2312"
@@ -295,6 +395,77 @@ case "$os" in
 	echo "eucTW EUC-TW"
 	echo "BIG5 BIG5"
 	echo "SJIS SHIFT_JIS"
+	;;
+    darwin[56]*)
+	# Darwin 6.8 doesn't have nl_langinfo(CODESET); therefore
+	# localcharset.c falls back to using the full locale name
+	# from the environment variables.
+	echo "C ASCII"
+	for l in en_AU en_CA en_GB en_US la_LN; do
+	  echo "$l.US-ASCII ASCII"
+	done
+	for l in da_DK de_AT de_CH de_DE en_AU en_CA en_GB en_US es_ES \
+	         fi_FI fr_BE fr_CA fr_CH fr_FR is_IS it_CH it_IT nl_BE \
+	         nl_NL no_NO pt_PT sv_SE; do
+	  echo "$l ISO-8859-1"
+	  echo "$l.ISO8859-1 ISO-8859-1"
+	  echo "$l.ISO8859-15 ISO-8859-15"
+	done
+	for l in la_LN; do
+	  echo "$l.ISO8859-1 ISO-8859-1"
+	  echo "$l.ISO8859-15 ISO-8859-15"
+	done
+	for l in cs_CZ hr_HR hu_HU la_LN pl_PL sl_SI; do
+	  echo "$l.ISO8859-2 ISO-8859-2"
+	done
+	for l in la_LN lt_LT; do
+	  echo "$l.ISO8859-4 ISO-8859-4"
+	done
+	for l in ru_RU; do
+	  echo "$l.KOI8-R KOI8-R"
+	  echo "$l.ISO8859-5 ISO-8859-5"
+	  echo "$l.CP866 CP866"
+	done
+	for l in bg_BG; do
+	  echo "$l.CP1251 CP1251"
+	done
+	echo "uk_UA.KOI8-U KOI8-U"
+	echo "zh_TW.BIG5 BIG5"
+	echo "zh_TW.Big5 BIG5"
+	echo "zh_CN.EUC GB2312"
+	echo "ja_JP.EUC EUC-JP"
+	echo "ja_JP.SJIS SHIFT_JIS"
+	echo "ko_KR.EUC EUC-KR"
+	;;
+    darwin*)
+	# Darwin 7.5 has nl_langinfo(CODESET), but it is useless:
+	# - It returns the empty string when LANG is set to a locale of the
+	#   form ll_CC, although ll_CC/LC_CTYPE is a symlink to an UTF-8
+	#   LC_CTYPE file.
+	# - The environment variables LANG, LC_CTYPE, LC_ALL are not set by
+	#   the system; nl_langinfo(CODESET) returns "US-ASCII" in this case.
+	# - The documentation says:
+	#     "... all code that calls BSD system routines should ensure
+	#      that the const *char parameters of these routines are in UTF-8
+	#      encoding. All BSD system functions expect their string
+	#      parameters to be in UTF-8 encoding and nothing else."
+	#   It also says
+	#     "An additional caveat is that string parameters for files,
+	#      paths, and other file-system entities must be in canonical
+	#      UTF-8. In a canonical UTF-8 Unicode string, all decomposable
+	#      characters are decomposed ..."
+	#   but this is not true: You can pass non-decomposed UTF-8 strings
+	#   to file system functions, and it is the OS which will convert
+	#   them to decomposed UTF-8 before accessing the file system.
+	# - The Apple Terminal application displays UTF-8 by default.
+	# - However, other applications are free to use different encodings:
+	#   - xterm uses ISO-8859-1 by default.
+	#   - TextEdit uses MacRoman by default.
+	# We prefer UTF-8 over decomposed UTF-8-MAC because one should
+	# minimize the use of decomposed Unicode. Unfortunately, through the
+	# Darwin file system, decomposed UTF-8 strings are leaked into user
+	# space nevertheless.
+	echo "* UTF-8"
 	;;
     beos*)
 	# BeOS has a single locale, and it has UTF-8 encoding.
@@ -409,6 +580,7 @@ case "$os" in
 	echo "sq CP852"
 	echo "sq_AL CP852"
 	echo "sr CP852"    # CP852 or CP866 or CP855 ??
+	echo "sr_CS CP852" # CP852 or CP866 or CP855 ??
 	echo "sr_YU CP852" # CP852 or CP866 or CP855 ??
 	# ISO-8859-3 languages
 	echo "mt CP850"
diff -r 4216c218ee44 -r e04165992166 intl/dcgettext.c
--- a/intl/dcgettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/dcgettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the dcgettext(3) function.
-   Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -44,10 +44,7 @@
 /* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
    locale.  */
 char *
-DCGETTEXT (domainname, msgid, category)
-     const char *domainname;
-     const char *msgid;
-     int category;
+DCGETTEXT (const char *domainname, const char *msgid, int category)
 {
   return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
 }
diff -r 4216c218ee44 -r e04165992166 intl/dcigettext.c
--- a/intl/dcigettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/dcigettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the internal dcigettext function.
-   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -33,14 +33,19 @@
 # define alloca __builtin_alloca
 # define HAVE_ALLOCA 1
 #else
-# if defined HAVE_ALLOCA_H || defined _LIBC
-#  include <alloca.h>
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
 # else
-#  ifdef _AIX
+#  if defined HAVE_ALLOCA_H || defined _LIBC
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
  #pragma alloca
-#  else
-#   ifndef alloca
+#   else
+#    ifndef alloca
 char *alloca ();
+#    endif
 #   endif
 #  endif
 # endif
@@ -143,13 +148,17 @@ char *getwd ();
 char *getwd ();
 #  define getcwd(buf, max) getwd (buf)
 # else
+#  if VMS
+#   define getcwd(buf, max) (getcwd) (buf, max, 0)
+#  else
 char *getcwd ();
+#  endif
 # endif
 # ifndef HAVE_STPCPY
-static char *stpcpy PARAMS ((char *dest, const char *src));
+static char *stpcpy (char *dest, const char *src);
 # endif
 # ifndef HAVE_MEMPCPY
-static void *mempcpy PARAMS ((void *dest, const void *src, size_t n));
+static void *mempcpy (void *dest, const void *src, size_t n);
 # endif
 #endif
 
@@ -191,8 +200,8 @@ static void *mempcpy PARAMS ((void *dest
                         it may be concatenated to a directory pathname.
    IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, OS/2, DOS */
+#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, Cygwin, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -243,11 +252,8 @@ static void *root;
 # endif
 
 /* Function to compare two entries in the table of known translations.  */
-static int transcmp PARAMS ((const void *p1, const void *p2));
 static int
-transcmp (p1, p2)
-     const void *p1;
-     const void *p2;
+transcmp (const void *p1, const void *p2)
 {
   const struct known_translation_t *s1;
   const struct known_translation_t *s2;
@@ -271,6 +277,13 @@ transcmp (p1, p2)
 }
 #endif
 
+#ifndef INTVARDEF
+# define INTVARDEF(name)
+#endif
+#ifndef INTUSE
+# define INTUSE(name) name
+#endif
+
 /* Name of the default domain used for gettext(3) prior any call to
    textdomain(3).  The default value for this is "messages".  */
 const char _nl_default_default_domain[] attribute_hidden = "messages";
@@ -284,6 +297,7 @@ extern const char _nl_default_dirname[];
 extern const char _nl_default_dirname[];
 #else
 const char _nl_default_dirname[] = LOCALEDIR;
+INTVARDEF (_nl_default_dirname)
 #endif
 
 /* List with bindings of specific domains created by bindtextdomain()
@@ -291,15 +305,19 @@ struct binding *_nl_domain_bindings;
 struct binding *_nl_domain_bindings;
 
 /* Prototypes for local functions.  */
-static char *plural_lookup PARAMS ((struct loaded_l10nfile *domain,
-				    unsigned long int n,
-				    const char *translation,
-				    size_t translation_len))
+static char *plural_lookup (struct loaded_l10nfile *domain,
+			    unsigned long int n,
+			    const char *translation, size_t translation_len)
      internal_function;
-static const char *category_to_name PARAMS ((int category)) internal_function;
-static const char *guess_category_value PARAMS ((int category,
-						 const char *categoryname))
+static const char *guess_category_value (int category,
+					 const char *categoryname)
      internal_function;
+#ifdef _LIBC
+# include "../locale/localeinfo.h"
+# define category_to_name(category)	_nl_category_names[category]
+#else
+static const char *category_to_name (int category) internal_function;
+#endif
 
 
 /* For those loosing systems which don't have `alloca' we have to add
@@ -406,13 +424,8 @@ static int enable_secure;
    CATEGORY locale and, if PLURAL is nonzero, search over string
    depending on the plural form determined by N.  */
 char *
-DCIGETTEXT (domainname, msgid1, msgid2, plural, n, category)
-     const char *domainname;
-     const char *msgid1;
-     const char *msgid2;
-     int plural;
-     unsigned long int n;
-     int category;
+DCIGETTEXT (const char *domainname, const char *msgid1, const char *msgid2,
+	    int plural, unsigned long int n, int category)
 {
 #ifndef HAVE_ALLOCA
   struct block_list *block_list = NULL;
@@ -437,6 +450,15 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
   if (msgid1 == NULL)
     return NULL;
 
+#ifdef _LIBC
+  if (category < 0 || category >= __LC_LAST || category == LC_ALL)
+    /* Bogus.  */
+    return (plural == 0
+	    ? (char *) msgid1
+	    /* Use the Germanic plural rule.  */
+	    : n == 1 ? (char *) msgid1 : (char *) msgid2);
+#endif
+
   __libc_rwlock_rdlock (_nl_state_lock);
 
   /* If DOMAINNAME is NULL, we are interested in the default domain.  If
@@ -500,7 +522,7 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
     }
 
   if (binding == NULL)
-    dirname = (char *) _nl_default_dirname;
+    dirname = (char *) INTUSE(_nl_default_dirname);
   else if (IS_ABSOLUTE_PATH (binding->dirname))
     dirname = binding->dirname;
   else
@@ -528,17 +550,9 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
 	}
 
       if (ret == NULL)
-	{
-	  /* We cannot get the current working directory.  Don't signal an
-	     error but simply return the default string.  */
-	  FREE_BLOCKS (block_list);
-	  __libc_rwlock_unlock (_nl_state_lock);
-	  __set_errno (saved_errno);
-	  return (plural == 0
-		  ? (char *) msgid1
-		  /* Use the Germanic plural rule.  */
-		  : n == 1 ? (char *) msgid1 : (char *) msgid2);
-	}
+	/* We cannot get the current working directory.  Don't signal an
+	   error but simply return the default string.  */
+	goto return_untranslated;
 
       stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
     }
@@ -595,16 +609,7 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
 	 domain.  Return the MSGID.  */
       if (strcmp (single_locale, "C") == 0
 	  || strcmp (single_locale, "POSIX") == 0)
-	{
-	  FREE_BLOCKS (block_list);
-	  __libc_rwlock_unlock (_nl_state_lock);
-	  __set_errno (saved_errno);
-	  return (plural == 0
-		  ? (char *) msgid1
-		  /* Use the Germanic plural rule.  */
-		  : n == 1 ? (char *) msgid1 : (char *) msgid2);
-	}
-
+	break;
 
       /* Find structure describing the message catalog matching the
 	 DOMAINNAME and CATEGORY.  */
@@ -636,7 +641,6 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
 	      /* Found the translation of MSGID1 in domain DOMAIN:
 		 starting at RETVAL, RETLEN bytes.  */
 	      FREE_BLOCKS (block_list);
-	      __set_errno (saved_errno);
 #if defined HAVE_TSEARCH || defined _LIBC
 	      if (foundp == NULL)
 		{
@@ -675,6 +679,8 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
 		  (*foundp)->translation_length = retlen;
 		}
 #endif
+	      __set_errno (saved_errno);
+
 	      /* Now deal with plural.  */
 	      if (plural)
 		retval = plural_lookup (domain, n, retval, retlen);
@@ -684,17 +690,37 @@ DCIGETTEXT (domainname, msgid1, msgid2, 
 	    }
 	}
     }
-  /* NOTREACHED */
+
+ return_untranslated:
+  /* Return the untranslated MSGID.  */
+  FREE_BLOCKS (block_list);
+  __libc_rwlock_unlock (_nl_state_lock);
+#ifndef _LIBC
+  if (!ENABLE_SECURE)
+    {
+      extern void _nl_log_untranslated (const char *logfilename,
+					const char *domainname,
+					const char *msgid1, const char *msgid2,
+					int plural);
+      const char *logfilename = getenv ("GETTEXT_LOG_UNTRANSLATED");
+
+      if (logfilename != NULL && logfilename[0] != '\0')
+	_nl_log_untranslated (logfilename, domainname, msgid1, msgid2, plural);
+    }
+#endif
+  __set_errno (saved_errno);
+  return (plural == 0
+	  ? (char *) msgid1
+	  /* Use the Germanic plural rule.  */
+	  : n == 1 ? (char *) msgid1 : (char *) msgid2);
 }
 
 
 char *
 internal_function
-_nl_find_msg (domain_file, domainbinding, msgid, lengthp)
-     struct loaded_l10nfile *domain_file;
-     struct binding *domainbinding;
-     const char *msgid;
-     size_t *lengthp;
+_nl_find_msg (struct loaded_l10nfile *domain_file,
+	      struct binding *domainbinding, const char *msgid,
+	      size_t *lengthp)
 {
   struct loaded_domain *domain;
   nls_uint32 nstrings;
@@ -1001,11 +1027,8 @@ _nl_find_msg (domain_file, domainbinding
 /* Look up a plural variant.  */
 static char *
 internal_function
-plural_lookup (domain, n, translation, translation_len)
-     struct loaded_l10nfile *domain;
-     unsigned long int n;
-     const char *translation;
-     size_t translation_len;
+plural_lookup (struct loaded_l10nfile *domain, unsigned long int n,
+	       const char *translation, size_t translation_len)
 {
   struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
   unsigned long int index;
@@ -1038,12 +1061,11 @@ plural_lookup (domain, n, translation, t
   return (char *) p;
 }
 
-
+#ifndef _LIBC
 /* Return string representation of locale CATEGORY.  */
 static const char *
 internal_function
-category_to_name (category)
-     int category;
+category_to_name (int category)
 {
   const char *retval;
 
@@ -1098,34 +1120,52 @@ category_to_name (category)
 
   return retval;
 }
-
-/* Guess value of current locale from value of the environment variables.  */
+#endif
+
+/* Guess value of current locale from value of the environment variables
+   or system-dependent defaults.  */
 static const char *
 internal_function
-guess_category_value (category, categoryname)
-     int category;
-     const char *categoryname;
+guess_category_value (int category, const char *categoryname)
 {
   const char *language;
-  const char *retval;
-
-  /* The highest priority value is the `LANGUAGE' environment
-     variable.  But we don't use the value if the currently selected
-     locale is the C locale.  This is a GNU extension.  */
-  language = getenv ("LANGUAGE");
-  if (language != NULL && language[0] == '\0')
-    language = NULL;
-
-  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
+  const char *locale;
+#ifndef _LIBC
+  const char *language_default;
+  int locale_defaulted;
+#endif
+
+  /* We use the settings in the following order:
+     1. The value of the environment variable 'LANGUAGE'.  This is a GNU
+        extension.  Its value can be a colon-separated list of locale names.
+     2. The value of the environment variable 'LC_ALL', 'LC_xxx', or 'LANG'.
+        More precisely, the first among these that is set to a non-empty value.
+        This is how POSIX specifies it.  The value is a single locale name.
+     3. A system-dependent preference list of languages.  Its value can be a
+        colon-separated list of locale names.
+     4. A system-dependent default locale name.
+     This way:
+       - System-dependent settings can be overridden by environment variables.
+       - If the system provides both a list of languages and a default locale,
+         the former is used.  */
+
+  /* Fetch the locale name, through the POSIX method of looking to `LC_ALL',
      `LC_xxx', and `LANG'.  On some systems this can be done by the
      `setlocale' function itself.  */
 #ifdef _LIBC
-  retval = setlocale (category, NULL);
-#else
-  retval = _nl_locale_name (category, categoryname);
-#endif
-
-  /* Ignore LANGUAGE if the locale is set to "C" because
+  locale = __current_locale_name (category);
+#else
+  locale = _nl_locale_name_posix (category, categoryname);
+  locale_defaulted = 0;
+  if (locale == NULL)
+    {
+      locale = _nl_locale_name_default ();
+      locale_defaulted = 1;
+    }
+#endif
+
+  /* Ignore LANGUAGE and its system-dependent analogon if the locale is set
+     to "C" because
      1. "C" locale usually uses the ASCII encoding, and most international
 	messages use non-ASCII characters. These characters get displayed
 	as question marks (if using glibc's iconv()) or as invalid 8-bit
@@ -1133,8 +1173,28 @@ guess_category_value (category, category
 	characters to ASCII). In any case, the output is ugly.
      2. The precise output of some programs in the "C" locale is specified
 	by POSIX and should not depend on environment variables like
-	"LANGUAGE".  We allow such programs to use gettext().  */
-  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
+	"LANGUAGE" or system-dependent information.  We allow such programs
+        to use gettext().  */
+  if (strcmp (locale, "C") == 0)
+    return locale;
+
+  /* The highest priority value is the value of the 'LANGUAGE' environment
+     variable.  */
+  language = getenv ("LANGUAGE");
+  if (language != NULL && language[0] != '\0')
+    return language;
+#ifndef _LIBC
+  /* The next priority value is the locale name, if not defaulted.  */
+  if (locale_defaulted)
+    {
+      /* The next priority value is the default language preferences list. */
+      language_default = _nl_language_preferences_default ();
+      if (language_default != NULL)
+        return language_default;
+    }
+  /* The least priority value is the locale name, if defaulted.  */
+#endif
+  return locale;
 }
 
 /* @@ begin of epilog @@ */
@@ -1145,9 +1205,7 @@ guess_category_value (category, category
    to be defined.  */
 #if !_LIBC && !HAVE_STPCPY
 static char *
-stpcpy (dest, src)
-     char *dest;
-     const char *src;
+stpcpy (char *dest, const char *src)
 {
   while ((*dest++ = *src++) != '\0')
     /* Do nothing. */ ;
@@ -1157,10 +1215,7 @@ stpcpy (dest, src)
 
 #if !_LIBC && !HAVE_MEMPCPY
 static void *
-mempcpy (dest, src, n)
-     void *dest;
-     const void *src;
-     size_t n;
+mempcpy (void *dest, const void *src, size_t n)
 {
   return (void *) ((char *) memcpy (dest, src, n) + n);
 }
@@ -1170,8 +1225,7 @@ mempcpy (dest, src, n)
 #ifdef _LIBC
 /* If we want to free all resources we have to do some work at
    program's end.  */
-static void __attribute__ ((unused))
-free_mem (void)
+libc_freeres_fn (free_mem)
 {
   void *old;
 
@@ -1179,7 +1233,7 @@ free_mem (void)
     {
       struct binding *oldp = _nl_domain_bindings;
       _nl_domain_bindings = _nl_domain_bindings->next;
-      if (oldp->dirname != _nl_default_dirname)
+      if (oldp->dirname != INTUSE(_nl_default_dirname))
 	/* Yes, this is a pointer comparison.  */
 	free (oldp->dirname);
       free (oldp->codeset);
@@ -1201,6 +1255,4 @@ free_mem (void)
       free (old);
     }
 }
-
-text_set_element (__libc_subfreeres, free_mem);
-#endif
+#endif
diff -r 4216c218ee44 -r e04165992166 intl/dcngettext.c
--- a/intl/dcngettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/dcngettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the dcngettext(3) function.
-   Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -44,18 +44,14 @@
 /* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
    locale.  */
 char *
-DCNGETTEXT (domainname, msgid1, msgid2, n, category)
-     const char *domainname;
-     const char *msgid1;
-     const char *msgid2;
-     unsigned long int n;
-     int category;
+DCNGETTEXT (const char *domainname,
+	    const char *msgid1, const char *msgid2, unsigned long int n,
+	    int category)
 {
   return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
 }
 
 #ifdef _LIBC
 /* Alias for function name in GNU C Library.  */
-INTDEF(__dcngettext)
 weak_alias (__dcngettext, dcngettext);
 #endif
diff -r 4216c218ee44 -r e04165992166 intl/dgettext.c
--- a/intl/dgettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/dgettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the dgettext(3) function.
-   Copyright (C) 1995-1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1997, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -20,9 +20,10 @@
 # include <config.h>
 #endif
 
+#include "gettextP.h"
+
 #include <locale.h>
 
-#include "gettextP.h"
 #ifdef _LIBC
 # include <libintl.h>
 #else
@@ -46,9 +47,7 @@
 /* Look up MSGID in the DOMAINNAME message catalog of the current
    LC_MESSAGES locale.  */
 char *
-DGETTEXT (domainname, msgid)
-     const char *domainname;
-     const char *msgid;
+DGETTEXT (const char *domainname, const char *msgid)
 {
   return DCGETTEXT (domainname, msgid, LC_MESSAGES);
 }
diff -r 4216c218ee44 -r e04165992166 intl/dngettext.c
--- a/intl/dngettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/dngettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the dngettext(3) function.
-   Copyright (C) 1995-1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1997, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -20,9 +20,10 @@
 # include <config.h>
 #endif
 
+#include "gettextP.h"
+
 #include <locale.h>
 
-#include "gettextP.h"
 #ifdef _LIBC
 # include <libintl.h>
 #else
@@ -37,7 +38,7 @@
    prefix.  So we have to make a difference here.  */
 #ifdef _LIBC
 # define DNGETTEXT __dngettext
-# define DCNGETTEXT INTUSE(__dcngettext)
+# define DCNGETTEXT __dcngettext
 #else
 # define DNGETTEXT libintl_dngettext
 # define DCNGETTEXT libintl_dcngettext
@@ -46,11 +47,8 @@
 /* Look up MSGID in the DOMAINNAME message catalog of the current
    LC_MESSAGES locale and skip message according to the plural form.  */
 char *
-DNGETTEXT (domainname, msgid1, msgid2, n)
-     const char *domainname;
-     const char *msgid1;
-     const char *msgid2;
-     unsigned long int n;
+DNGETTEXT (const char *domainname,
+	   const char *msgid1, const char *msgid2, unsigned long int n)
 {
   return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
 }
diff -r 4216c218ee44 -r e04165992166 intl/eval-plural.h
--- a/intl/eval-plural.h	Sat May 28 13:40:15 2005 +0000
+++ b/intl/eval-plural.h	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Plural expression evaluation.
-   Copyright (C) 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -21,16 +21,10 @@
 #endif
 
 /* Evaluate the plural expression and return an index value.  */
-STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
-					      unsigned long int n))
-     internal_function;
-
 STATIC
 unsigned long int
 internal_function
-plural_eval (pexp, n)
-     struct expression *pexp;
-     unsigned long int n;
+plural_eval (struct expression *pexp, unsigned long int n)
 {
   switch (pexp->nargs)
     {
diff -r 4216c218ee44 -r e04165992166 intl/explodename.c
--- a/intl/explodename.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/explodename.c	Sat May 28 13:45:22 2005 +0000
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+/* Copyright (C) 1995-1998, 2000-2001, 2003 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
 
    This program is free software; you can redistribute it and/or modify it
@@ -38,8 +38,7 @@
 /* @@ end of prolog @@ */
 
 char *
-_nl_find_language (name)
-     const char *name;
+_nl_find_language (const char *name)
 {
   while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
 	 && name[0] != '+' && name[0] != ',')
@@ -50,17 +49,11 @@ _nl_find_language (name)
 
 
 int
-_nl_explode_name (name, language, modifier, territory, codeset,
-		  normalized_codeset, special, sponsor, revision)
-     char *name;
-     const char **language;
-     const char **modifier;
-     const char **territory;
-     const char **codeset;
-     const char **normalized_codeset;
-     const char **special;
-     const char **sponsor;
-     const char **revision;
+_nl_explode_name (char *name,
+		  const char **language, const char **modifier,
+		  const char **territory, const char **codeset,
+		  const char **normalized_codeset, const char **special,
+		  const char **sponsor, const char **revision)
 {
   enum { undecided, xpg, cen } syntax;
   char *cp;
diff -r 4216c218ee44 -r e04165992166 intl/finddomain.c
--- a/intl/finddomain.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/finddomain.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Handle list of needed message catalogs
-   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@gnu.org>, 1995.
 
    This program is free software; you can redistribute it and/or modify it
@@ -47,11 +47,8 @@ static struct loaded_l10nfile *_nl_loade
    established bindings.  */
 struct loaded_l10nfile *
 internal_function
-_nl_find_domain (dirname, locale, domainname, domainbinding)
-     const char *dirname;
-     char *locale;
-     const char *domainname;
-     struct binding *domainbinding;
+_nl_find_domain (const char *dirname, char *locale,
+		 const char *domainname, struct binding *domainbinding)
 {
   struct loaded_l10nfile *retval;
   const char *language;
@@ -178,8 +175,7 @@ _nl_find_domain (dirname, locale, domain
 
 
 #ifdef _LIBC
-static void __attribute__ ((unused))
-free_mem (void)
+libc_freeres_fn (free_mem)
 {
   struct loaded_l10nfile *runp = _nl_loaded_domains;
 
@@ -193,6 +189,4 @@ free_mem (void)
       free (here);
     }
 }
-
-text_set_element (__libc_subfreeres, free_mem);
 #endif
diff -r 4216c218ee44 -r e04165992166 intl/gettext.c
--- a/intl/gettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/gettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of gettext(3) function.
-   Copyright (C) 1995, 1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -52,8 +52,7 @@
    LC_MESSAGES locale.  If not found, returns MSGID itself (the default
    text).  */
 char *
-GETTEXT (msgid)
-     const char *msgid;
+GETTEXT (const char *msgid)
 {
   return DCGETTEXT (NULL, msgid, LC_MESSAGES);
 }
diff -r 4216c218ee44 -r e04165992166 intl/gettextP.h
--- a/intl/gettextP.h	Sat May 28 13:40:15 2005 +0000
+++ b/intl/gettextP.h	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Header describing internals of libintl library.
-   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2005 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@cygnus.com>, 1995.
 
    This program is free software; you can redistribute it and/or modify it
@@ -35,14 +35,6 @@
 #include "gmo.h"		/* Get nls_uint32.  */
 
 /* @@ end of prolog @@ */
-
-#ifndef PARAMS
-# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
-#  define PARAMS(args) args
-# else
-#  define PARAMS(args) ()
-# endif
-#endif
 
 #ifndef internal_function
 # define internal_function
@@ -159,82 +151,66 @@ extern int _nl_msg_cat_cntr;
 extern int _nl_msg_cat_cntr;
 
 #ifndef _LIBC
-const char *_nl_locale_name PARAMS ((int category, const char *categoryname));
-#endif
-
-struct loaded_l10nfile *_nl_find_domain PARAMS ((const char *__dirname,
-						 char *__locale,
-						 const char *__domainname,
-					      struct binding *__domainbinding))
-     internal_function;
-void _nl_load_domain PARAMS ((struct loaded_l10nfile *__domain,
-			      struct binding *__domainbinding))
-     internal_function;
-void _nl_unload_domain PARAMS ((struct loaded_domain *__domain))
-     internal_function;
-const char *_nl_init_domain_conv PARAMS ((struct loaded_l10nfile *__domain_file,
-					  struct loaded_domain *__domain,
-					  struct binding *__domainbinding))
-     internal_function;
-void _nl_free_domain_conv PARAMS ((struct loaded_domain *__domain))
-     internal_function;
-
-char *_nl_find_msg PARAMS ((struct loaded_l10nfile *domain_file,
-			    struct binding *domainbinding,
-			    const char *msgid, size_t *lengthp))
-     internal_function;
-
-#ifdef _LIBC
-extern char *__gettext PARAMS ((const char *__msgid));
-extern char *__dgettext PARAMS ((const char *__domainname,
-				 const char *__msgid));
-extern char *__dcgettext PARAMS ((const char *__domainname,
-				  const char *__msgid, int __category));
-extern char *__ngettext PARAMS ((const char *__msgid1, const char *__msgid2,
-				 unsigned long int __n));
-extern char *__dngettext PARAMS ((const char *__domainname,
-				  const char *__msgid1, const char *__msgid2,
-				  unsigned long int n));
-extern char *__dcngettext PARAMS ((const char *__domainname,
-				   const char *__msgid1, const char *__msgid2,
-				   unsigned long int __n, int __category));
-extern char *__dcigettext PARAMS ((const char *__domainname,
-				   const char *__msgid1, const char *__msgid2,
-				   int __plural, unsigned long int __n,
-				   int __category));
-extern char *__textdomain PARAMS ((const char *__domainname));
-extern char *__bindtextdomain PARAMS ((const char *__domainname,
-				       const char *__dirname));
-extern char *__bind_textdomain_codeset PARAMS ((const char *__domainname,
-						const char *__codeset));
-#else
-extern char *libintl_gettext PARAMS ((const char *__msgid));
-extern char *libintl_dgettext PARAMS ((const char *__domainname,
-				       const char *__msgid));
-extern char *libintl_dcgettext PARAMS ((const char *__domainname,
-					const char *__msgid, int __category));
-extern char *libintl_ngettext PARAMS ((const char *__msgid1,
-				       const char *__msgid2,
-				       unsigned long int __n));
-extern char *libintl_dngettext PARAMS ((const char *__domainname,
-					const char *__msgid1,
-					const char *__msgid2,
-					unsigned long int __n));
-extern char *libintl_dcngettext PARAMS ((const char *__domainname,
-					 const char *__msgid1,
-					 const char *__msgid2,
-					 unsigned long int __n,
-					 int __category));
-extern char *libintl_dcigettext PARAMS ((const char *__domainname,
-					 const char *__msgid1,
-					 const char *__msgid2,
-					 int __plural, unsigned long int __n,
-					 int __category));
-extern char *libintl_textdomain PARAMS ((const char *__domainname));
-extern char *libintl_bindtextdomain PARAMS ((const char *__domainname,
-					     const char *__dirname));
-extern char *libintl_bind_textdomain_codeset PARAMS ((const char *__domainname,
-						      const char *__codeset));
+const char *_nl_language_preferences_default (void);
+const char *_nl_locale_name_posix (int category, const char *categoryname);
+const char *_nl_locale_name_default (void);
+const char *_nl_locale_name (int category, const char *categoryname);
+#endif
+
+struct loaded_l10nfile *_nl_find_domain (const char *__dirname, char *__locale,
+					 const char *__domainname,
+					 struct binding *__domainbinding)
+     internal_function;
+void _nl_load_domain (struct loaded_l10nfile *__domain,
+		      struct binding *__domainbinding)
+     internal_function;
+void _nl_unload_domain (struct loaded_domain *__domain)
+     internal_function;
+const char *_nl_init_domain_conv (struct loaded_l10nfile *__domain_file,
+				  struct loaded_domain *__domain,
+				  struct binding *__domainbinding)
+     internal_function;
+void _nl_free_domain_conv (struct loaded_domain *__domain)
+     internal_function;
+
+char *_nl_find_msg (struct loaded_l10nfile *domain_file,
+		    struct binding *domainbinding, const char *msgid,
+		    size_t *lengthp)
+     internal_function;
+
+#ifdef _LIBC
+extern char *__gettext (const char *__msgid);
+extern char *__dgettext (const char *__domainname, const char *__msgid);
+extern char *__dcgettext (const char *__domainname, const char *__msgid,
+			  int __category);
+extern char *__ngettext (const char *__msgid1, const char *__msgid2,
+			 unsigned long int __n);
+extern char *__dngettext (const char *__domainname,
+			  const char *__msgid1, const char *__msgid2,
+			  unsigned long int n);
+extern char *__dcngettext (const char *__domainname,
+			   const char *__msgid1, const char *__msgid2,
+			   unsigned long int __n, int __category);
+extern char *__dcigettext (const char *__domainname,
+			   const char *__msgid1, const char *__msgid2,
+			   int __plural, unsigned long int __n,
+			   int __category);
+extern char *__textdomain (const char *__domainname);
+extern char *__bindtextdomain (const char *__domainname,
+			       const char *__dirname);
+extern char *__bind_textdomain_codeset (const char *__domainname,
+					const char *__codeset);
+#else
+/* Declare the exported libintl_* functions, in a way that allows us to
+   call them under their real name.  */
+# undef _INTL_REDIRECT_INLINE
+# undef _INTL_REDIRECT_MACROS
+# define _INTL_REDIRECT_MACROS
+# include "libgnuintl.h"
+extern char *libintl_dcigettext (const char *__domainname,
+				 const char *__msgid1, const char *__msgid2,
+				 int __plural, unsigned long int __n,
+				 int __category);
 #endif
 
 /* @@ begin of epilog @@ */
diff -r 4216c218ee44 -r e04165992166 intl/gmo.h
--- a/intl/gmo.h	Sat May 28 13:40:15 2005 +0000
+++ b/intl/gmo.h	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Description of GNU message catalog format: general file layout.
-   Copyright (C) 1995, 1997, 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997, 2000-2002, 2004 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -29,6 +29,7 @@
 
 /* Revision number of the currently used .mo (binary) file format.  */
 #define MO_REVISION_NUMBER 0
+#define MO_REVISION_NUMBER_WITH_SYSDEP_I 1
 
 /* The following contortions are an attempt to use the C preprocessor
    to determine an unsigned integral type that is 32 bits wide.  An
@@ -76,7 +77,7 @@ struct mo_file_header
   /* The revision number of the file format.  */
   nls_uint32 revision;
 
-  /* The following are only used in .mo files with major revision 0.  */
+  /* The following are only used in .mo files with major revision 0 or 1.  */
 
   /* The number of strings pairs.  */
   nls_uint32 nstrings;
diff -r 4216c218ee44 -r e04165992166 intl/hash-string.h
--- a/intl/hash-string.h	Sat May 28 13:40:15 2005 +0000
+++ b/intl/hash-string.h	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Description of GNU message catalog format: string hashing function.
-   Copyright (C) 1995, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997-1998, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -18,14 +18,6 @@
 
 /* @@ end of prolog @@ */
 
-#ifndef PARAMS
-# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
-#  define PARAMS(Args) Args
-# else
-#  define PARAMS(Args) ()
-# endif
-#endif
-
 /* We assume to have `unsigned long int' value with at least 32 bits.  */
 #define HASHWORDBITS 32
 
@@ -33,11 +25,8 @@
 /* Defines the so called `hashpjw' function by P.J. Weinberger
    [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,
    1986, 1987 Bell Telephone Laboratories, Inc.]  */
-static unsigned long int hash_string PARAMS ((const char *__str_param));
-
 static inline unsigned long int
-hash_string (str_param)
-     const char *str_param;
+hash_string (const char *str_param)
 {
   unsigned long int hval, g;
   const char *str = str_param;
@@ -47,7 +36,7 @@ hash_string (str_param)
   while (*str != '\0')
     {
       hval <<= 4;
-      hval += (unsigned long int) *str++;
+      hval += (unsigned char) *str++;
       g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
       if (g != 0)
 	{
diff -r 4216c218ee44 -r e04165992166 intl/intl-compat.c
--- a/intl/intl-compat.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/intl-compat.c	Sat May 28 13:45:22 2005 +0000
@@ -1,6 +1,6 @@
 /* intl-compat.c - Stub functions to call gettext functions from GNU gettext
    Library.
-   Copyright (C) 1995, 2000-2002 Software Foundation, Inc.
+   Copyright (C) 1995, 2000-2003 Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -21,8 +21,6 @@
 # include <config.h>
 #endif
 
-#define _INTL_REDIRECT_MACROS
-#include "libgnuintl.h"
 #include "gettextP.h"
 
 /* @@ end of prolog @@ */
@@ -31,7 +29,10 @@
    defined in the included GNU libintl library (with "libintl_" prefix).
    It is compiled into libintl in order to make the AM_GNU_GETTEXT test
    of gettext <= 0.11.2 work with the libintl library >= 0.11.3 which
-   has the redirections primarily in the <libintl.h> include file.  */
+   has the redirections primarily in the <libintl.h> include file.
+   It is also compiled into libgnuintl so that libgnuintl.so can be used
+   as LD_PRELOADable library on glibc systems, to provide the extra
+   features that the functions in the libc don't have (namely, logging).  */
 
 
 #undef gettext
@@ -45,87 +46,86 @@
 #undef bind_textdomain_codeset
 
 
+/* When building a DLL, we must export some functions.  Note that because
+   the functions are only defined for binary backward compatibility, we
+   don't need to use __declspec(dllimport) in any case.  */
+#if defined _MSC_VER && BUILDING_DLL
+# define DLL_EXPORTED __declspec(dllexport)
+#else
+# define DLL_EXPORTED
+#endif
+
+
+DLL_EXPORTED
 char *
-gettext (msgid)
-     const char *msgid;
+gettext (const char *msgid)
 {
   return libintl_gettext (msgid);
 }
 
 
+DLL_EXPORTED
 char *
-dgettext (domainname, msgid)
-     const char *domainname;
-     const char *msgid;
+dgettext (const char *domainname, const char *msgid)
 {
   return libintl_dgettext (domainname, msgid);
 }
 
 
+DLL_EXPORTED
 char *
-dcgettext (domainname, msgid, category)
-     const char *domainname;
-     const char *msgid;
-     int category;
+dcgettext (const char *domainname, const char *msgid, int category)
 {
   return libintl_dcgettext (domainname, msgid, category);
 }
 
 
+DLL_EXPORTED
 char *
-ngettext (msgid1, msgid2, n)
-     const char *msgid1;
-     const char *msgid2;
-     unsigned long int n;
+ngettext (const char *msgid1, const char *msgid2, unsigned long int n)
 {
   return libintl_ngettext (msgid1, msgid2, n);
 }
 
 
+DLL_EXPORTED
 char *
-dngettext (domainname, msgid1, msgid2, n)
-     const char *domainname;
-     const char *msgid1;
-     const char *msgid2;
-     unsigned long int n;
+dngettext (const char *domainname,
+	   const char *msgid1, const char *msgid2, unsigned long int n)
 {
   return libintl_dngettext (domainname, msgid1, msgid2, n);
 }
 
 
+DLL_EXPORTED
 char *
-dcngettext (domainname, msgid1, msgid2, n, category)
-     const char *domainname;
-     const char *msgid1;
-     const char *msgid2;
-     unsigned long int n;
-     int category;
+dcngettext (const char *domainname,
+	    const char *msgid1, const char *msgid2, unsigned long int n,
+	    int category)
 {
   return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
 }
 
 
+DLL_EXPORTED
 char *
-textdomain (domainname)
-     const char *domainname;
+textdomain (const char *domainname)
 {
   return libintl_textdomain (domainname);
 }
 
 
+DLL_EXPORTED
 char *
-bindtextdomain (domainname, dirname)
-     const char *domainname;
-     const char *dirname;
+bindtextdomain (const char *domainname, const char *dirname)
 {
   return libintl_bindtextdomain (domainname, dirname);
 }
 
 
+DLL_EXPORTED
 char *
-bind_textdomain_codeset (domainname, codeset)
-     const char *domainname;
-     const char *codeset;
+bind_textdomain_codeset (const char *domainname, const char *codeset)
 {
   return libintl_bind_textdomain_codeset (domainname, codeset);
 }
diff -r 4216c218ee44 -r e04165992166 intl/l10nflist.c
--- a/intl/l10nflist.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/l10nflist.c	Sat May 28 13:45:22 2005 +0000
@@ -1,4 +1,4 @@
-/* Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+/* Copyright (C) 1995-1999, 2000-2004 Free Software Foundation, Inc.
    Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
 
    This program is free software; you can redistribute it and/or modify it
@@ -58,7 +58,7 @@
 # endif
 #else
 # ifndef HAVE_STPCPY
-static char *stpcpy PARAMS ((char *dest, const char *src));
+static char *stpcpy (char *dest, const char *src);
 # endif
 #endif
 
@@ -67,8 +67,8 @@ static char *stpcpy PARAMS ((char *dest,
    IS_ABSOLUTE_PATH(P)  tests whether P is an absolute path.  If it is not,
                         it may be concatenated to a directory pathname.
  */
-#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, OS/2, DOS */
+#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, Cygwin, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 # define HAS_DEVICE(P) \
     ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
@@ -84,12 +84,8 @@ static char *stpcpy PARAMS ((char *dest,
 
 #if !defined _LIBC && !defined HAVE___ARGZ_COUNT
 /* Returns the number of strings in ARGZ.  */
-static size_t argz_count__ PARAMS ((const char *argz, size_t len));
-
 static size_t
-argz_count__ (argz, len)
-     const char *argz;
-     size_t len;
+argz_count__ (const char *argz, size_t len)
 {
   size_t count = 0;
   while (len > 0)
@@ -112,13 +108,8 @@ argz_count__ (argz, len)
 #if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY
 /* Make '\0' separated arg vector ARGZ printable by converting all the '\0's
    except the last into the character SEP.  */
-static void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));
-
 static void
-argz_stringify__ (argz, len, sep)
-     char *argz;
-     size_t len;
-     int sep;
+argz_stringify__ (char *argz, size_t len, int sep)
 {
   while (len > 0)
     {
@@ -139,14 +130,8 @@ argz_stringify__ (argz, len, sep)
 #endif	/* !_LIBC && !HAVE___ARGZ_STRINGIFY */
 
 #if !defined _LIBC && !defined HAVE___ARGZ_NEXT
-static char *argz_next__ PARAMS ((char *argz, size_t argz_len,
-				  const char *entry));
-
 static char *
-argz_next__ (argz, argz_len, entry)
-     char *argz;
-     size_t argz_len;
-     const char *entry;
+argz_next__ (char *argz, size_t argz_len, const char *entry)
 {
   if (entry)
     {
@@ -167,11 +152,8 @@ argz_next__ (argz, argz_len, entry)
 
 
 /* Return number of bits set in X.  */
-static int pop PARAMS ((int x));
-
 static inline int
-pop (x)
-     int x;
+pop (int x)
 {
   /* We assume that no more than 16 bits are used.  */
   x = ((x & ~0x5555) >> 1) + (x & 0x5555);
@@ -184,23 +166,13 @@ pop (x)
 
 
 struct loaded_l10nfile *
-_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
-		    territory, codeset, normalized_codeset, modifier, special,
-		    sponsor, revision, filename, do_allocate)
-     struct loaded_l10nfile **l10nfile_list;
-     const char *dirlist;
-     size_t dirlist_len;
-     int mask;
-     const char *language;
-     const char *territory;
-     const char *codeset;
-     const char *normalized_codeset;
-     const char *modifier;
-     const char *special;
-     const char *sponsor;
-     const char *revision;
-     const char *filename;
-     int do_allocate;
+_nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,
+		    const char *dirlist, size_t dirlist_len,
+		    int mask, const char *language, const char *territory,
+		    const char *codeset, const char *normalized_codeset,
+		    const char *modifier, const char *special,
+		    const char *sponsor, const char *revision,
+		    const char *filename, int do_allocate)
 {
   char *abs_filename;
   struct loaded_l10nfile **lastp;
@@ -393,9 +365,7 @@ _nl_make_l10nflist (l10nfile_list, dirli
    names.  The return value is dynamically allocated and has to be
    freed by the caller.  */
 const char *
-_nl_normalize_codeset (codeset, name_len)
-     const char *codeset;
-     size_t name_len;
+_nl_normalize_codeset (const char *codeset, size_t name_len)
 {
   int len = 0;
   int only_digit = 1;
@@ -442,9 +412,7 @@ _nl_normalize_codeset (codeset, name_len
    to be defined.  */
 #if !_LIBC && !HAVE_STPCPY
 static char *
-stpcpy (dest, src)
-     char *dest;
-     const char *src;
+stpcpy (char *dest, const char *src)
 {
   while ((*dest++ = *src++) != '\0')
     /* Do nothing. */ ;
diff -r 4216c218ee44 -r e04165992166 intl/langprefs.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/langprefs.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,130 @@
+/* Determine the user's language preferences.
+   Copyright (C) 2004-2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+
+#if HAVE_CFPREFERENCESCOPYAPPVALUE
+# include <string.h>
+# include <CFPreferences.h>
+# include <CFPropertyList.h>
+# include <CFArray.h>
+# include <CFString.h>
+extern void _nl_locale_name_canonicalize (char *name);
+#endif
+
+/* Determine the user's language preferences, as a colon separated list of
+   locale names in XPG syntax
+     language[_territory[.codeset]][@modifier]
+   The result must not be freed; it is statically allocated.
+   The LANGUAGE environment variable does not need to be considered; it is
+   already taken into account by the caller.  */
+
+const char *
+_nl_language_preferences_default (void)
+{
+#if HAVE_CFPREFERENCESCOPYAPPVALUE /* MacOS X 10.2 or newer */
+  {
+    /* Cache the preferences list, since CoreFoundation calls are expensive.  */
+    static const char *cached_languages;
+    static int cache_initialized;
+
+    if (!cache_initialized)
+      {
+	CFTypeRef preferences =
+	  CFPreferencesCopyAppValue (CFSTR ("AppleLanguages"),
+				     kCFPreferencesCurrentApplication);
+	if (preferences != NULL
+	    && CFGetTypeID (preferences) == CFArrayGetTypeID ())
+	  {
+	    CFArrayRef prefArray = (CFArrayRef)preferences;
+	    int n = CFArrayGetCount (prefArray);
+	    char buf[256];
+	    size_t size = 0;
+	    int i;
+
+	    for (i = 0; i < n; i++)
+	      {
+		CFTypeRef element = CFArrayGetValueAtIndex (prefArray, i);
+		if (element != NULL
+		    && CFGetTypeID (element) == CFStringGetTypeID ()
+		    && CFStringGetCString ((CFStringRef)element,
+					   buf, sizeof (buf),
+					   kCFStringEncodingASCII))
+		  {
+		    _nl_locale_name_canonicalize (buf);
+		    size += strlen (buf) + 1;
+		    /* Most GNU programs use msgids in English and don't ship
+		       an en.mo message catalog.  Therefore when we see "en"
+		       in the preferences list, arrange for gettext() to
+		       return the msgid, and ignore all further elements of
+		       the preferences list.  */
+		    if (strcmp (buf, "en") == 0)
+		      break;
+		  }
+		else
+		  break;
+	      }
+	    if (size > 0)
+	      {
+		char *languages = (char *) malloc (size);
+
+		if (languages != NULL)
+		  {
+		    char *p = languages;
+
+		    for (i = 0; i < n; i++)
+		      {
+			CFTypeRef element =
+			  CFArrayGetValueAtIndex (prefArray, i);
+			if (element != NULL
+		            && CFGetTypeID (element) == CFStringGetTypeID ()
+			    && CFStringGetCString ((CFStringRef)element,
+						   buf, sizeof (buf),
+						   kCFStringEncodingASCII))
+			  {
+			    _nl_locale_name_canonicalize (buf);
+			    strcpy (p, buf);
+			    p += strlen (buf);
+			    *p++ = ':';
+			    if (strcmp (buf, "en") == 0)
+			      break;
+			  }
+			else
+			  break;
+		      }
+		    *--p = '\0';
+
+		    cached_languages = languages;
+		  }
+	      }
+	  }
+	cache_initialized = 1;
+      }
+    if (cached_languages != NULL)
+      return cached_languages;
+  }
+#endif
+
+  return NULL;
+}
diff -r 4216c218ee44 -r e04165992166 intl/libgnuintl.h.in
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/libgnuintl.h.in	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,383 @@
+/* Message catalogs for internationalization.
+   Copyright (C) 1995-1997, 2000-2004 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _LIBINTL_H
+#define _LIBINTL_H	1
+
+#include <locale.h>
+
+/* The LC_MESSAGES locale category is the category used by the functions
+   gettext() and dgettext().  It is specified in POSIX, but not in ANSI C.
+   On systems that don't define it, use an arbitrary value instead.
+   On Solaris, <locale.h> defines __LOCALE_H (or _LOCALE_H in Solaris 2.5)
+   then includes <libintl.h> (i.e. this file!) and then only defines
+   LC_MESSAGES.  To avoid a redefinition warning, don't define LC_MESSAGES
+   in this case.  */
+#if !defined LC_MESSAGES && !(defined __LOCALE_H || (defined _LOCALE_H && defined __sun))
+# define LC_MESSAGES 1729
+#endif
+
+/* We define an additional symbol to signal that we use the GNU
+   implementation of gettext.  */
+#define __USE_GNU_GETTEXT 1
+
+/* Provide information about the supported file formats.  Returns the
+   maximum minor revision number supported for a given major revision.  */
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) \
+  ((major) == 0 || (major) == 1 ? 1 : -1)
+
+/* Resolve a platform specific conflict on DJGPP.  GNU gettext takes
+   precedence over _conio_gettext.  */
+#ifdef __DJGPP__
+# undef gettext
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* We redirect the functions to those prefixed with "libintl_".  This is
+   necessary, because some systems define gettext/textdomain/... in the C
+   library (namely, Solaris 2.4 and newer, and GNU libc 2.0 and newer).
+   If we used the unprefixed names, there would be cases where the
+   definition in the C library would override the one in the libintl.so
+   shared library.  Recall that on ELF systems, the symbols are looked
+   up in the following order:
+     1. in the executable,
+     2. in the shared libraries specified on the link command line, in order,
+     3. in the dependencies of the shared libraries specified on the link
+        command line,
+     4. in the dlopen()ed shared libraries, in the order in which they were
+        dlopen()ed.
+   The definition in the C library would override the one in libintl.so if
+   either
+     * -lc is given on the link command line and -lintl isn't, or
+     * -lc is given on the link command line before -lintl, or
+     * libintl.so is a dependency of a dlopen()ed shared library but not
+       linked to the executable at link time.
+   Since Solaris gettext() behaves differently than GNU gettext(), this
+   would be unacceptable.
+
+   The redirection happens by default through macros in C, so that &gettext
+   is independent of the compilation unit, but through inline functions in
+   C++, in order not to interfere with the name mangling of class fields or
+   class methods called 'gettext'.  */
+
+/* The user can define _INTL_REDIRECT_INLINE or _INTL_REDIRECT_MACROS.
+   If he doesn't, we choose the method.  A third possible method is
+   _INTL_REDIRECT_ASM, supported only by GCC.  */
+#if !(defined _INTL_REDIRECT_INLINE || defined _INTL_REDIRECT_MACROS)
+# if __GNUC__ >= 2 && !defined __APPLE_CC__ && !defined __MINGW32__ && !(__GNUC__ == 2 && defined _AIX) && (defined __STDC__ || defined __cplusplus)
+#  define _INTL_REDIRECT_ASM
+# else
+#  ifdef __cplusplus
+#   define _INTL_REDIRECT_INLINE
+#  else
+#   define _INTL_REDIRECT_MACROS
+#  endif
+# endif
+#endif
+/* Auxiliary macros.  */
+#ifdef _INTL_REDIRECT_ASM
+# define _INTL_ASM(cname) __asm__ (_INTL_ASMNAME (__USER_LABEL_PREFIX__, #cname))
+# define _INTL_ASMNAME(prefix,cnamestring) _INTL_STRINGIFY (prefix) cnamestring
+# define _INTL_STRINGIFY(prefix) #prefix
+#else
+# define _INTL_ASM(cname)
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_gettext (const char *__msgid);
+static inline char *gettext (const char *__msgid)
+{
+  return libintl_gettext (__msgid);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define gettext libintl_gettext
+#endif
+extern char *gettext (const char *__msgid)
+       _INTL_ASM (libintl_gettext);
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   LC_MESSAGES locale.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dgettext (const char *__domainname, const char *__msgid);
+static inline char *dgettext (const char *__domainname, const char *__msgid)
+{
+  return libintl_dgettext (__domainname, __msgid);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dgettext libintl_dgettext
+#endif
+extern char *dgettext (const char *__domainname, const char *__msgid)
+       _INTL_ASM (libintl_dgettext);
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dcgettext (const char *__domainname, const char *__msgid,
+				int __category);
+static inline char *dcgettext (const char *__domainname, const char *__msgid,
+			       int __category)
+{
+  return libintl_dcgettext (__domainname, __msgid, __category);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dcgettext libintl_dcgettext
+#endif
+extern char *dcgettext (const char *__domainname, const char *__msgid,
+			int __category)
+       _INTL_ASM (libintl_dcgettext);
+#endif
+
+
+/* Similar to `gettext' but select the plural form corresponding to the
+   number N.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_ngettext (const char *__msgid1, const char *__msgid2,
+			       unsigned long int __n);
+static inline char *ngettext (const char *__msgid1, const char *__msgid2,
+			      unsigned long int __n)
+{
+  return libintl_ngettext (__msgid1, __msgid2, __n);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define ngettext libintl_ngettext
+#endif
+extern char *ngettext (const char *__msgid1, const char *__msgid2,
+		       unsigned long int __n)
+       _INTL_ASM (libintl_ngettext);
+#endif
+
+/* Similar to `dgettext' but select the plural form corresponding to the
+   number N.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dngettext (const char *__domainname, const char *__msgid1,
+				const char *__msgid2, unsigned long int __n);
+static inline char *dngettext (const char *__domainname, const char *__msgid1,
+			       const char *__msgid2, unsigned long int __n)
+{
+  return libintl_dngettext (__domainname, __msgid1, __msgid2, __n);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dngettext libintl_dngettext
+#endif
+extern char *dngettext (const char *__domainname,
+			const char *__msgid1, const char *__msgid2,
+			unsigned long int __n)
+       _INTL_ASM (libintl_dngettext);
+#endif
+
+/* Similar to `dcgettext' but select the plural form corresponding to the
+   number N.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dcngettext (const char *__domainname,
+				 const char *__msgid1, const char *__msgid2,
+				 unsigned long int __n, int __category);
+static inline char *dcngettext (const char *__domainname,
+				const char *__msgid1, const char *__msgid2,
+				unsigned long int __n, int __category)
+{
+  return libintl_dcngettext (__domainname, __msgid1, __msgid2, __n, __category);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dcngettext libintl_dcngettext
+#endif
+extern char *dcngettext (const char *__domainname,
+			 const char *__msgid1, const char *__msgid2,
+			 unsigned long int __n, int __category)
+       _INTL_ASM (libintl_dcngettext);
+#endif
+
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_textdomain (const char *__domainname);
+static inline char *textdomain (const char *__domainname)
+{
+  return libintl_textdomain (__domainname);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define textdomain libintl_textdomain
+#endif
+extern char *textdomain (const char *__domainname)
+       _INTL_ASM (libintl_textdomain);
+#endif
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_bindtextdomain (const char *__domainname,
+				     const char *__dirname);
+static inline char *bindtextdomain (const char *__domainname,
+				    const char *__dirname)
+{
+  return libintl_bindtextdomain (__domainname, __dirname);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define bindtextdomain libintl_bindtextdomain
+#endif
+extern char *bindtextdomain (const char *__domainname, const char *__dirname)
+       _INTL_ASM (libintl_bindtextdomain);
+#endif
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_bind_textdomain_codeset (const char *__domainname,
+					      const char *__codeset);
+static inline char *bind_textdomain_codeset (const char *__domainname,
+					     const char *__codeset)
+{
+  return libintl_bind_textdomain_codeset (__domainname, __codeset);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define bind_textdomain_codeset libintl_bind_textdomain_codeset
+#endif
+extern char *bind_textdomain_codeset (const char *__domainname,
+				      const char *__codeset)
+       _INTL_ASM (libintl_bind_textdomain_codeset);
+#endif
+
+
+/* Support for format strings with positions in *printf(), following the
+   POSIX/XSI specification.
+   Note: These replacements for the *printf() functions are visible only
+   in source files that #include <libintl.h> or #include "gettext.h".
+   Packages that use *printf() in source files that don't refer to _()
+   or gettext() but for which the format string could be the return value
+   of _() or gettext() need to add this #include.  Oh well.  */
+
+#if !@HAVE_POSIX_PRINTF@
+
+#include <stdio.h>
+#include <stddef.h>
+
+/* Get va_list.  */
+#if __STDC__ || defined __cplusplus || defined _MSC_VER
+# include <stdarg.h>
+#else
+# include <varargs.h>
+#endif
+
+#undef fprintf
+#define fprintf libintl_fprintf
+extern int fprintf (FILE *, const char *, ...);
+#undef vfprintf
+#define vfprintf libintl_vfprintf
+extern int vfprintf (FILE *, const char *, va_list);
+
+#undef printf
+#define printf libintl_printf
+extern int printf (const char *, ...);
+#undef vprintf
+#define vprintf libintl_vprintf
+extern int vprintf (const char *, va_list);
+
+#undef sprintf
+#define sprintf libintl_sprintf
+extern int sprintf (char *, const char *, ...);
+#undef vsprintf
+#define vsprintf libintl_vsprintf
+extern int vsprintf (char *, const char *, va_list);
+
+#if @HAVE_SNPRINTF@
+
+#undef snprintf
+#define snprintf libintl_snprintf
+extern int snprintf (char *, size_t, const char *, ...);
+#undef vsnprintf
+#define vsnprintf libintl_vsnprintf
+extern int vsnprintf (char *, size_t, const char *, va_list);
+
+#endif
+
+#if @HAVE_ASPRINTF@
+
+#undef asprintf
+#define asprintf libintl_asprintf
+extern int asprintf (char **, const char *, ...);
+#undef vasprintf
+#define vasprintf libintl_vasprintf
+extern int vasprintf (char **, const char *, va_list);
+
+#endif
+
+#if @HAVE_WPRINTF@
+
+#undef fwprintf
+#define fwprintf libintl_fwprintf
+extern int fwprintf (FILE *, const wchar_t *, ...);
+#undef vfwprintf
+#define vfwprintf libintl_vfwprintf
+extern int vfwprintf (FILE *, const wchar_t *, va_list);
+
+#undef wprintf
+#define wprintf libintl_wprintf
+extern int wprintf (const wchar_t *, ...);
+#undef vwprintf
+#define vwprintf libintl_vwprintf
+extern int vwprintf (const wchar_t *, va_list);
+
+#undef swprintf
+#define swprintf libintl_swprintf
+extern int swprintf (wchar_t *, size_t, const wchar_t *, ...);
+#undef vswprintf
+#define vswprintf libintl_vswprintf
+extern int vswprintf (wchar_t *, size_t, const wchar_t *, va_list);
+
+#endif
+
+#endif
+
+
+/* Support for relocatable packages.  */
+
+/* Sets the original and the current installation prefix of the package.
+   Relocation simply replaces a pathname starting with the original prefix
+   by the corresponding pathname with the current prefix instead.  Both
+   prefixes should be directory names without trailing slash (i.e. use ""
+   instead of "/").  */
+#define libintl_set_relocation_prefix libintl_set_relocation_prefix
+extern void
+       libintl_set_relocation_prefix (const char *orig_prefix,
+				      const char *curr_prefix);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* libintl.h */
diff -r 4216c218ee44 -r e04165992166 intl/loadinfo.h
--- a/intl/loadinfo.h	Sat May 28 13:40:15 2005 +0000
+++ b/intl/loadinfo.h	Sat May 28 13:45:22 2005 +0000
@@ -1,4 +1,4 @@
-/* Copyright (C) 1996-1999, 2000-2002 Free Software Foundation, Inc.
+/* Copyright (C) 1996-1999, 2000-2003 Free Software Foundation, Inc.
    This file is part of the GNU C Library.
    Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
 
@@ -32,14 +32,6 @@
    in gettextP.h.
  */
 
-#ifndef PARAMS
-# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
-#  define PARAMS(args) args
-# else
-#  define PARAMS(args) ()
-# endif
-#endif
-
 #ifndef internal_function
 # define internal_function
 #endif
@@ -89,8 +81,8 @@ struct loaded_l10nfile
    names.  Normalization allows the user to use any of the common
    names.  The return value is dynamically allocated and has to be
    freed by the caller.  */
-extern const char *_nl_normalize_codeset PARAMS ((const char *codeset,
-						  size_t name_len));
+extern const char *_nl_normalize_codeset (const char *codeset,
+					  size_t name_len);
 
 /* Lookup a locale dependent file.
    *L10NFILE_LIST denotes a pool of lookup results of locale dependent
@@ -107,19 +99,18 @@ extern const char *_nl_normalize_codeset
    furthermore its ->successor[] field contains a list of other lookup
    results from which this lookup result inherits.  */
 extern struct loaded_l10nfile *
-_nl_make_l10nflist PARAMS ((struct loaded_l10nfile **l10nfile_list,
-			    const char *dirlist, size_t dirlist_len, int mask,
-			    const char *language, const char *territory,
-			    const char *codeset,
-			    const char *normalized_codeset,
-			    const char *modifier, const char *special,
-			    const char *sponsor, const char *revision,
-			    const char *filename, int do_allocate));
+_nl_make_l10nflist (struct loaded_l10nfile **l10nfile_list,
+		    const char *dirlist, size_t dirlist_len, int mask,
+		    const char *language, const char *territory,
+		    const char *codeset, const char *normalized_codeset,
+		    const char *modifier, const char *special,
+		    const char *sponsor, const char *revision,
+		    const char *filename, int do_allocate);
 
 /* Lookup the real locale name for a locale alias NAME, or NULL if
    NAME is not a locale alias (but possibly a real locale name).
    The return value is statically allocated and must not be freed.  */
-extern const char *_nl_expand_alias PARAMS ((const char *name));
+extern const char *_nl_expand_alias (const char *name);
 
 /* Split a locale name NAME into its pieces: language, modifier,
    territory, codeset, special, sponsor, revision.
@@ -139,18 +130,16 @@ extern const char *_nl_expand_alias PARA
      CEN_SPONSOR                 for *SPONSOR,
      CEN_REVISION                for *REVISION.
  */
-extern int _nl_explode_name PARAMS ((char *name, const char **language,
-				     const char **modifier,
-				     const char **territory,
-				     const char **codeset,
-				     const char **normalized_codeset,
-				     const char **special,
-				     const char **sponsor,
-				     const char **revision));
+extern int _nl_explode_name (char *name, const char **language,
+			     const char **modifier, const char **territory,
+			     const char **codeset,
+			     const char **normalized_codeset,
+			     const char **special, const char **sponsor,
+			     const char **revision);
 
 /* Split a locale name NAME into a leading language part and all the
    rest.  Return a pointer to the first character after the language,
    i.e. to the first byte of the rest.  */
-extern char *_nl_find_language PARAMS ((const char *name));
+extern char *_nl_find_language (const char *name);
 
 #endif	/* loadinfo.h */
diff -r 4216c218ee44 -r e04165992166 intl/loadmsgcat.c
--- a/intl/loadmsgcat.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/loadmsgcat.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Load needed message catalogs.
-   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2004 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -34,17 +34,23 @@
 #include <sys/stat.h>
 
 #ifdef __GNUC__
+# undef  alloca
 # define alloca __builtin_alloca
 # define HAVE_ALLOCA 1
 #else
-# if defined HAVE_ALLOCA_H || defined _LIBC
-#  include <alloca.h>
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
 # else
-#  ifdef _AIX
+#  if defined HAVE_ALLOCA_H || defined _LIBC
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
  #pragma alloca
-#  else
-#   ifndef alloca
+#   else
+#    ifndef alloca
 char *alloca ();
+#    endif
 #   endif
 #  endif
 # endif
@@ -485,11 +491,6 @@ char *alloca ();
 #endif
 
 
-/* Prototypes for local functions.  Needed to ensure compiler checking of
-   function argument counts despite of K&R C function definition syntax.  */
-static const char *get_sysdep_segment_value PARAMS ((const char *name));
-
-
 /* We need a sign, whether a new catalog was loaded, which can be associated
    with all translations.  This is important if the translations are
    cached by one of GCC's features.  */
@@ -498,8 +499,7 @@ int _nl_msg_cat_cntr;
 
 /* Expand a system dependent string segment.  Return NULL if unsupported.  */
 static const char *
-get_sysdep_segment_value (name)
-     const char *name;
+get_sysdep_segment_value (const char *name)
 {
   /* Test for an ISO C 99 section 7.8.1 format string directive.
      Syntax:
@@ -748,6 +748,18 @@ get_sysdep_segment_value (name)
 	    }
 	}
     }
+  /* Test for a glibc specific printf() format directive flag.  */
+  if (name[0] == 'I' && name[1] == '\0')
+    {
+#if defined _LIBC || __GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2)
+      /* The 'I' flag, in numeric format directives, replaces ASCII digits
+	 with the 'outdigits' defined in the LC_CTYPE locale facet.  This is
+	 used for Farsi (Persian) and maybe Arabic.  */
+      return "I";
+#else
+      return "";
+#endif
+    }
   /* Other system dependent strings are not valid.  */
   return NULL;
 }
@@ -756,10 +768,9 @@ get_sysdep_segment_value (name)
    Return the header entry.  */
 const char *
 internal_function
-_nl_init_domain_conv (domain_file, domain, domainbinding)
-     struct loaded_l10nfile *domain_file;
-     struct loaded_domain *domain;
-     struct binding *domainbinding;
+_nl_init_domain_conv (struct loaded_l10nfile *domain_file,
+		      struct loaded_domain *domain,
+		      struct binding *domainbinding)
 {
   /* Find out about the character set the file is encoded with.
      This can be found (in textual form) in the entry "".  If this
@@ -820,10 +831,10 @@ _nl_init_domain_conv (domain_file, domai
 	      if (outcharset == NULL || outcharset[0] == '\0')
 		{
 # ifdef _LIBC
-		  outcharset = (*_nl_current[LC_CTYPE])->values[_NL_ITEM_INDEX (CODESET)].string;
+		  outcharset = _NL_CURRENT (LC_CTYPE, CODESET);
 # else
 #  if HAVE_ICONV
-		  extern const char *locale_charset PARAMS ((void));
+		  extern const char *locale_charset (void);
 		  outcharset = locale_charset ();
 #  endif
 # endif
@@ -875,8 +886,7 @@ _nl_init_domain_conv (domain_file, domai
 /* Frees the codeset dependent parts of an opened message catalog.  */
 void
 internal_function
-_nl_free_domain_conv (domain)
-     struct loaded_domain *domain;
+_nl_free_domain_conv (struct loaded_domain *domain)
 {
   if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
     free (domain->conv_tab);
@@ -896,9 +906,8 @@ _nl_free_domain_conv (domain)
    message catalog do nothing.  */
 void
 internal_function
-_nl_load_domain (domain_file, domainbinding)
-     struct loaded_l10nfile *domain_file;
-     struct binding *domainbinding;
+_nl_load_domain (struct loaded_l10nfile *domain_file,
+		 struct binding *domainbinding)
 {
   int fd;
   size_t size;
@@ -1022,10 +1031,11 @@ _nl_load_domain (domain_file, domainbind
 
   /* Fill in the information about the available tables.  */
   revision = W (domain->must_swap, data->revision);
-  /* We support only the major revision 0.  */
+  /* We support only the major revisions 0 and 1.  */
   switch (revision >> 16)
     {
     case 0:
+    case 1:
       domain->nstrings = W (domain->must_swap, data->nstrings);
       domain->orig_tab = (const struct string_desc *)
 	((char *) data + W (domain->must_swap, data->orig_tab_offset));
@@ -1065,12 +1075,13 @@ _nl_load_domain (domain_file, domainbind
 		const char **sysdep_segment_values;
 		const nls_uint32 *orig_sysdep_tab;
 		const nls_uint32 *trans_sysdep_tab;
+		nls_uint32 n_inmem_sysdep_strings;
 		size_t memneed;
 		char *mem;
 		struct sysdep_string_desc *inmem_orig_sysdep_tab;
 		struct sysdep_string_desc *inmem_trans_sysdep_tab;
 		nls_uint32 *inmem_hash_tab;
-		unsigned int i;
+		unsigned int i, j;
 
 		/* Get the values of the system dependent segments.  */
 		n_sysdep_segments =
@@ -1105,153 +1116,247 @@ _nl_load_domain (domain_file, domainbind
 		   + W (domain->must_swap, data->trans_sysdep_tab_offset));
 
 		/* Compute the amount of additional memory needed for the
-		   system dependent strings and the augmented hash table.  */
-		memneed = 2 * n_sysdep_strings
-			  * sizeof (struct sysdep_string_desc)
-			  + domain->hash_size * sizeof (nls_uint32);
-		for (i = 0; i < 2 * n_sysdep_strings; i++)
+		   system dependent strings and the augmented hash table.
+		   At the same time, also drop string pairs which refer to
+		   an undefined system dependent segment.  */
+		n_inmem_sysdep_strings = 0;
+		memneed = domain->hash_size * sizeof (nls_uint32);
+		for (i = 0; i < n_sysdep_strings; i++)
 		  {
-		    const struct sysdep_string *sysdep_string =
-		      (const struct sysdep_string *)
-		      ((char *) data
-		       + W (domain->must_swap,
-			    i < n_sysdep_strings
-			    ? orig_sysdep_tab[i]
-			    : trans_sysdep_tab[i - n_sysdep_strings]));
-		    size_t need = 0;
-		    const struct segment_pair *p = sysdep_string->segments;
-
-		    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
-		      for (p = sysdep_string->segments;; p++)
-			{
-			  nls_uint32 sysdepref;
-
-			  need += W (domain->must_swap, p->segsize);
-
-			  sysdepref = W (domain->must_swap, p->sysdepref);
-			  if (sysdepref == SEGMENTS_END)
-			    break;
-
-			  if (sysdepref >= n_sysdep_segments)
+		    int valid = 1;
+		    size_t needs[2];
+
+		    for (j = 0; j < 2; j++)
+		      {
+			const struct sysdep_string *sysdep_string =
+			  (const struct sysdep_string *)
+			  ((char *) data
+			   + W (domain->must_swap,
+				j == 0
+				? orig_sysdep_tab[i]
+				: trans_sysdep_tab[i]));
+			size_t need = 0;
+			const struct segment_pair *p = sysdep_string->segments;
+
+			if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
+			  for (p = sysdep_string->segments;; p++)
 			    {
-			      /* Invalid.  */
-			      freea (sysdep_segment_values);
-			      goto invalid;
+			      nls_uint32 sysdepref;
+
+			      need += W (domain->must_swap, p->segsize);
+
+			      sysdepref = W (domain->must_swap, p->sysdepref);
+			      if (sysdepref == SEGMENTS_END)
+				break;
+
+			      if (sysdepref >= n_sysdep_segments)
+				{
+				  /* Invalid.  */
+				  freea (sysdep_segment_values);
+				  goto invalid;
+				}
+
+			      if (sysdep_segment_values[sysdepref] == NULL)
+				{
+				  /* This particular string pair is invalid.  */
+				  valid = 0;
+				  break;
+				}
+
+			      need += strlen (sysdep_segment_values[sysdepref]);
 			    }
 
-			  need += strlen (sysdep_segment_values[sysdepref]);
-			}
-
-		    memneed += need;
-		  }
-
-		/* Allocate additional memory.  */
-		mem = (char *) malloc (memneed);
-		if (mem == NULL)
-		  goto invalid;
-
-		domain->malloced = mem;
-		inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
-		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
-		inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
-		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
-		inmem_hash_tab = (nls_uint32 *) mem;
-		mem += domain->hash_size * sizeof (nls_uint32);
-
-		/* Compute the system dependent strings.  */
-		for (i = 0; i < 2 * n_sysdep_strings; i++)
-		  {
-		    const struct sysdep_string *sysdep_string =
-		      (const struct sysdep_string *)
-		      ((char *) data
-		       + W (domain->must_swap,
-			    i < n_sysdep_strings
-			    ? orig_sysdep_tab[i]
-			    : trans_sysdep_tab[i - n_sysdep_strings]));
-		    const char *static_segments =
-		      (char *) data
-		      + W (domain->must_swap, sysdep_string->offset);
-		    const struct segment_pair *p = sysdep_string->segments;
-
-		    /* Concatenate the segments, and fill
-		       inmem_orig_sysdep_tab[i] (for i < n_sysdep_strings) and
-		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for
-		       i >= n_sysdep_strings).  */
-
-		    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)
+			needs[j] = need;
+			if (!valid)
+			  break;
+		      }
+
+		    if (valid)
 		      {
-			/* Only one static segment.  */
-			inmem_orig_sysdep_tab[i].length =
-			  W (domain->must_swap, p->segsize);
-			inmem_orig_sysdep_tab[i].pointer = static_segments;
-		      }
-		    else
-		      {
-			inmem_orig_sysdep_tab[i].pointer = mem;
-
-			for (p = sysdep_string->segments;; p++)
-			  {
-			    nls_uint32 segsize =
-			      W (domain->must_swap, p->segsize);
-			    nls_uint32 sysdepref =
-			      W (domain->must_swap, p->sysdepref);
-			    size_t n;
-
-			    if (segsize > 0)
-			      {
-				memcpy (mem, static_segments, segsize);
-				mem += segsize;
-				static_segments += segsize;
-			      }
-
-			    if (sysdepref == SEGMENTS_END)
-			      break;
-
-			    n = strlen (sysdep_segment_values[sysdepref]);
-			    memcpy (mem, sysdep_segment_values[sysdepref], n);
-			    mem += n;
-			  }
-
-			inmem_orig_sysdep_tab[i].length =
-			  mem - inmem_orig_sysdep_tab[i].pointer;
+			n_inmem_sysdep_strings++;
+			memneed += needs[0] + needs[1];
 		      }
 		  }
-
-		/* Compute the augmented hash table.  */
-		for (i = 0; i < domain->hash_size; i++)
-		  inmem_hash_tab[i] =
-		    W (domain->must_swap_hash_tab, domain->hash_tab[i]);
-		for (i = 0; i < n_sysdep_strings; i++)
+		memneed += 2 * n_inmem_sysdep_strings
+			   * sizeof (struct sysdep_string_desc);
+
+		if (n_inmem_sysdep_strings > 0)
 		  {
-		    const char *msgid = inmem_orig_sysdep_tab[i].pointer;
-		    nls_uint32 hash_val = hash_string (msgid);
-		    nls_uint32 idx = hash_val % domain->hash_size;
-		    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
-
-		    for (;;)
+		    unsigned int k;
+
+		    /* Allocate additional memory.  */
+		    mem = (char *) malloc (memneed);
+		    if (mem == NULL)
+		      goto invalid;
+
+		    domain->malloced = mem;
+		    inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
+		    mem += n_inmem_sysdep_strings
+			   * sizeof (struct sysdep_string_desc);
+		    inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
+		    mem += n_inmem_sysdep_strings
+			   * sizeof (struct sysdep_string_desc);
+		    inmem_hash_tab = (nls_uint32 *) mem;
+		    mem += domain->hash_size * sizeof (nls_uint32);
+
+		    /* Compute the system dependent strings.  */
+		    k = 0;
+		    for (i = 0; i < n_sysdep_strings; i++)
 		      {
-			if (inmem_hash_tab[idx] == 0)
+			int valid = 1;
+
+			for (j = 0; j < 2; j++)
 			  {
-			    /* Hash table entry is empty.  Use it.  */
-			    inmem_hash_tab[idx] = 1 + domain->nstrings + i;
-			    break;
+			    const struct sysdep_string *sysdep_string =
+			      (const struct sysdep_string *)
+			      ((char *) data
+			       + W (domain->must_swap,
+				    j == 0
+				    ? orig_sysdep_tab[i]
+				    : trans_sysdep_tab[i]));
+			    const struct segment_pair *p =
+			      sysdep_string->segments;
+
+			    if (W (domain->must_swap, p->sysdepref)
+				!= SEGMENTS_END)
+			      for (p = sysdep_string->segments;; p++)
+				{
+				  nls_uint32 sysdepref;
+
+				  sysdepref =
+				    W (domain->must_swap, p->sysdepref);
+				  if (sysdepref == SEGMENTS_END)
+				    break;
+
+				  if (sysdep_segment_values[sysdepref] == NULL)
+				    {
+				      /* This particular string pair is
+					 invalid.  */
+				      valid = 0;
+				      break;
+				    }
+				}
+
+			    if (!valid)
+			      break;
 			  }
 
-			if (idx >= domain->hash_size - incr)
-			  idx -= domain->hash_size - incr;
-			else
-			  idx += incr;
+			if (valid)
+			  {
+			    for (j = 0; j < 2; j++)
+			      {
+				const struct sysdep_string *sysdep_string =
+				  (const struct sysdep_string *)
+				  ((char *) data
+				   + W (domain->must_swap,
+					j == 0
+					? orig_sysdep_tab[i]
+					: trans_sysdep_tab[i]));
+				const char *static_segments =
+				  (char *) data
+				  + W (domain->must_swap, sysdep_string->offset);
+				const struct segment_pair *p =
+				  sysdep_string->segments;
+
+				/* Concatenate the segments, and fill
+				   inmem_orig_sysdep_tab[k] (for j == 0) and
+				   inmem_trans_sysdep_tab[k] (for j == 1).  */
+
+				struct sysdep_string_desc *inmem_tab_entry =
+				  (j == 0
+				   ? inmem_orig_sysdep_tab
+				   : inmem_trans_sysdep_tab)
+				  + k;
+
+				if (W (domain->must_swap, p->sysdepref)
+				    == SEGMENTS_END)
+				  {
+				    /* Only one static segment.  */
+				    inmem_tab_entry->length =
+				      W (domain->must_swap, p->segsize);
+				    inmem_tab_entry->pointer = static_segments;
+				  }
+				else
+				  {
+				    inmem_tab_entry->pointer = mem;
+
+				    for (p = sysdep_string->segments;; p++)
+				      {
+					nls_uint32 segsize =
+					  W (domain->must_swap, p->segsize);
+					nls_uint32 sysdepref =
+					  W (domain->must_swap, p->sysdepref);
+					size_t n;
+
+					if (segsize > 0)
+					  {
+					    memcpy (mem, static_segments, segsize);
+					    mem += segsize;
+					    static_segments += segsize;
+					  }
+
+					if (sysdepref == SEGMENTS_END)
+					  break;
+
+					n = strlen (sysdep_segment_values[sysdepref]);
+					memcpy (mem, sysdep_segment_values[sysdepref], n);
+					mem += n;
+				      }
+
+				    inmem_tab_entry->length =
+				      mem - inmem_tab_entry->pointer;
+				  }
+			      }
+
+			    k++;
+			  }
 		      }
+		    if (k != n_inmem_sysdep_strings)
+		      abort ();
+
+		    /* Compute the augmented hash table.  */
+		    for (i = 0; i < domain->hash_size; i++)
+		      inmem_hash_tab[i] =
+			W (domain->must_swap_hash_tab, domain->hash_tab[i]);
+		    for (i = 0; i < n_inmem_sysdep_strings; i++)
+		      {
+			const char *msgid = inmem_orig_sysdep_tab[i].pointer;
+			nls_uint32 hash_val = hash_string (msgid);
+			nls_uint32 idx = hash_val % domain->hash_size;
+			nls_uint32 incr =
+			  1 + (hash_val % (domain->hash_size - 2));
+
+			for (;;)
+			  {
+			    if (inmem_hash_tab[idx] == 0)
+			      {
+				/* Hash table entry is empty.  Use it.  */
+				inmem_hash_tab[idx] = 1 + domain->nstrings + i;
+				break;
+			      }
+
+			    if (idx >= domain->hash_size - incr)
+			      idx -= domain->hash_size - incr;
+			    else
+			      idx += incr;
+			  }
+		      }
+
+		    domain->n_sysdep_strings = n_inmem_sysdep_strings;
+		    domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
+		    domain->trans_sysdep_tab = inmem_trans_sysdep_tab;
+
+		    domain->hash_tab = inmem_hash_tab;
+		    domain->must_swap_hash_tab = 0;
 		  }
+		else
+		  {
+		    domain->n_sysdep_strings = 0;
+		    domain->orig_sysdep_tab = NULL;
+		    domain->trans_sysdep_tab = NULL;
+		  }
 
 		freea (sysdep_segment_values);
-
-		domain->n_sysdep_strings = n_sysdep_strings;
-		domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
-		domain->trans_sysdep_tab = inmem_trans_sysdep_tab;
-
-		domain->hash_tab = inmem_hash_tab;
-		domain->must_swap_hash_tab = 0;
 	      }
 	    else
 	      {
@@ -1293,8 +1398,7 @@ _nl_load_domain (domain_file, domainbind
 #ifdef _LIBC
 void
 internal_function
-_nl_unload_domain (domain)
-     struct loaded_domain *domain;
+_nl_unload_domain (struct loaded_domain *domain)
 {
   if (domain->plural != &__gettext_germanic_plural)
     __gettext_free_exp (domain->plural);
diff -r 4216c218ee44 -r e04165992166 intl/localcharset.c
--- a/intl/localcharset.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/localcharset.c	Sat May 28 13:45:22 2005 +0000
@@ -1,6 +1,6 @@
 /* Determine a canonical name for the current locale's character encoding.
 
-   Copyright (C) 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 2000-2004 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -22,6 +22,9 @@
 #ifdef HAVE_CONFIG_H
 # include <config.h>
 #endif
+
+/* Specification.  */
+#include "localcharset.h"
 
 #if HAVE_STDDEF_H
 # include <stddef.h>
@@ -64,8 +67,14 @@
 # include <os2.h>
 #endif
 
-#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
-  /* Win32, OS/2, DOS */
+#if ENABLE_RELOCATABLE
+# include "relocatable.h"
+#else
+# define relocate(pathname) (pathname)
+#endif
+
+#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, Cygwin, OS/2, DOS */
 # define ISSLASH(C) ((C) == '/' || (C) == '\\')
 #endif
 
@@ -77,14 +86,9 @@
 # define ISSLASH(C) ((C) == DIRECTORY_SEPARATOR)
 #endif
 
-#ifdef HAVE_GETC_UNLOCKED
+#if HAVE_DECL_GETC_UNLOCKED
 # undef getc
 # define getc getc_unlocked
-#endif
-
-#ifdef __cplusplus
-/* When compiling with "gcc -x c++", produce a function with C linkage.  */
-extern "C" const char * locale_charset (void);
 #endif
 
 /* The following static variable is declared 'volatile' to avoid a
@@ -110,11 +114,17 @@ get_charset_aliases ()
   cp = charset_aliases;
   if (cp == NULL)
     {
-#if !defined WIN32
+#if !(defined VMS || defined WIN32)
       FILE *fp;
-      const char *dir = LIBDIR;
+      const char *dir;
       const char *base = "charset.alias";
       char *file_name;
+
+      /* Make it possible to override the charset.alias location.  This is
+	 necessary for running the testsuite before "make install".  */
+      dir = getenv ("CHARSETALIASDIR");
+      if (dir == NULL || dir[0] == '\0')
+	dir = relocate (LIBDIR);
 
       /* Concatenate dir and base into freshly allocated file_name.  */
       {
@@ -137,15 +147,17 @@ get_charset_aliases ()
       else
 	{
 	  /* Parse the file's contents.  */
-	  int c;
-	  char buf1[50+1];
-	  char buf2[50+1];
 	  char *res_ptr = NULL;
 	  size_t res_size = 0;
-	  size_t l1, l2;
 
 	  for (;;)
 	    {
+	      int c;
+	      char buf1[50+1];
+	      char buf2[50+1];
+	      size_t l1, l2;
+	      char *old_res_ptr;
+
 	      c = getc (fp);
 	      if (c == EOF)
 		break;
@@ -166,6 +178,7 @@ get_charset_aliases ()
 		break;
 	      l1 = strlen (buf1);
 	      l2 = strlen (buf2);
+	      old_res_ptr = res_ptr;
 	      if (res_size == 0)
 		{
 		  res_size = l1 + 1 + l2 + 1;
@@ -180,6 +193,8 @@ get_charset_aliases ()
 		{
 		  /* Out of memory. */
 		  res_size = 0;
+		  if (old_res_ptr != NULL)
+		    free (old_res_ptr);
 		  break;
 		}
 	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
@@ -200,11 +215,36 @@ get_charset_aliases ()
 
 #else
 
+# if defined VMS
+      /* To avoid the troubles of an extra file charset.alias_vms in the
+	 sources of many GNU packages, simply inline the aliases here.  */
+      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation
+	 "Compaq C Run-Time Library Reference Manual for OpenVMS systems"
+	 section 10.7 "Handling Different Character Sets".  */
+      cp = "ISO8859-1" "\0" "ISO-8859-1" "\0"
+	   "ISO8859-2" "\0" "ISO-8859-2" "\0"
+	   "ISO8859-5" "\0" "ISO-8859-5" "\0"
+	   "ISO8859-7" "\0" "ISO-8859-7" "\0"
+	   "ISO8859-8" "\0" "ISO-8859-8" "\0"
+	   "ISO8859-9" "\0" "ISO-8859-9" "\0"
+	   /* Japanese */
+	   "eucJP" "\0" "EUC-JP" "\0"
+	   "SJIS" "\0" "SHIFT_JIS" "\0"
+	   "DECKANJI" "\0" "DEC-KANJI" "\0"
+	   "SDECKANJI" "\0" "EUC-JP" "\0"
+	   /* Chinese */
+	   "eucTW" "\0" "EUC-TW" "\0"
+	   "DECHANYU" "\0" "DEC-HANYU" "\0"
+	   "DECHANZI" "\0" "GB2312" "\0"
+	   /* Korean */
+	   "DECKOREAN" "\0" "EUC-KR" "\0";
+# endif
+
+# if defined WIN32
       /* To avoid the troubles of installing a separate file in the same
 	 directory as the DLL and of retrieving the DLL's directory at
 	 runtime, simply inline the aliases here.  */
 
-# if defined WIN32
       cp = "CP936" "\0" "GBK" "\0"
 	   "CP1361" "\0" "JOHAB" "\0"
 	   "CP20127" "\0" "ASCII" "\0"
diff -r 4216c218ee44 -r e04165992166 intl/localcharset.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/localcharset.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,42 @@
+/* Determine a canonical name for the current locale's character encoding.
+   Copyright (C) 2000-2003 Free Software Foundation, Inc.
+   This file is part of the GNU CHARSET Library.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _LOCALCHARSET_H
+#define _LOCALCHARSET_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Determine the current locale's character encoding, and canonicalize it
+   into one of the canonical names listed in config.charset.
+   The result must not be freed; it is statically allocated.
+   If the canonical name cannot be determined, the result is a non-canonical
+   name.  */
+extern const char * locale_charset (void);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif /* _LOCALCHARSET_H */
diff -r 4216c218ee44 -r e04165992166 intl/locale.alias
--- a/intl/locale.alias	Sat May 28 13:40:15 2005 +0000
+++ b/intl/locale.alias	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 # Locale name alias data base.
-# Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+# Copyright (C) 1996-2001,2003 Free Software Foundation, Inc.
 #
 # This program is free software; you can redistribute it and/or modify it
 # under the terms of the GNU Library General Public License as published
@@ -29,8 +29,8 @@
 
 # Packages using this file: 
 
-bokmal		no_NO.ISO-8859-1
-bokml		no_NO.ISO-8859-1
+bokmal		nb_NO.ISO-8859-1
+bokml		nb_NO.ISO-8859-1
 catalan		ca_ES.ISO-8859-1
 croatian	hr_HR.ISO-8859-2
 czech		cs_CZ.ISO-8859-2
@@ -61,9 +61,9 @@ korean.euc 	ko_KR.eucKR
 korean.euc 	ko_KR.eucKR
 ko_KR		ko_KR.eucKR
 lithuanian      lt_LT.ISO-8859-13
-nb_NO		no_NO.ISO-8859-1
-nb_NO.ISO-8859-1 no_NO.ISO-8859-1
-norwegian       no_NO.ISO-8859-1
+no_NO		nb_NO.ISO-8859-1
+no_NO.ISO-8859-1 nb_NO.ISO-8859-1
+norwegian       nb_NO.ISO-8859-1
 nynorsk		nn_NO.ISO-8859-1
 polish          pl_PL.ISO-8859-2
 portuguese      pt_PT.ISO-8859-1
diff -r 4216c218ee44 -r e04165992166 intl/localealias.c
--- a/intl/localealias.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/localealias.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Handle aliases for locale names.
-   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -35,17 +35,23 @@
 #include <sys/types.h>
 
 #ifdef __GNUC__
+# undef alloca
 # define alloca __builtin_alloca
 # define HAVE_ALLOCA 1
 #else
-# if defined HAVE_ALLOCA_H || defined _LIBC
-#  include <alloca.h>
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
 # else
-#  ifdef _AIX
+#  if defined HAVE_ALLOCA_H || defined _LIBC
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
  #pragma alloca
-#  else
-#   ifndef alloca
+#   else
+#    ifndef alloca
 char *alloca ();
+#    endif
 #   endif
 #  endif
 # endif
@@ -55,6 +61,12 @@ char *alloca ();
 #include <string.h>
 
 #include "gettextP.h"
+
+#if ENABLE_RELOCATABLE
+# include "relocatable.h"
+#else
+# define relocate(pathname) (pathname)
+#endif
 
 /* @@ end of prolog @@ */
 
@@ -98,11 +110,11 @@ __libc_lock_define_initialized (static, 
 # define freea(p) free (p)
 #endif
 
-#if defined _LIBC_REENTRANT || defined HAVE_FGETS_UNLOCKED
+#if defined _LIBC_REENTRANT || HAVE_DECL_FGETS_UNLOCKED
 # undef fgets
 # define fgets(buf, len, s) fgets_unlocked (buf, len, s)
 #endif
-#if defined _LIBC_REENTRANT || defined HAVE_FEOF_UNLOCKED
+#if defined _LIBC_REENTRANT || HAVE_DECL_FEOF_UNLOCKED
 # undef feof
 # define feof(s) feof_unlocked (s)
 #endif
@@ -115,25 +127,28 @@ struct alias_map
 };
 
 
-static char *string_space;
+#ifndef _LIBC
+# define libc_freeres_ptr(decl) decl
+#endif
+
+libc_freeres_ptr (static char *string_space);
 static size_t string_space_act;
 static size_t string_space_max;
-static struct alias_map *map;
+libc_freeres_ptr (static struct alias_map *map);
 static size_t nmap;
 static size_t maxmap;
 
 
 /* Prototypes for local functions.  */
-static size_t read_alias_file PARAMS ((const char *fname, int fname_len))
+static size_t read_alias_file (const char *fname, int fname_len)
      internal_function;
-static int extend_alias_table PARAMS ((void));
-static int alias_compare PARAMS ((const struct alias_map *map1,
-				  const struct alias_map *map2));
+static int extend_alias_table (void);
+static int alias_compare (const struct alias_map *map1,
+			  const struct alias_map *map2);
 
 
 const char *
-_nl_expand_alias (name)
-    const char *name;
+_nl_expand_alias (const char *name)
 {
   static const char *locale_alias_path;
   struct alias_map *retval;
@@ -156,8 +171,8 @@ _nl_expand_alias (name)
       if (nmap > 0)
 	retval = (struct alias_map *) bsearch (&item, map, nmap,
 					       sizeof (struct alias_map),
-					       (int (*) PARAMS ((const void *,
-								 const void *))
+					       (int (*) (const void *,
+							 const void *)
 						) alias_compare);
       else
 	retval = NULL;
@@ -199,9 +214,7 @@ _nl_expand_alias (name)
 
 static size_t
 internal_function
-read_alias_file (fname, fname_len)
-     const char *fname;
-     int fname_len;
+read_alias_file (const char *fname, int fname_len)
 {
   FILE *fp;
   char *full_fname;
@@ -217,7 +230,7 @@ read_alias_file (fname, fname_len)
   memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
 #endif
 
-  fp = fopen (full_fname, "r");
+  fp = fopen (relocate (full_fname), "r");
   freea (full_fname);
   if (fp == NULL)
     return 0;
@@ -234,8 +247,10 @@ read_alias_file (fname, fname_len)
 	 a) we are only interested in the first two fields
 	 b) these fields must be usable as file names and so must not
 	    be that long
-       */
-      char buf[BUFSIZ];
+	 We avoid a multi-kilobyte buffer here since this would use up
+	 stack space which we might not have if the program ran out of
+	 memory.  */
+      char buf[400];
       char *alias;
       char *value;
       char *cp;
@@ -243,19 +258,6 @@ read_alias_file (fname, fname_len)
       if (FGETS (buf, sizeof buf, fp) == NULL)
 	/* EOF reached.  */
 	break;
-
-      /* Possibly not the whole line fits into the buffer.  Ignore
-	 the rest of the line.  */
-      if (strchr (buf, '\n') == NULL)
-	{
-	  char altbuf[BUFSIZ];
-	  do
-	    if (FGETS (altbuf, sizeof altbuf, fp) == NULL)
-	      /* Make sure the inner loop will be left.  The outer loop
-		 will exit at the `feof' test.  */
-	      break;
-	  while (strchr (altbuf, '\n') == NULL);
-	}
 
       cp = buf;
       /* Ignore leading white space.  */
@@ -340,6 +342,14 @@ read_alias_file (fname, fname_len)
 	      ++added;
 	    }
 	}
+
+      /* Possibly not the whole line fits into the buffer.  Ignore
+	 the rest of the line.  */
+      while (strchr (buf, '\n') == NULL)
+	if (FGETS (buf, sizeof buf, fp) == NULL)
+	  /* Make sure the inner loop will be left.  The outer loop
+	     will exit at the `feof' test.  */
+	  break;
     }
 
   /* Should we test for ferror()?  I think we have to silently ignore
@@ -348,7 +358,7 @@ read_alias_file (fname, fname_len)
 
   if (added > 0)
     qsort (map, nmap, sizeof (struct alias_map),
-	   (int (*) PARAMS ((const void *, const void *))) alias_compare);
+	   (int (*) (const void *, const void *)) alias_compare);
 
   return added;
 }
@@ -373,23 +383,8 @@ extend_alias_table ()
 }
 
 
-#ifdef _LIBC
-static void __attribute__ ((unused))
-free_mem (void)
-{
-  if (string_space != NULL)
-    free (string_space);
-  if (map != NULL)
-    free (map);
-}
-text_set_element (__libc_subfreeres, free_mem);
-#endif
-
-
 static int
-alias_compare (map1, map2)
-     const struct alias_map *map1;
-     const struct alias_map *map2;
+alias_compare (const struct alias_map *map1, const struct alias_map *map2)
 {
 #if defined _LIBC || defined HAVE_STRCASECMP
   return strcasecmp (map1->alias, map2->alias);
diff -r 4216c218ee44 -r e04165992166 intl/localename.c
--- a/intl/localename.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/localename.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Determine the current selected locale.
-   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1999, 2000-2005 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -18,6 +18,7 @@
 
 /* Written by Ulrich Drepper <drepper@gnu.org>, 1995.  */
 /* Win32 code written by Tor Lillqvist <tml@iki.fi>.  */
+/* MacOS X code written by Bruno Haible <bruno@clisp.org>.  */
 
 #ifdef HAVE_CONFIG_H
 # include <config.h>
@@ -25,6 +26,16 @@
 
 #include <stdlib.h>
 #include <locale.h>
+
+#if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE
+# include <string.h>
+# include <CFString.h>
+# if HAVE_CFLOCALECOPYCURRENT
+#  include <CFLocale.h>
+# elif HAVE_CFPREFERENCESCOPYAPPVALUE
+#  include <CFPreferences.h>
+# endif
+#endif
 
 #if defined _WIN32 || defined __WIN32__
 # undef WIN32   /* avoid warning on mingw32 */
@@ -34,6 +45,124 @@
 #ifdef WIN32
 # define WIN32_LEAN_AND_MEAN
 # include <windows.h>
+/* List of language codes, sorted by value:
+   0x01 LANG_ARABIC
+   0x02 LANG_BULGARIAN
+   0x03 LANG_CATALAN
+   0x04 LANG_CHINESE
+   0x05 LANG_CZECH
+   0x06 LANG_DANISH
+   0x07 LANG_GERMAN
+   0x08 LANG_GREEK
+   0x09 LANG_ENGLISH
+   0x0a LANG_SPANISH
+   0x0b LANG_FINNISH
+   0x0c LANG_FRENCH
+   0x0d LANG_HEBREW
+   0x0e LANG_HUNGARIAN
+   0x0f LANG_ICELANDIC
+   0x10 LANG_ITALIAN
+   0x11 LANG_JAPANESE
+   0x12 LANG_KOREAN
+   0x13 LANG_DUTCH
+   0x14 LANG_NORWEGIAN
+   0x15 LANG_POLISH
+   0x16 LANG_PORTUGUESE
+   0x17 LANG_RHAETO_ROMANCE
+   0x18 LANG_ROMANIAN
+   0x19 LANG_RUSSIAN
+   0x1a LANG_CROATIAN == LANG_SERBIAN
+   0x1b LANG_SLOVAK
+   0x1c LANG_ALBANIAN
+   0x1d LANG_SWEDISH
+   0x1e LANG_THAI
+   0x1f LANG_TURKISH
+   0x20 LANG_URDU
+   0x21 LANG_INDONESIAN
+   0x22 LANG_UKRAINIAN
+   0x23 LANG_BELARUSIAN
+   0x24 LANG_SLOVENIAN
+   0x25 LANG_ESTONIAN
+   0x26 LANG_LATVIAN
+   0x27 LANG_LITHUANIAN
+   0x28 LANG_TAJIK
+   0x29 LANG_FARSI
+   0x2a LANG_VIETNAMESE
+   0x2b LANG_ARMENIAN
+   0x2c LANG_AZERI
+   0x2d LANG_BASQUE
+   0x2e LANG_SORBIAN
+   0x2f LANG_MACEDONIAN
+   0x30 LANG_SUTU
+   0x31 LANG_TSONGA
+   0x32 LANG_TSWANA
+   0x33 LANG_VENDA
+   0x34 LANG_XHOSA
+   0x35 LANG_ZULU
+   0x36 LANG_AFRIKAANS
+   0x37 LANG_GEORGIAN
+   0x38 LANG_FAEROESE
+   0x39 LANG_HINDI
+   0x3a LANG_MALTESE
+   0x3b LANG_SAAMI
+   0x3c LANG_GAELIC
+   0x3d LANG_YIDDISH
+   0x3e LANG_MALAY
+   0x3f LANG_KAZAK
+   0x40 LANG_KYRGYZ
+   0x41 LANG_SWAHILI
+   0x42 LANG_TURKMEN
+   0x43 LANG_UZBEK
+   0x44 LANG_TATAR
+   0x45 LANG_BENGALI
+   0x46 LANG_PUNJABI
+   0x47 LANG_GUJARATI
+   0x48 LANG_ORIYA
+   0x49 LANG_TAMIL
+   0x4a LANG_TELUGU
+   0x4b LANG_KANNADA
+   0x4c LANG_MALAYALAM
+   0x4d LANG_ASSAMESE
+   0x4e LANG_MARATHI
+   0x4f LANG_SANSKRIT
+   0x50 LANG_MONGOLIAN
+   0x51 LANG_TIBETAN
+   0x52 LANG_WELSH
+   0x53 LANG_CAMBODIAN
+   0x54 LANG_LAO
+   0x55 LANG_BURMESE
+   0x56 LANG_GALICIAN
+   0x57 LANG_KONKANI
+   0x58 LANG_MANIPURI
+   0x59 LANG_SINDHI
+   0x5a LANG_SYRIAC
+   0x5b LANG_SINHALESE
+   0x5c LANG_CHEROKEE
+   0x5d LANG_INUKTITUT
+   0x5e LANG_AMHARIC
+   0x5f LANG_TAMAZIGHT
+   0x60 LANG_KASHMIRI
+   0x61 LANG_NEPALI
+   0x62 LANG_FRISIAN
+   0x63 LANG_PASHTO
+   0x64 LANG_TAGALOG
+   0x65 LANG_DIVEHI
+   0x66 LANG_EDO
+   0x67 LANG_FULFULDE
+   0x68 LANG_HAUSA
+   0x69 LANG_IBIBIO
+   0x6a LANG_YORUBA
+   0x70 LANG_IGBO
+   0x71 LANG_KANURI
+   0x72 LANG_OROMO
+   0x73 LANG_TIGRINYA
+   0x74 LANG_GUARANI
+   0x75 LANG_HAWAIIAN
+   0x76 LANG_LATIN
+   0x77 LANG_SOMALI
+   0x78 LANG_YI
+   0x79 LANG_PAPIAMENTU
+*/
 /* Mingw headers don't have latest language and sublanguage codes.  */
 # ifndef LANG_AFRIKAANS
 # define LANG_AFRIKAANS 0x36
@@ -41,6 +170,9 @@
 # ifndef LANG_ALBANIAN
 # define LANG_ALBANIAN 0x1c
 # endif
+# ifndef LANG_AMHARIC
+# define LANG_AMHARIC 0x5e
+# endif
 # ifndef LANG_ARABIC
 # define LANG_ARABIC 0x01
 # endif
@@ -62,12 +194,24 @@
 # ifndef LANG_BENGALI
 # define LANG_BENGALI 0x45
 # endif
+# ifndef LANG_BURMESE
+# define LANG_BURMESE 0x55
+# endif
+# ifndef LANG_CAMBODIAN
+# define LANG_CAMBODIAN 0x53
+# endif
 # ifndef LANG_CATALAN
 # define LANG_CATALAN 0x03
 # endif
+# ifndef LANG_CHEROKEE
+# define LANG_CHEROKEE 0x5c
+# endif
 # ifndef LANG_DIVEHI
 # define LANG_DIVEHI 0x65
 # endif
+# ifndef LANG_EDO
+# define LANG_EDO 0x66
+# endif
 # ifndef LANG_ESTONIAN
 # define LANG_ESTONIAN 0x25
 # endif
@@ -77,27 +221,57 @@
 # ifndef LANG_FARSI
 # define LANG_FARSI 0x29
 # endif
+# ifndef LANG_FRISIAN
+# define LANG_FRISIAN 0x62
+# endif
+# ifndef LANG_FULFULDE
+# define LANG_FULFULDE 0x67
+# endif
+# ifndef LANG_GAELIC
+# define LANG_GAELIC 0x3c
+# endif
 # ifndef LANG_GALICIAN
 # define LANG_GALICIAN 0x56
 # endif
 # ifndef LANG_GEORGIAN
 # define LANG_GEORGIAN 0x37
 # endif
+# ifndef LANG_GUARANI
+# define LANG_GUARANI 0x74
+# endif
 # ifndef LANG_GUJARATI
 # define LANG_GUJARATI 0x47
 # endif
+# ifndef LANG_HAUSA
+# define LANG_HAUSA 0x68
+# endif
+# ifndef LANG_HAWAIIAN
+# define LANG_HAWAIIAN 0x75
+# endif
 # ifndef LANG_HEBREW
 # define LANG_HEBREW 0x0d
 # endif
 # ifndef LANG_HINDI
 # define LANG_HINDI 0x39
 # endif
+# ifndef LANG_IBIBIO
+# define LANG_IBIBIO 0x69
+# endif
+# ifndef LANG_IGBO
+# define LANG_IGBO 0x70
+# endif
 # ifndef LANG_INDONESIAN
 # define LANG_INDONESIAN 0x21
 # endif
+# ifndef LANG_INUKTITUT
+# define LANG_INUKTITUT 0x5d
+# endif
 # ifndef LANG_KANNADA
 # define LANG_KANNADA 0x4b
 # endif
+# ifndef LANG_KANURI
+# define LANG_KANURI 0x71
+# endif
 # ifndef LANG_KASHMIRI
 # define LANG_KASHMIRI 0x60
 # endif
@@ -110,6 +284,12 @@
 # ifndef LANG_KYRGYZ
 # define LANG_KYRGYZ 0x40
 # endif
+# ifndef LANG_LAO
+# define LANG_LAO 0x54
+# endif
+# ifndef LANG_LATIN
+# define LANG_LATIN 0x76
+# endif
 # ifndef LANG_LATVIAN
 # define LANG_LATVIAN 0x26
 # endif
@@ -125,6 +305,9 @@
 # ifndef LANG_MALAYALAM
 # define LANG_MALAYALAM 0x4c
 # endif
+# ifndef LANG_MALTESE
+# define LANG_MALTESE 0x3a
+# endif
 # ifndef LANG_MANIPURI
 # define LANG_MANIPURI 0x58
 # endif
@@ -140,9 +323,24 @@
 # ifndef LANG_ORIYA
 # define LANG_ORIYA 0x48
 # endif
+# ifndef LANG_OROMO
+# define LANG_OROMO 0x72
+# endif
+# ifndef LANG_PAPIAMENTU
+# define LANG_PAPIAMENTU 0x79
+# endif
+# ifndef LANG_PASHTO
+# define LANG_PASHTO 0x63
+# endif
 # ifndef LANG_PUNJABI
 # define LANG_PUNJABI 0x46
 # endif
+# ifndef LANG_RHAETO_ROMANCE
+# define LANG_RHAETO_ROMANCE 0x17
+# endif
+# ifndef LANG_SAAMI
+# define LANG_SAAMI 0x3b
+# endif
 # ifndef LANG_SANSKRIT
 # define LANG_SANSKRIT 0x4f
 # endif
@@ -152,18 +350,36 @@
 # ifndef LANG_SINDHI
 # define LANG_SINDHI 0x59
 # endif
+# ifndef LANG_SINHALESE
+# define LANG_SINHALESE 0x5b
+# endif
 # ifndef LANG_SLOVAK
 # define LANG_SLOVAK 0x1b
 # endif
+# ifndef LANG_SOMALI
+# define LANG_SOMALI 0x77
+# endif
 # ifndef LANG_SORBIAN
 # define LANG_SORBIAN 0x2e
 # endif
+# ifndef LANG_SUTU
+# define LANG_SUTU 0x30
+# endif
 # ifndef LANG_SWAHILI
 # define LANG_SWAHILI 0x41
 # endif
 # ifndef LANG_SYRIAC
 # define LANG_SYRIAC 0x5a
 # endif
+# ifndef LANG_TAGALOG
+# define LANG_TAGALOG 0x64
+# endif
+# ifndef LANG_TAJIK
+# define LANG_TAJIK 0x28
+# endif
+# ifndef LANG_TAMAZIGHT
+# define LANG_TAMAZIGHT 0x5f
+# endif
 # ifndef LANG_TAMIL
 # define LANG_TAMIL 0x49
 # endif
@@ -176,6 +392,21 @@
 # ifndef LANG_THAI
 # define LANG_THAI 0x1e
 # endif
+# ifndef LANG_TIBETAN
+# define LANG_TIBETAN 0x51
+# endif
+# ifndef LANG_TIGRINYA
+# define LANG_TIGRINYA 0x73
+# endif
+# ifndef LANG_TSONGA
+# define LANG_TSONGA 0x31
+# endif
+# ifndef LANG_TSWANA
+# define LANG_TSWANA 0x32
+# endif
+# ifndef LANG_TURKMEN
+# define LANG_TURKMEN 0x42
+# endif
 # ifndef LANG_UKRAINIAN
 # define LANG_UKRAINIAN 0x22
 # endif
@@ -185,9 +416,30 @@
 # ifndef LANG_UZBEK
 # define LANG_UZBEK 0x43
 # endif
+# ifndef LANG_VENDA
+# define LANG_VENDA 0x33
+# endif
 # ifndef LANG_VIETNAMESE
 # define LANG_VIETNAMESE 0x2a
 # endif
+# ifndef LANG_WELSH
+# define LANG_WELSH 0x52
+# endif
+# ifndef LANG_XHOSA
+# define LANG_XHOSA 0x34
+# endif
+# ifndef LANG_YI
+# define LANG_YI 0x78
+# endif
+# ifndef LANG_YIDDISH
+# define LANG_YIDDISH 0x3d
+# endif
+# ifndef LANG_YORUBA
+# define LANG_YORUBA 0x6a
+# endif
+# ifndef LANG_ZULU
+# define LANG_ZULU 0x35
+# endif
 # ifndef SUBLANG_ARABIC_SAUDI_ARABIA
 # define SUBLANG_ARABIC_SAUDI_ARABIA 0x01
 # endif
@@ -242,6 +494,12 @@
 # ifndef SUBLANG_AZERI_CYRILLIC
 # define SUBLANG_AZERI_CYRILLIC 0x02
 # endif
+# ifndef SUBLANG_BENGALI_INDIA
+# define SUBLANG_BENGALI_INDIA 0x00
+# endif
+# ifndef SUBLANG_BENGALI_BANGLADESH
+# define SUBLANG_BENGALI_BANGLADESH 0x01
+# endif
 # ifndef SUBLANG_CHINESE_MACAU
 # define SUBLANG_CHINESE_MACAU 0x05
 # endif
@@ -266,12 +524,54 @@
 # ifndef SUBLANG_ENGLISH_PHILIPPINES
 # define SUBLANG_ENGLISH_PHILIPPINES 0x0d
 # endif
+# ifndef SUBLANG_ENGLISH_INDONESIA
+# define SUBLANG_ENGLISH_INDONESIA 0x0e
+# endif
+# ifndef SUBLANG_ENGLISH_HONGKONG
+# define SUBLANG_ENGLISH_HONGKONG 0x0f
+# endif
+# ifndef SUBLANG_ENGLISH_INDIA
+# define SUBLANG_ENGLISH_INDIA 0x10
+# endif
+# ifndef SUBLANG_ENGLISH_MALAYSIA
+# define SUBLANG_ENGLISH_MALAYSIA 0x11
+# endif
+# ifndef SUBLANG_ENGLISH_SINGAPORE
+# define SUBLANG_ENGLISH_SINGAPORE 0x12
+# endif
 # ifndef SUBLANG_FRENCH_LUXEMBOURG
 # define SUBLANG_FRENCH_LUXEMBOURG 0x05
 # endif
 # ifndef SUBLANG_FRENCH_MONACO
 # define SUBLANG_FRENCH_MONACO 0x06
 # endif
+# ifndef SUBLANG_FRENCH_WESTINDIES
+# define SUBLANG_FRENCH_WESTINDIES 0x07
+# endif
+# ifndef SUBLANG_FRENCH_REUNION
+# define SUBLANG_FRENCH_REUNION 0x08
+# endif
+# ifndef SUBLANG_FRENCH_CONGO
+# define SUBLANG_FRENCH_CONGO 0x09
+# endif
+# ifndef SUBLANG_FRENCH_SENEGAL
+# define SUBLANG_FRENCH_SENEGAL 0x0a
+# endif
+# ifndef SUBLANG_FRENCH_CAMEROON
+# define SUBLANG_FRENCH_CAMEROON 0x0b
+# endif
+# ifndef SUBLANG_FRENCH_COTEDIVOIRE
+# define SUBLANG_FRENCH_COTEDIVOIRE 0x0c
+# endif
+# ifndef SUBLANG_FRENCH_MALI
+# define SUBLANG_FRENCH_MALI 0x0d
+# endif
+# ifndef SUBLANG_FRENCH_MOROCCO
+# define SUBLANG_FRENCH_MOROCCO 0x0e
+# endif
+# ifndef SUBLANG_FRENCH_HAITI
+# define SUBLANG_FRENCH_HAITI 0x0f
+# endif
 # ifndef SUBLANG_GERMAN_LUXEMBOURG
 # define SUBLANG_GERMAN_LUXEMBOURG 0x04
 # endif
@@ -290,12 +590,30 @@
 # ifndef SUBLANG_NEPALI_INDIA
 # define SUBLANG_NEPALI_INDIA 0x02
 # endif
+# ifndef SUBLANG_PUNJABI_INDIA
+# define SUBLANG_PUNJABI_INDIA 0x00
+# endif
+# ifndef SUBLANG_PUNJABI_PAKISTAN
+# define SUBLANG_PUNJABI_PAKISTAN 0x01
+# endif
+# ifndef SUBLANG_ROMANIAN_ROMANIA
+# define SUBLANG_ROMANIAN_ROMANIA 0x00
+# endif
+# ifndef SUBLANG_ROMANIAN_MOLDOVA
+# define SUBLANG_ROMANIAN_MOLDOVA 0x01
+# endif
 # ifndef SUBLANG_SERBIAN_LATIN
 # define SUBLANG_SERBIAN_LATIN 0x02
 # endif
 # ifndef SUBLANG_SERBIAN_CYRILLIC
 # define SUBLANG_SERBIAN_CYRILLIC 0x03
 # endif
+# ifndef SUBLANG_SINDHI_INDIA
+# define SUBLANG_SINDHI_INDIA 0x00
+# endif
+# ifndef SUBLANG_SINDHI_PAKISTAN
+# define SUBLANG_SINDHI_PAKISTAN 0x01
+# endif
 # ifndef SUBLANG_SPANISH_GUATEMALA
 # define SUBLANG_SPANISH_GUATEMALA 0x04
 # endif
@@ -350,6 +668,18 @@
 # ifndef SUBLANG_SWEDISH_FINLAND
 # define SUBLANG_SWEDISH_FINLAND 0x02
 # endif
+# ifndef SUBLANG_TAMAZIGHT_ARABIC
+# define SUBLANG_TAMAZIGHT_ARABIC 0x01
+# endif
+# ifndef SUBLANG_TAMAZIGHT_LATIN
+# define SUBLANG_TAMAZIGHT_LATIN 0x02
+# endif
+# ifndef SUBLANG_TIGRINYA_ETHIOPIA
+# define SUBLANG_TIGRINYA_ETHIOPIA 0x00
+# endif
+# ifndef SUBLANG_TIGRINYA_ERITREA
+# define SUBLANG_TIGRINYA_ERITREA 0x01
+# endif
 # ifndef SUBLANG_URDU_PAKISTAN
 # define SUBLANG_URDU_PAKISTAN 0x01
 # endif
@@ -362,6 +692,280 @@
 # ifndef SUBLANG_UZBEK_CYRILLIC
 # define SUBLANG_UZBEK_CYRILLIC 0x02
 # endif
+#endif
+
+# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE
+/* MacOS X 10.2 or newer */
+
+/* Canonicalize a MacOS X locale name to a Unix locale name.
+   NAME is a sufficiently large buffer.
+   On input, it contains the MacOS X locale name.
+   On output, it contains the Unix locale name.  */
+void
+_nl_locale_name_canonicalize (char *name)
+{
+  /* This conversion is based on a posting by
+     Deborah GoldSmith <goldsmit@apple.com> on 2005-03-08,
+     http://lists.apple.com/archives/carbon-dev/2005/Mar/msg00293.html */
+
+  /* Convert legacy (NeXTstep inherited) English names to Unix (ISO 639 and
+     ISO 3166) names.  Prior to MacOS X 10.3, there is no API for doing this.
+     Therefore we do it ourselves, using a table based on the results of the
+     MacOS X 10.3.8 function
+     CFLocaleCreateCanonicalLocaleIdentifierFromString().  */
+  typedef struct { const char legacy[21+1]; const char unixy[5+1]; }
+	  legacy_entry;
+  static const legacy_entry legacy_table[] = {
+    { "Afrikaans",             "af" },
+    { "Albanian",              "sq" },
+    { "Amharic",               "am" },
+    { "Arabic",                "ar" },
+    { "Armenian",              "hy" },
+    { "Assamese",              "as" },
+    { "Aymara",                "ay" },
+    { "Azerbaijani",           "az" },
+    { "Basque",                "eu" },
+    { "Belarusian",            "be" },
+    { "Belorussian",           "be" },
+    { "Bengali",               "bn" },
+    { "Brazilian Portugese",   "pt_BR" },
+    { "Brazilian Portuguese",  "pt_BR" },
+    { "Breton",                "br" },
+    { "Bulgarian",             "bg" },
+    { "Burmese",               "my" },
+    { "Byelorussian",          "be" },
+    { "Catalan",               "ca" },
+    { "Chewa",                 "ny" },
+    { "Chichewa",              "ny" },
+    { "Chinese",               "zh" },
+    { "Chinese, Simplified",   "zh_CN" },
+    { "Chinese, Traditional",  "zh_TW" },
+    { "Chinese, Tradtional",   "zh_TW" },
+    { "Croatian",              "hr" },
+    { "Czech",                 "cs" },
+    { "Danish",                "da" },
+    { "Dutch",                 "nl" },
+    { "Dzongkha",              "dz" },
+    { "English",               "en" },
+    { "Esperanto",             "eo" },
+    { "Estonian",              "et" },
+    { "Faroese",               "fo" },
+    { "Farsi",                 "fa" },
+    { "Finnish",               "fi" },
+    { "Flemish",               "nl_BE" },
+    { "French",                "fr" },
+    { "Galician",              "gl" },
+    { "Gallegan",              "gl" },
+    { "Georgian",              "ka" },
+    { "German",                "de" },
+    { "Greek",                 "el" },
+    { "Greenlandic",           "kl" },
+    { "Guarani",               "gn" },
+    { "Gujarati",              "gu" },
+    { "Hawaiian",              "haw" }, /* Yes, "haw", not "cpe".  */
+    { "Hebrew",                "he" },
+    { "Hindi",                 "hi" },
+    { "Hungarian",             "hu" },
+    { "Icelandic",             "is" },
+    { "Indonesian",            "id" },
+    { "Inuktitut",             "iu" },
+    { "Irish",                 "ga" },
+    { "Italian",               "it" },
+    { "Japanese",              "ja" },
+    { "Javanese",              "jv" },
+    { "Kalaallisut",           "kl" },
+    { "Kannada",               "kn" },
+    { "Kashmiri",              "ks" },
+    { "Kazakh",                "kk" },
+    { "Khmer",                 "km" },
+    { "Kinyarwanda",           "rw" },
+    { "Kirghiz",               "ky" },
+    { "Korean",                "ko" },
+    { "Kurdish",               "ku" },
+    { "Latin",                 "la" },
+    { "Latvian",               "lv" },
+    { "Lithuanian",            "lt" },
+    { "Macedonian",            "mk" },
+    { "Malagasy",              "mg" },
+    { "Malay",                 "ms" },
+    { "Malayalam",             "ml" },
+    { "Maltese",               "mt" },
+    { "Manx",                  "gv" },
+    { "Marathi",               "mr" },
+    { "Moldavian",             "mo" },
+    { "Mongolian",             "mn" },
+    { "Nepali",                "ne" },
+    { "Norwegian",             "nb" }, /* Yes, "nb", not the obsolete "no".  */
+    { "Nyanja",                "ny" },
+    { "Nynorsk",               "nn" },
+    { "Oriya",                 "or" },
+    { "Oromo",                 "om" },
+    { "Panjabi",               "pa" },
+    { "Pashto",                "ps" },
+    { "Persian",               "fa" },
+    { "Polish",                "pl" },
+    { "Portuguese",            "pt" },
+    { "Portuguese, Brazilian", "pt_BR" },
+    { "Punjabi",               "pa" },
+    { "Pushto",                "ps" },
+    { "Quechua",               "qu" },
+    { "Romanian",              "ro" },
+    { "Ruanda",                "rw" },
+    { "Rundi",                 "rn" },
+    { "Russian",               "ru" },
+    { "Sami",                  "se_NO" }, /* Not just "se".  */
+    { "Sanskrit",              "sa" },
+    { "Scottish",              "gd" },
+    { "Serbian",               "sr" },
+    { "Simplified Chinese",    "zh_CN" },
+    { "Sindhi",                "sd" },
+    { "Sinhalese",             "si" },
+    { "Slovak",                "sk" },
+    { "Slovenian",             "sl" },
+    { "Somali",                "so" },
+    { "Spanish",               "es" },
+    { "Sundanese",             "su" },
+    { "Swahili",               "sw" },
+    { "Swedish",               "sv" },
+    { "Tagalog",               "tl" },
+    { "Tajik",                 "tg" },
+    { "Tajiki",                "tg" },
+    { "Tamil",                 "ta" },
+    { "Tatar",                 "tt" },
+    { "Telugu",                "te" },
+    { "Thai",                  "th" },
+    { "Tibetan",               "bo" },
+    { "Tigrinya",              "ti" },
+    { "Tongan",                "to" },
+    { "Traditional Chinese",   "zh_TW" },
+    { "Turkish",               "tr" },
+    { "Turkmen",               "tk" },
+    { "Uighur",                "ug" },
+    { "Ukrainian",             "uk" },
+    { "Urdu",                  "ur" },
+    { "Uzbek",                 "uz" },
+    { "Vietnamese",            "vi" },
+    { "Welsh",                 "cy" },
+    { "Yiddish",               "yi" }
+  };
+
+  /* Convert new-style locale names with language tags (ISO 639 and ISO 15924)
+     to Unix (ISO 639 and ISO 3166) names.  */
+  typedef struct { const char langtag[7+1]; const char unixy[12+1]; }
+	  langtag_entry;
+  static const langtag_entry langtag_table[] = {
+    /* MacOS X has "az-Arab", "az-Cyrl", "az-Latn".
+       The default script for az on Unix is Latin.  */
+    { "az-Latn", "az" },
+    /* MacOS X has "ga-dots".  Does not yet exist on Unix.  */
+    { "ga-dots", "ga" },
+    /* MacOS X has "kk-Cyrl".  Does not yet exist on Unix.  */
+    /* MacOS X has "mn-Cyrl", "mn-Mong".
+       The default script for mn on Unix is Cyrillic.  */
+    { "mn-Cyrl", "mn" },
+    /* MacOS X has "ms-Arab", "ms-Latn".
+       The default script for ms on Unix is Latin.  */
+    { "ms-Latn", "ms" },
+    /* MacOS X has "tg-Cyrl".
+       The default script for tg on Unix is Cyrillic.  */
+    { "tg-Cyrl", "tg" },
+    /* MacOS X has "tk-Cyrl".  Does not yet exist on Unix.  */
+    /* MacOS X has "tt-Cyrl".
+       The default script for tt on Unix is Cyrillic.  */
+    { "tt-Cyrl", "tt" },
+    /* MacOS X has "zh-Hans", "zh-Hant".
+       Country codes are used to distinguish these on Unix.  */
+    { "zh-Hans", "zh_CN" },
+    { "zh-Hant", "zh_TW" }
+  };
+
+  /* Convert script names (ISO 15924) to Unix conventions.
+     See http://www.unicode.org/iso15924/iso15924-codes.html  */
+  typedef struct { const char script[4+1]; const char unixy[9+1]; }
+	  script_entry;
+  static const script_entry script_table[] = {
+    { "Arab", "arabic" },
+    { "Cyrl", "cyrillic" },
+    { "Mong", "mongolian" }
+  };
+
+  /* Step 1: Convert using legacy_table.  */
+  if (name[0] >= 'A' && name[0] <= 'Z')
+    {
+      unsigned int i1, i2;
+      i1 = 0;
+      i2 = sizeof (legacy_table) / sizeof (legacy_entry);
+      while (i2 - i1 > 1)
+	{
+	  /* At this point we know that if name occurs in legacy_table,
+	     its index must be >= i1 and < i2.  */
+	  unsigned int i = (i1 + i2) >> 1;
+	  const legacy_entry *p = &legacy_table[i];
+	  if (strcmp (name, p->legacy) < 0)
+	    i2 = i;
+	  else
+	    i1 = i;
+	}
+      if (strcmp (name, legacy_table[i1].legacy) == 0)
+	{
+	  strcpy (name, legacy_table[i1].unixy);
+	  return;
+	}
+    }
+
+  /* Step 2: Convert using langtag_table and script_table.  */
+  if (strlen (name) == 7 && name[2] == '-')
+    {
+      unsigned int i1, i2;
+      i1 = 0;
+      i2 = sizeof (langtag_table) / sizeof (langtag_entry);
+      while (i2 - i1 > 1)
+	{
+	  /* At this point we know that if name occurs in langtag_table,
+	     its index must be >= i1 and < i2.  */
+	  unsigned int i = (i1 + i2) >> 1;
+	  const langtag_entry *p = &langtag_table[i];
+	  if (strcmp (name, p->langtag) < 0)
+	    i2 = i;
+	  else
+	    i1 = i;
+	}
+      if (strcmp (name, langtag_table[i1].langtag) == 0)
+	{
+	  strcpy (name, langtag_table[i1].unixy);
+	  return;
+	}
+
+      i1 = 0;
+      i2 = sizeof (script_table) / sizeof (script_entry);
+      while (i2 - i1 > 1)
+	{
+	  /* At this point we know that if (name + 3) occurs in script_table,
+	     its index must be >= i1 and < i2.  */
+	  unsigned int i = (i1 + i2) >> 1;
+	  const script_entry *p = &script_table[i];
+	  if (strcmp (name + 3, p->script) < 0)
+	    i2 = i;
+	  else
+	    i1 = i;
+	}
+      if (strcmp (name + 3, script_table[i1].script) == 0)
+	{
+	  name[2] = '@';
+	  strcpy (name + 3, script_table[i1].unixy);
+	  return;
+	}
+    }
+
+  /* Step 3: Convert new-style dash to Unix underscore. */
+  {
+    char *p;
+    for (p = name; *p != '\0'; p++)
+      if (*p == '-')
+	*p = '_';
+  }
+}
+
 #endif
 
 /* XPG3 defines the result of 'setlocale (category, NULL)' as:
@@ -381,131 +985,183 @@
    The result must not be freed; it is statically allocated.  */
 
 const char *
-_nl_locale_name (category, categoryname)
-     int category;
-     const char *categoryname;
+_nl_locale_name_posix (int category, const char *categoryname)
 {
-  const char *retval;
-
-#ifndef WIN32
-
   /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.
      On some systems this can be done by the 'setlocale' function itself.  */
-# if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
-  retval = setlocale (category, NULL);
-# else
-  /* Setting of LC_ALL overwrites all other.  */
+#if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
+  return setlocale (category, NULL);
+#else
+  const char *retval;
+
+  /* Setting of LC_ALL overrides all other.  */
   retval = getenv ("LC_ALL");
-  if (retval == NULL || retval[0] == '\0')
-    {
-      /* Next comes the name of the desired category.  */
-      retval = getenv (categoryname);
-      if (retval == NULL || retval[0] == '\0')
-	{
-	  /* Last possibility is the LANG environment variable.  */
-	  retval = getenv ("LANG");
-	  if (retval == NULL || retval[0] == '\0')
-	    /* We use C as the default domain.  POSIX says this is
-	       implementation defined.  */
-	    retval = "C";
-	}
-    }
-# endif
-
-  return retval;
-
-#else /* WIN32 */
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+  /* Next comes the name of the desired category.  */
+  retval = getenv (categoryname);
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+  /* Last possibility is the LANG environment variable.  */
+  retval = getenv ("LANG");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  return NULL;
+#endif
+}
+
+const char *
+_nl_locale_name_default (void)
+{
+  /* POSIX:2001 says:
+     "All implementations shall define a locale as the default locale, to be
+      invoked when no environment variables are set, or set to the empty
+      string.  This default locale can be the POSIX locale or any other
+      implementation-defined locale.  Some implementations may provide
+      facilities for local installation administrators to set the default
+      locale, customizing it for each location.  POSIX:2001 does not require
+      such a facility.  */
+
+#if !(HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE || defined(WIN32))
+
+  /* The system does not have a way of setting the locale, other than the
+     POSIX specified environment variables.  We use C as default locale.  */
+  return "C";
+
+#else
 
   /* Return an XPG style locale name language[_territory][@modifier].
      Don't even bother determining the codeset; it's not useful in this
      context, because message catalogs are not specific to a single
      codeset.  */
 
-  LCID lcid;
-  LANGID langid;
-  int primary, sub;
-
-  /* Let the user override the system settings through environment
-     variables, as on POSIX systems.  */
-  retval = getenv ("LC_ALL");
-  if (retval != NULL && retval[0] != '\0')
-    return retval;
-  retval = getenv (categoryname);
-  if (retval != NULL && retval[0] != '\0')
-    return retval;
-  retval = getenv ("LANG");
-  if (retval != NULL && retval[0] != '\0')
-    return retval;
-
-  /* Use native Win32 API locale ID.  */
-  lcid = GetThreadLocale ();
-
-  /* Strip off the sorting rules, keep only the language part.  */
-  langid = LANGIDFROMLCID (lcid);
-
-  /* Split into language and territory part.  */
-  primary = PRIMARYLANGID (langid);
-  sub = SUBLANGID (langid);
-
-  /* Dispatch on language.
-     See also http://www.unicode.org/unicode/onlinedat/languages.html .
-     For details about languages, see http://www.ethnologue.com/ .  */
-  switch (primary)
-    {
-    case LANG_AFRIKAANS: return "af_ZA";
-    case LANG_ALBANIAN: return "sq_AL";
-    case 0x5e: /* AMHARIC */ return "am_ET";
-    case LANG_ARABIC:
-      switch (sub)
-	{
-	case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
-	case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
-	case SUBLANG_ARABIC_EGYPT: return "ar_EG";
-	case SUBLANG_ARABIC_LIBYA: return "ar_LY";
-	case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
-	case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
-	case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
-	case SUBLANG_ARABIC_OMAN: return "ar_OM";
-	case SUBLANG_ARABIC_YEMEN: return "ar_YE";
-	case SUBLANG_ARABIC_SYRIA: return "ar_SY";
-	case SUBLANG_ARABIC_JORDAN: return "ar_JO";
-	case SUBLANG_ARABIC_LEBANON: return "ar_LB";
-	case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
-	case SUBLANG_ARABIC_UAE: return "ar_AE";
-	case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
-	case SUBLANG_ARABIC_QATAR: return "ar_QA";
-	}
-      return "ar";
-    case LANG_ARMENIAN: return "hy_AM";
-    case LANG_ASSAMESE: return "as_IN";
-    case LANG_AZERI:
-      switch (sub)
-	{
-	/* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
-	case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
-	case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
-	}
-      return "az";
-    case LANG_BASQUE:
-      return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
-    case LANG_BELARUSIAN: return "be_BY";
-    case LANG_BENGALI: return "bn_IN";
-    case LANG_BULGARIAN: return "bg_BG";
-    case 0x55: /* BURMESE */ return "my_MM";
-    case 0x53: /* CAMBODIAN */ return "km_KH";
-    case LANG_CATALAN: return "ca_ES";
-    case 0x5c: /* CHEROKEE */ return "chr_US";
-    case LANG_CHINESE:
-      switch (sub)
-	{
-	case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
-	case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
-	case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
-	case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
-	case SUBLANG_CHINESE_MACAU: return "zh_MO";
-	}
-      return "zh";
-    case LANG_CROATIAN:		/* LANG_CROATIAN == LANG_SERBIAN
+# if HAVE_CFLOCALECOPYCURRENT || HAVE_CFPREFERENCESCOPYAPPVALUE
+  /* MacOS X 10.2 or newer */
+  {
+    /* Cache the locale name, since CoreFoundation calls are expensive.  */
+    static const char *cached_localename;
+
+    if (cached_localename == NULL)
+      {
+	char namebuf[256];
+#  if HAVE_CFLOCALECOPYCURRENT /* MacOS X 10.3 or newer */
+	CFLocaleRef locale = CFLocaleCopyCurrent ();
+	CFStringRef name = CFLocaleGetIdentifier (locale);
+
+	if (CFStringGetCString (name, namebuf, sizeof(namebuf),
+				kCFStringEncodingASCII))
+	  {
+	    _nl_locale_name_canonicalize (namebuf);
+	    cached_localename = strdup (namebuf);
+	  }
+	CFRelease (locale);
+#  elif HAVE_CFPREFERENCESCOPYAPPVALUE /* MacOS X 10.2 or newer */
+	CFTypeRef value =
+	  CFPreferencesCopyAppValue (CFSTR ("AppleLocale"),
+				     kCFPreferencesCurrentApplication);
+	if (value != NULL
+	    && CFGetTypeID (value) == CFStringGetTypeID ()
+	    && CFStringGetCString ((CFStringRef)value, namebuf, sizeof(namebuf),
+				   kCFStringEncodingASCII))
+	  {
+	    _nl_locale_name_canonicalize (namebuf);
+	    cached_localename = strdup (namebuf);
+	  }
+#  endif
+	if (cached_localename == NULL)
+	  cached_localename = "C";
+      }
+    return cached_localename;
+  }
+
+# endif
+
+# if defined(WIN32) /* WIN32 */
+  {
+    LCID lcid;
+    LANGID langid;
+    int primary, sub;
+
+    /* Use native Win32 API locale ID.  */
+    lcid = GetThreadLocale ();
+
+    /* Strip off the sorting rules, keep only the language part.  */
+    langid = LANGIDFROMLCID (lcid);
+
+    /* Split into language and territory part.  */
+    primary = PRIMARYLANGID (langid);
+    sub = SUBLANGID (langid);
+
+    /* Dispatch on language.
+       See also http://www.unicode.org/unicode/onlinedat/languages.html .
+       For details about languages, see http://www.ethnologue.com/ .  */
+    switch (primary)
+      {
+      case LANG_AFRIKAANS: return "af_ZA";
+      case LANG_ALBANIAN: return "sq_AL";
+      case LANG_AMHARIC: return "am_ET";
+      case LANG_ARABIC:
+	switch (sub)
+	  {
+	  case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
+	  case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
+	  case SUBLANG_ARABIC_EGYPT: return "ar_EG";
+	  case SUBLANG_ARABIC_LIBYA: return "ar_LY";
+	  case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
+	  case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
+	  case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
+	  case SUBLANG_ARABIC_OMAN: return "ar_OM";
+	  case SUBLANG_ARABIC_YEMEN: return "ar_YE";
+	  case SUBLANG_ARABIC_SYRIA: return "ar_SY";
+	  case SUBLANG_ARABIC_JORDAN: return "ar_JO";
+	  case SUBLANG_ARABIC_LEBANON: return "ar_LB";
+	  case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
+	  case SUBLANG_ARABIC_UAE: return "ar_AE";
+	  case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
+	  case SUBLANG_ARABIC_QATAR: return "ar_QA";
+	  }
+	return "ar";
+      case LANG_ARMENIAN: return "hy_AM";
+      case LANG_ASSAMESE: return "as_IN";
+      case LANG_AZERI:
+	switch (sub)
+	  {
+	  /* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
+	  case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
+	  case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
+	  }
+	return "az";
+      case LANG_BASQUE:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "eu_ES";
+	  }
+	return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
+      case LANG_BELARUSIAN: return "be_BY";
+      case LANG_BENGALI:
+	switch (sub)
+	  {
+	  case SUBLANG_BENGALI_INDIA: return "bn_IN";
+	  case SUBLANG_BENGALI_BANGLADESH: return "bn_BD";
+	  }
+	return "bn";
+      case LANG_BULGARIAN: return "bg_BG";
+      case LANG_BURMESE: return "my_MM";
+      case LANG_CAMBODIAN: return "km_KH";
+      case LANG_CATALAN: return "ca_ES";
+      case LANG_CHEROKEE: return "chr_US";
+      case LANG_CHINESE:
+	switch (sub)
+	  {
+	  case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
+	  case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
+	  case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
+	  case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
+	  case SUBLANG_CHINESE_MACAU: return "zh_MO";
+	  }
+	return "zh";
+      case LANG_CROATIAN:       /* LANG_CROATIAN == LANG_SERBIAN
 				 * What used to be called Serbo-Croatian
 				 * should really now be two separate
 				 * languages because of political reasons.
@@ -513,260 +1169,332 @@ _nl_locale_name (category, categoryname)
 				 * or Croatian.)
 				 * (I can feel those flames coming already.)
 				 */
-      switch (sub)
-	{
-	case SUBLANG_DEFAULT: return "hr_HR";
-	case SUBLANG_SERBIAN_LATIN: return "sr_YU";
-	case SUBLANG_SERBIAN_CYRILLIC: return "sr_YU@cyrillic";
-	}
-      return "hr";
-    case LANG_CZECH: return "cs_CZ";
-    case LANG_DANISH: return "da_DK";
-    case LANG_DIVEHI: return "div_MV";
-    case LANG_DUTCH:
-      switch (sub)
-	{
-	case SUBLANG_DUTCH: return "nl_NL";
-	case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
-	}
-      return "nl";
-    case 0x66: /* EDO */ return "bin_NG";
-    case LANG_ENGLISH:
-      switch (sub)
-	{
-	/* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
-	 * English was the language spoken in England.
-	 * Oh well.
-	 */
-	case SUBLANG_ENGLISH_US: return "en_US";
-	case SUBLANG_ENGLISH_UK: return "en_GB";
-	case SUBLANG_ENGLISH_AUS: return "en_AU";
-	case SUBLANG_ENGLISH_CAN: return "en_CA";
-	case SUBLANG_ENGLISH_NZ: return "en_NZ";
-	case SUBLANG_ENGLISH_EIRE: return "en_IE";
-	case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
-	case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
-	case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
-	case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
-	case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
-	case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
-	case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
-	}
-      return "en";
-    case LANG_ESTONIAN: return "et_EE";
-    case LANG_FAEROESE: return "fo_FO";
-    case LANG_FARSI: return "fa_IR";
-    case LANG_FINNISH: return "fi_FI";
-    case LANG_FRENCH:
-      switch (sub)
-	{
-	case SUBLANG_FRENCH: return "fr_FR";
-	case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
-	case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
-	case SUBLANG_FRENCH_SWISS: return "fr_CH";
-	case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
-	case SUBLANG_FRENCH_MONACO: return "fr_MC";
-	}
-      return "fr";
-    case 0x62: /* FRISIAN */ return "fy_NL";
-    case 0x67: /* FULFULDE */ return "ful_NG";
-    case 0x3c: /* GAELIC */
-      switch (sub)
-	{
-	case 0x01: /* SCOTTISH */ return "gd_GB";
-	case 0x02: /* IRISH */ return "ga_IE";
-	}
-      return "C";
-    case LANG_GALICIAN: return "gl_ES";
-    case LANG_GEORGIAN: return "ka_GE";
-    case LANG_GERMAN:
-      switch (sub)
-	{
-	case SUBLANG_GERMAN: return "de_DE";
-	case SUBLANG_GERMAN_SWISS: return "de_CH";
-	case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
-	case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
-	case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
-	}
-      return "de";
-    case LANG_GREEK: return "el_GR";
-    case 0x74: /* GUARANI */ return "gn_PY";
-    case LANG_GUJARATI: return "gu_IN";
-    case 0x68: /* HAUSA */ return "ha_NG";
-    case 0x75: /* HAWAIIAN */
-      /* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
-	 or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
-      return "cpe_US";
-    case LANG_HEBREW: return "he_IL";
-    case LANG_HINDI: return "hi_IN";
-    case LANG_HUNGARIAN: return "hu_HU";
-    case 0x69: /* IBIBIO */ return "nic_NG";
-    case LANG_ICELANDIC: return "is_IS";
-    case 0x70: /* IGBO */ return "ibo_NG";
-    case LANG_INDONESIAN: return "id_ID";
-    case 0x5d: /* INUKTITUT */ return "iu_CA";
-    case LANG_ITALIAN:
-      switch (sub)
-	{
-	case SUBLANG_ITALIAN: return "it_IT";
-	case SUBLANG_ITALIAN_SWISS: return "it_CH";
-	}
-      return "it";
-    case LANG_JAPANESE: return "ja_JP";
-    case LANG_KANNADA: return "kn_IN";
-    case 0x71: /* KANURI */ return "kau_NG";
-    case LANG_KASHMIRI:
-      switch (sub)
-	{
-	case SUBLANG_DEFAULT: return "ks_PK";
-	case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
-	}
-      return "ks";
-    case LANG_KAZAK: return "kk_KZ";
-    case LANG_KONKANI:
-      /* FIXME: Adjust this when such locales appear on Unix.  */
-      return "kok_IN";
-    case LANG_KOREAN: return "ko_KR";
-    case LANG_KYRGYZ: return "ky_KG";
-    case 0x54: /* LAO */ return "lo_LA";
-    case 0x76: /* LATIN */ return "la_VA";
-    case LANG_LATVIAN: return "lv_LV";
-    case LANG_LITHUANIAN: return "lt_LT";
-    case LANG_MACEDONIAN: return "mk_MK";
-    case LANG_MALAY:
-      switch (sub)
-	{
-	case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
-	case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
-	}
-      return "ms";
-    case LANG_MALAYALAM: return "ml_IN";
-    case 0x3a: /* MALTESE */ return "mt_MT";
-    case LANG_MANIPURI:
-      /* FIXME: Adjust this when such locales appear on Unix.  */
-      return "mni_IN";
-    case LANG_MARATHI: return "mr_IN";
-    case LANG_MONGOLIAN:
-      return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
-    case LANG_NEPALI:
-      switch (sub)
-	{
-	case SUBLANG_DEFAULT: return "ne_NP";
-	case SUBLANG_NEPALI_INDIA: return "ne_IN";
-	}
-      return "ne";
-    case LANG_NORWEGIAN:
-      switch (sub)
-	{
-	case SUBLANG_NORWEGIAN_BOKMAL: return "no_NO";
-	case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
-	}
-      return "no";
-    case LANG_ORIYA: return "or_IN";
-    case 0x72: /* OROMO */ return "om_ET";
-    case 0x79: /* PAPIAMENTU */ return "pap_AN";
-    case 0x63: /* PASHTO */
-      return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
-    case LANG_POLISH: return "pl_PL";
-    case LANG_PORTUGUESE:
-      switch (sub)
-	{
-	case SUBLANG_PORTUGUESE: return "pt_PT";
-	/* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
-	   Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
-	case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
-	}
-      return "pt";
-    case LANG_PUNJABI: return "pa_IN";
-    case 0x17: /* RHAETO-ROMANCE */ return "rm_CH";
-    case LANG_ROMANIAN: return "ro_RO";
-    case LANG_RUSSIAN:
-      return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA".  */
-    case 0x3b: /* SAMI */ return "se_NO";
-    case LANG_SANSKRIT: return "sa_IN";
-    case LANG_SINDHI: return "sd";
-    case 0x5b: /* SINHALESE */ return "si_LK";
-    case LANG_SLOVAK: return "sk_SK";
-    case LANG_SLOVENIAN: return "sl_SI";
-    case 0x77: /* SOMALI */ return "so_SO";
-    case LANG_SORBIAN:
-      /* FIXME: Adjust this when such locales appear on Unix.  */
-      return "wen_DE";
-    case LANG_SPANISH:
-      switch (sub)
-	{
-	case SUBLANG_SPANISH: return "es_ES";
-	case SUBLANG_SPANISH_MEXICAN: return "es_MX";
-	case SUBLANG_SPANISH_MODERN:
-	  return "es_ES@modern";	/* not seen on Unix */
-	case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
-	case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
-	case SUBLANG_SPANISH_PANAMA: return "es_PA";
-	case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
-	case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
-	case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
-	case SUBLANG_SPANISH_PERU: return "es_PE";
-	case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
-	case SUBLANG_SPANISH_ECUADOR: return "es_EC";
-	case SUBLANG_SPANISH_CHILE: return "es_CL";
-	case SUBLANG_SPANISH_URUGUAY: return "es_UY";
-	case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
-	case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
-	case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
-	case SUBLANG_SPANISH_HONDURAS: return "es_HN";
-	case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
-	case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
-	}
-      return "es";
-    case 0x30: /* SUTU */ return "bnt_TZ";
-    case LANG_SWAHILI: return "sw_KE";
-    case LANG_SWEDISH:
-      switch (sub)
-	{
-	case SUBLANG_DEFAULT: return "sv_SE";
-	case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
-	}
-      return "sv";
-    case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
-    case 0x64: /* TAGALOG */ return "tl_PH";
-    case 0x28: /* TAJIK */ return "tg_TJ";
-    case 0x5f: /* TAMAZIGHT */ return "ber_MA";
-    case LANG_TAMIL:
-      return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
-    case LANG_TATAR: return "tt_RU";
-    case LANG_TELUGU: return "te_IN";
-    case LANG_THAI: return "th_TH";
-    case 0x51: /* TIBETAN */ return "bo_CN";
-    case 0x73: /* TIGRINYA */ return "ti_ET";
-    case 0x31: /* TSONGA */ return "ts_ZA";
-    case LANG_TURKISH: return "tr_TR";
-    case 0x42: /* TURKMEN */ return "tk_TM";
-    case LANG_UKRAINIAN: return "uk_UA";
-    case LANG_URDU:
-      switch (sub)
-	{
-	case SUBLANG_URDU_PAKISTAN: return "ur_PK";
-	case SUBLANG_URDU_INDIA: return "ur_IN";
-	}
-      return "ur";
-    case LANG_UZBEK:
-      switch (sub)
-	{
-	/* FIXME: Adjust this when Uzbek locales appear on Unix.  */
-	case SUBLANG_UZBEK_LATIN: return "uz_UZ@latin";
-	case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
-	}
-      return "uz";
-    case 0x33: /* VENDA */ return "ven_ZA";
-    case LANG_VIETNAMESE: return "vi_VN";
-    case 0x52: /* WELSH */ return "cy_GB";
-    case 0x34: /* XHOSA */ return "xh_ZA";
-    case 0x78: /* YI */ return "sit_CN";
-    case 0x3d: /* YIDDISH */ return "yi_IL";
-    case 0x6a: /* YORUBA */ return "yo_NG";
-    case 0x35: /* ZULU */ return "zu_ZA";
-    default: return "C";
-    }
-
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "hr_HR";
+	  case SUBLANG_SERBIAN_LATIN: return "sr_CS";
+	  case SUBLANG_SERBIAN_CYRILLIC: return "sr_CS@cyrillic";
+	  }
+	return "hr";
+      case LANG_CZECH: return "cs_CZ";
+      case LANG_DANISH: return "da_DK";
+      case LANG_DIVEHI: return "dv_MV";
+      case LANG_DUTCH:
+	switch (sub)
+	  {
+	  case SUBLANG_DUTCH: return "nl_NL";
+	  case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
+	  }
+	return "nl";
+      case LANG_EDO: return "bin_NG";
+      case LANG_ENGLISH:
+	switch (sub)
+	  {
+	  /* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
+	   * English was the language spoken in England.
+	   * Oh well.
+	   */
+	  case SUBLANG_ENGLISH_US: return "en_US";
+	  case SUBLANG_ENGLISH_UK: return "en_GB";
+	  case SUBLANG_ENGLISH_AUS: return "en_AU";
+	  case SUBLANG_ENGLISH_CAN: return "en_CA";
+	  case SUBLANG_ENGLISH_NZ: return "en_NZ";
+	  case SUBLANG_ENGLISH_EIRE: return "en_IE";
+	  case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
+	  case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
+	  case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
+	  case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
+	  case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
+	  case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
+	  case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
+	  case SUBLANG_ENGLISH_INDONESIA: return "en_ID";
+	  case SUBLANG_ENGLISH_HONGKONG: return "en_HK";
+	  case SUBLANG_ENGLISH_INDIA: return "en_IN";
+	  case SUBLANG_ENGLISH_MALAYSIA: return "en_MY";
+	  case SUBLANG_ENGLISH_SINGAPORE: return "en_SG";
+	  }
+	return "en";
+      case LANG_ESTONIAN: return "et_EE";
+      case LANG_FAEROESE: return "fo_FO";
+      case LANG_FARSI: return "fa_IR";
+      case LANG_FINNISH: return "fi_FI";
+      case LANG_FRENCH:
+	switch (sub)
+	  {
+	  case SUBLANG_FRENCH: return "fr_FR";
+	  case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
+	  case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
+	  case SUBLANG_FRENCH_SWISS: return "fr_CH";
+	  case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
+	  case SUBLANG_FRENCH_MONACO: return "fr_MC";
+	  case SUBLANG_FRENCH_WESTINDIES: return "fr"; /* Caribbean? */
+	  case SUBLANG_FRENCH_REUNION: return "fr_RE";
+	  case SUBLANG_FRENCH_CONGO: return "fr_CG";
+	  case SUBLANG_FRENCH_SENEGAL: return "fr_SN";
+	  case SUBLANG_FRENCH_CAMEROON: return "fr_CM";
+	  case SUBLANG_FRENCH_COTEDIVOIRE: return "fr_CI";
+	  case SUBLANG_FRENCH_MALI: return "fr_ML";
+	  case SUBLANG_FRENCH_MOROCCO: return "fr_MA";
+	  case SUBLANG_FRENCH_HAITI: return "fr_HT";
+	  }
+	return "fr";
+      case LANG_FRISIAN: return "fy_NL";
+      case LANG_FULFULDE:
+	/* Spoken in Nigeria, Guinea, Senegal, Mali, Niger, Cameroon, Benin.  */
+	return "ff_NG";
+      case LANG_GAELIC:
+	switch (sub)
+	  {
+	  case 0x01: /* SCOTTISH */ return "gd_GB";
+	  case 0x02: /* IRISH */ return "ga_IE";
+	  }
+	return "C";
+      case LANG_GALICIAN: return "gl_ES";
+      case LANG_GEORGIAN: return "ka_GE";
+      case LANG_GERMAN:
+	switch (sub)
+	  {
+	  case SUBLANG_GERMAN: return "de_DE";
+	  case SUBLANG_GERMAN_SWISS: return "de_CH";
+	  case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
+	  case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
+	  case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
+	  }
+	return "de";
+      case LANG_GREEK: return "el_GR";
+      case LANG_GUARANI: return "gn_PY";
+      case LANG_GUJARATI: return "gu_IN";
+      case LANG_HAUSA: return "ha_NG";
+      case LANG_HAWAIIAN:
+	/* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
+	   or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
+	return "cpe_US";
+      case LANG_HEBREW: return "he_IL";
+      case LANG_HINDI: return "hi_IN";
+      case LANG_HUNGARIAN: return "hu_HU";
+      case LANG_IBIBIO: return "nic_NG";
+      case LANG_ICELANDIC: return "is_IS";
+      case LANG_IGBO: return "ig_NG";
+      case LANG_INDONESIAN: return "id_ID";
+      case LANG_INUKTITUT: return "iu_CA";
+      case LANG_ITALIAN:
+	switch (sub)
+	  {
+	  case SUBLANG_ITALIAN: return "it_IT";
+	  case SUBLANG_ITALIAN_SWISS: return "it_CH";
+	  }
+	return "it";
+      case LANG_JAPANESE: return "ja_JP";
+      case LANG_KANNADA: return "kn_IN";
+      case LANG_KANURI: return "kr_NG";
+      case LANG_KASHMIRI:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "ks_PK";
+	  case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
+	  }
+	return "ks";
+      case LANG_KAZAK: return "kk_KZ";
+      case LANG_KONKANI:
+	/* FIXME: Adjust this when such locales appear on Unix.  */
+	return "kok_IN";
+      case LANG_KOREAN: return "ko_KR";
+      case LANG_KYRGYZ: return "ky_KG";
+      case LANG_LAO: return "lo_LA";
+      case LANG_LATIN: return "la_VA";
+      case LANG_LATVIAN: return "lv_LV";
+      case LANG_LITHUANIAN: return "lt_LT";
+      case LANG_MACEDONIAN: return "mk_MK";
+      case LANG_MALAY:
+	switch (sub)
+	  {
+	  case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
+	  case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
+	  }
+	return "ms";
+      case LANG_MALAYALAM: return "ml_IN";
+      case LANG_MALTESE: return "mt_MT";
+      case LANG_MANIPURI:
+	/* FIXME: Adjust this when such locales appear on Unix.  */
+	return "mni_IN";
+      case LANG_MARATHI: return "mr_IN";
+      case LANG_MONGOLIAN:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "mn_MN";
+	  }
+	return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
+      case LANG_NEPALI:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "ne_NP";
+	  case SUBLANG_NEPALI_INDIA: return "ne_IN";
+	  }
+	return "ne";
+      case LANG_NORWEGIAN:
+	switch (sub)
+	  {
+	  case SUBLANG_NORWEGIAN_BOKMAL: return "nb_NO";
+	  case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
+	  }
+	return "no";
+      case LANG_ORIYA: return "or_IN";
+      case LANG_OROMO: return "om_ET";
+      case LANG_PAPIAMENTU: return "pap_AN";
+      case LANG_PASHTO:
+	return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
+      case LANG_POLISH: return "pl_PL";
+      case LANG_PORTUGUESE:
+	switch (sub)
+	  {
+	  case SUBLANG_PORTUGUESE: return "pt_PT";
+	  /* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
+	     Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
+	  case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
+	  }
+	return "pt";
+      case LANG_PUNJABI:
+	switch (sub)
+	  {
+	  case SUBLANG_PUNJABI_INDIA: return "pa_IN"; /* Gurmukhi script */
+	  case SUBLANG_PUNJABI_PAKISTAN: return "pa_PK"; /* Arabic script */
+	  }
+	return "pa";
+      case LANG_RHAETO_ROMANCE: return "rm_CH";
+      case LANG_ROMANIAN:
+	switch (sub)
+	  {
+	  case SUBLANG_ROMANIAN_ROMANIA: return "ro_RO";
+	  case SUBLANG_ROMANIAN_MOLDOVA: return "ro_MD";
+	  }
+	return "ro";
+      case LANG_RUSSIAN:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "ru_RU";
+	  }
+	return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA" or "ru_MD".  */
+      case LANG_SAAMI: /* actually Northern Sami */ return "se_NO";
+      case LANG_SANSKRIT: return "sa_IN";
+      case LANG_SINDHI:
+	switch (sub)
+	  {
+	  case SUBLANG_SINDHI_INDIA: return "sd_IN";
+	  case SUBLANG_SINDHI_PAKISTAN: return "sd_PK";
+	  }
+	return "sd";
+      case LANG_SINHALESE: return "si_LK";
+      case LANG_SLOVAK: return "sk_SK";
+      case LANG_SLOVENIAN: return "sl_SI";
+      case LANG_SOMALI: return "so_SO";
+      case LANG_SORBIAN:
+	/* FIXME: Adjust this when such locales appear on Unix.  */
+	return "wen_DE";
+      case LANG_SPANISH:
+	switch (sub)
+	  {
+	  case SUBLANG_SPANISH: return "es_ES";
+	  case SUBLANG_SPANISH_MEXICAN: return "es_MX";
+	  case SUBLANG_SPANISH_MODERN:
+	    return "es_ES@modern";	/* not seen on Unix */
+	  case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
+	  case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
+	  case SUBLANG_SPANISH_PANAMA: return "es_PA";
+	  case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
+	  case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
+	  case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
+	  case SUBLANG_SPANISH_PERU: return "es_PE";
+	  case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
+	  case SUBLANG_SPANISH_ECUADOR: return "es_EC";
+	  case SUBLANG_SPANISH_CHILE: return "es_CL";
+	  case SUBLANG_SPANISH_URUGUAY: return "es_UY";
+	  case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
+	  case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
+	  case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
+	  case SUBLANG_SPANISH_HONDURAS: return "es_HN";
+	  case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
+	  case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
+	  }
+	return "es";
+      case LANG_SUTU: return "bnt_TZ"; /* or "st_LS" or "nso_ZA"? */
+      case LANG_SWAHILI: return "sw_KE";
+      case LANG_SWEDISH:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "sv_SE";
+	  case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
+	  }
+	return "sv";
+      case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
+      case LANG_TAGALOG: return "tl_PH";
+      case LANG_TAJIK: return "tg_TJ";
+      case LANG_TAMAZIGHT:
+	switch (sub)
+	  {
+	  /* FIXME: Adjust this when Tamazight locales appear on Unix.  */
+	  case SUBLANG_TAMAZIGHT_ARABIC: return "ber_MA@arabic";
+	  case SUBLANG_TAMAZIGHT_LATIN: return "ber_MA@latin";
+	  }
+	return "ber_MA";
+      case LANG_TAMIL:
+	switch (sub)
+	  {
+	  case SUBLANG_DEFAULT: return "ta_IN";
+	  }
+	return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
+      case LANG_TATAR: return "tt_RU";
+      case LANG_TELUGU: return "te_IN";
+      case LANG_THAI: return "th_TH";
+      case LANG_TIBETAN: return "bo_CN";
+      case LANG_TIGRINYA:
+	switch (sub)
+	  {
+	  case SUBLANG_TIGRINYA_ETHIOPIA: return "ti_ET";
+	  case SUBLANG_TIGRINYA_ERITREA: return "ti_ER";
+	  }
+	return "ti";
+      case LANG_TSONGA: return "ts_ZA";
+      case LANG_TSWANA: return "tn_BW";
+      case LANG_TURKISH: return "tr_TR";
+      case LANG_TURKMEN: return "tk_TM";
+      case LANG_UKRAINIAN: return "uk_UA";
+      case LANG_URDU:
+	switch (sub)
+	  {
+	  case SUBLANG_URDU_PAKISTAN: return "ur_PK";
+	  case SUBLANG_URDU_INDIA: return "ur_IN";
+	  }
+	return "ur";
+      case LANG_UZBEK:
+	switch (sub)
+	  {
+	  case SUBLANG_UZBEK_LATIN: return "uz_UZ";
+	  case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
+	  }
+	return "uz";
+      case LANG_VENDA: return "ve_ZA";
+      case LANG_VIETNAMESE: return "vi_VN";
+      case LANG_WELSH: return "cy_GB";
+      case LANG_XHOSA: return "xh_ZA";
+      case LANG_YI: return "sit_CN";
+      case LANG_YIDDISH: return "yi_IL";
+      case LANG_YORUBA: return "yo_NG";
+      case LANG_ZULU: return "zu_ZA";
+      default: return "C";
+      }
+  }
+# endif
 #endif
 }
+
+const char *
+_nl_locale_name (int category, const char *categoryname)
+{
+  const char *retval;
+
+  retval = _nl_locale_name_posix (category, categoryname);
+  if (retval != NULL)
+    return retval;
+
+  return _nl_locale_name_default ();
+}
diff -r 4216c218ee44 -r e04165992166 intl/log.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/log.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,98 @@
+/* Log file output.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+/* Print an ASCII string with quotes and escape sequences where needed.  */
+static void
+print_escaped (FILE *stream, const char *str)
+{
+  putc ('"', stream);
+  for (; *str != '\0'; str++)
+    if (*str == '\n')
+      {
+	fputs ("\\n\"", stream);
+	if (str[1] == '\0')
+	  return;
+	fputs ("\n\"", stream);
+      }
+    else
+      {
+	if (*str == '"' || *str == '\\')
+	  putc ('\\', stream);
+	putc (*str, stream);
+      }
+  putc ('"', stream);
+}
+
+/* Add to the log file an entry denoting a failed translation.  */
+void
+_nl_log_untranslated (const char *logfilename, const char *domainname,
+		      const char *msgid1, const char *msgid2, int plural)
+{
+  static char *last_logfilename = NULL;
+  static FILE *last_logfile = NULL;
+  FILE *logfile;
+
+  /* Can we reuse the last opened logfile?  */
+  if (last_logfilename == NULL || strcmp (logfilename, last_logfilename) != 0)
+    {
+      /* Close the last used logfile.  */
+      if (last_logfilename != NULL)
+	{
+	  if (last_logfile != NULL)
+	    {
+	      fclose (last_logfile);
+	      last_logfile = NULL;
+	    }
+	  free (last_logfilename);
+	  last_logfilename = NULL;
+	}
+      /* Open the logfile.  */
+      last_logfilename = (char *) malloc (strlen (logfilename) + 1);
+      if (last_logfilename == NULL)
+	return;
+      strcpy (last_logfilename, logfilename);
+      last_logfile = fopen (logfilename, "a");
+      if (last_logfile == NULL)
+	return;
+    }
+  logfile = last_logfile;
+
+  fprintf (logfile, "domain ");
+  print_escaped (logfile, domainname);
+  fprintf (logfile, "\nmsgid ");
+  print_escaped (logfile, msgid1);
+  if (plural)
+    {
+      fprintf (logfile, "\nmsgid_plural ");
+      print_escaped (logfile, msgid2);
+      fprintf (logfile, "\nmsgstr[0] \"\"\n");
+    }
+  else
+    fprintf (logfile, "\nmsgstr \"\"\n");
+  putc ('\n', logfile);
+}
diff -r 4216c218ee44 -r e04165992166 intl/ngettext.c
--- a/intl/ngettext.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/ngettext.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of ngettext(3) function.
-   Copyright (C) 1995, 1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995, 1997, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -44,7 +44,7 @@
    prefix.  So we have to make a difference here.  */
 #ifdef _LIBC
 # define NGETTEXT __ngettext
-# define DCNGETTEXT INTUSE(__dcngettext)
+# define DCNGETTEXT __dcngettext
 #else
 # define NGETTEXT libintl_ngettext
 # define DCNGETTEXT libintl_dcngettext
@@ -54,10 +54,7 @@
    LC_MESSAGES locale.  If not found, returns MSGID itself (the default
    text).  */
 char *
-NGETTEXT (msgid1, msgid2, n)
-     const char *msgid1;
-     const char *msgid2;
-     unsigned long int n;
+NGETTEXT (const char *msgid1, const char *msgid2, unsigned long int n)
 {
   return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
 }
diff -r 4216c218ee44 -r e04165992166 intl/plural-exp.c
--- a/intl/plural-exp.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/plural-exp.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Expression parsing for plural form selection.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 2000-2001, 2003 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
 
    This program is free software; you can redistribute it and/or modify it
@@ -96,10 +96,8 @@ init_germanic_plural ()
 
 void
 internal_function
-EXTRACT_PLURAL_EXPRESSION (nullentry, pluralp, npluralsp)
-     const char *nullentry;
-     struct expression **pluralp;
-     unsigned long int *npluralsp;
+EXTRACT_PLURAL_EXPRESSION (const char *nullentry, struct expression **pluralp,
+			   unsigned long int *npluralsp)
 {
   if (nullentry != NULL)
     {
diff -r 4216c218ee44 -r e04165992166 intl/plural-exp.h
--- a/intl/plural-exp.h	Sat May 28 13:40:15 2005 +0000
+++ b/intl/plural-exp.h	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Expression parsing and evaluation for plural form selection.
-   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 2000-2003 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
 
    This program is free software; you can redistribute it and/or modify it
@@ -19,14 +19,6 @@
 
 #ifndef _PLURAL_EXP_H
 #define _PLURAL_EXP_H
-
-#ifndef PARAMS
-# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
-#  define PARAMS(args) args
-# else
-#  define PARAMS(args) ()
-# endif
-#endif
 
 #ifndef internal_function
 # define internal_function
@@ -109,18 +101,18 @@ struct parse_args
 # define EXTRACT_PLURAL_EXPRESSION extract_plural_expression
 #endif
 
-extern void FREE_EXPRESSION PARAMS ((struct expression *exp))
+extern void FREE_EXPRESSION (struct expression *exp)
      internal_function;
-extern int PLURAL_PARSE PARAMS ((void *arg));
+extern int PLURAL_PARSE (void *arg);
 extern struct expression GERMANIC_PLURAL attribute_hidden;
-extern void EXTRACT_PLURAL_EXPRESSION PARAMS ((const char *nullentry,
-					       struct expression **pluralp,
-					       unsigned long int *npluralsp))
+extern void EXTRACT_PLURAL_EXPRESSION (const char *nullentry,
+				       struct expression **pluralp,
+				       unsigned long int *npluralsp)
      internal_function;
 
 #if !defined (_LIBC) && !defined (IN_LIBINTL)
-extern unsigned long int plural_eval PARAMS ((struct expression *pexp,
-					      unsigned long int n));
+extern unsigned long int plural_eval (struct expression *pexp,
+				      unsigned long int n);
 #endif
 
 #endif /* _PLURAL_EXP_H */
diff -r 4216c218ee44 -r e04165992166 intl/plural.c
--- a/intl/plural.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/plural.c	Sat May 28 13:45:22 2005 +0000
@@ -1,6 +1,5 @@
-
-/*  A Bison parser, made from plural.y
-    by GNU Bison version 1.28  */
+/* A Bison parser, made from plural.y
+   by GNU bison 1.35.  */
 
 #define YYBISON 1  /* Identify Bison output.  */
 
@@ -11,16 +10,16 @@
 #define yychar __gettextchar
 #define yydebug __gettextdebug
 #define yynerrs __gettextnerrs
-#define	EQUOP2	257
-#define	CMPOP2	258
-#define	ADDOP2	259
-#define	MULOP2	260
-#define	NUMBER	261
+# define	EQUOP2	257
+# define	CMPOP2	258
+# define	ADDOP2	259
+# define	MULOP2	260
+# define	NUMBER	261
 
 #line 1 "plural.y"
 
 /* Expression parsing for plural form selection.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 2000-2001, 2003 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
 
    This program is free software; you can redistribute it and/or modify it
@@ -64,36 +63,25 @@
 #define YYPARSE_PARAM	arg
 
 #line 49 "plural.y"
+#ifndef YYSTYPE
 typedef union {
   unsigned long int num;
   enum operator op;
   struct expression *exp;
-} YYSTYPE;
+} yystype;
+# define YYSTYPE yystype
+# define YYSTYPE_IS_TRIVIAL 1
+#endif
 #line 55 "plural.y"
 
 /* Prototypes for local functions.  */
-static struct expression *new_exp PARAMS ((int nargs, enum operator op,
-					   struct expression * const *args));
-static inline struct expression *new_exp_0 PARAMS ((enum operator op));
-static inline struct expression *new_exp_1 PARAMS ((enum operator op,
-						   struct expression *right));
-static struct expression *new_exp_2 PARAMS ((enum operator op,
-					     struct expression *left,
-					     struct expression *right));
-static inline struct expression *new_exp_3 PARAMS ((enum operator op,
-						   struct expression *bexp,
-						   struct expression *tbranch,
-						   struct expression *fbranch));
-static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
-static void yyerror PARAMS ((const char *str));
+static int yylex (YYSTYPE *lval, const char **pexp);
+static void yyerror (const char *str);
 
 /* Allocation of expressions.  */
 
 static struct expression *
-new_exp (nargs, op, args)
-     int nargs;
-     enum operator op;
-     struct expression * const *args;
+new_exp (int nargs, enum operator op, struct expression * const *args)
 {
   int i;
   struct expression *newp;
@@ -122,16 +110,13 @@ new_exp (nargs, op, args)
 }
 
 static inline struct expression *
-new_exp_0 (op)
-     enum operator op;
+new_exp_0 (enum operator op)
 {
   return new_exp (0, op, NULL);
 }
 
 static inline struct expression *
-new_exp_1 (op, right)
-     enum operator op;
-     struct expression *right;
+new_exp_1 (enum operator op, struct expression *right)
 {
   struct expression *args[1];
 
@@ -140,10 +125,7 @@ new_exp_1 (op, right)
 }
 
 static struct expression *
-new_exp_2 (op, left, right)
-     enum operator op;
-     struct expression *left;
-     struct expression *right;
+new_exp_2 (enum operator op, struct expression *left, struct expression *right)
 {
   struct expression *args[2];
 
@@ -153,11 +135,8 @@ new_exp_2 (op, left, right)
 }
 
 static inline struct expression *
-new_exp_3 (op, bexp, tbranch, fbranch)
-     enum operator op;
-     struct expression *bexp;
-     struct expression *tbranch;
-     struct expression *fbranch;
+new_exp_3 (enum operator op, struct expression *bexp,
+	   struct expression *tbranch, struct expression *fbranch)
 {
   struct expression *args[3];
 
@@ -167,12 +146,8 @@ new_exp_3 (op, bexp, tbranch, fbranch)
   return new_exp (3, op, args);
 }
 
-#include <stdio.h>
-
-#ifndef __cplusplus
-#ifndef __STDC__
-#define const
-#endif
+#ifndef YYDEBUG
+# define YYDEBUG 0
 #endif
 
 
@@ -181,129 +156,152 @@ new_exp_3 (op, bexp, tbranch, fbranch)
 #define	YYFLAG		-32768
 #define	YYNTBASE	16
 
+/* YYTRANSLATE(YYLEX) -- Bison token number corresponding to YYLEX. */
 #define YYTRANSLATE(x) ((unsigned)(x) <= 261 ? yytranslate[x] : 18)
 
-static const char yytranslate[] = {     0,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,    10,     2,     2,     2,     2,     5,     2,    14,
-    15,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,    12,     2,     2,
-     2,     2,     3,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,    13,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     4,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-     2,     2,     2,     2,     2,     1,     6,     7,     8,     9,
-    11
+/* YYTRANSLATE[YYLEX] -- Bison token number corresponding to YYLEX. */
+static const char yytranslate[] =
+{
+       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,    10,     2,     2,     2,     2,     5,     2,
+      14,    15,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,    12,     2,
+       2,     2,     2,     3,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+      13,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     4,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+       2,     2,     2,     2,     2,     2,     1,     6,     7,     8,
+       9,    11
 };
 
-#if YYDEBUG != 0
-static const short yyprhs[] = {     0,
-     0,     2,     8,    12,    16,    20,    24,    28,    32,    35,
-    37,    39
+#if YYDEBUG
+static const short yyprhs[] =
+{
+       0,     0,     2,     8,    12,    16,    20,    24,    28,    32,
+      35,    37,    39
 };
-
-static const short yyrhs[] = {    17,
-     0,    17,     3,    17,    12,    17,     0,    17,     4,    17,
-     0,    17,     5,    17,     0,    17,     6,    17,     0,    17,
-     7,    17,     0,    17,     8,    17,     0,    17,     9,    17,
-     0,    10,    17,     0,    13,     0,    11,     0,    14,    17,
-    15,     0
+static const short yyrhs[] =
+{
+      17,     0,    17,     3,    17,    12,    17,     0,    17,     4,
+      17,     0,    17,     5,    17,     0,    17,     6,    17,     0,
+      17,     7,    17,     0,    17,     8,    17,     0,    17,     9,
+      17,     0,    10,    17,     0,    13,     0,    11,     0,    14,
+      17,    15,     0
 };
 
 #endif
 
-#if YYDEBUG != 0
-static const short yyrline[] = { 0,
-   174,   182,   186,   190,   194,   198,   202,   206,   210,   214,
-   218,   223
+#if YYDEBUG
+/* YYRLINE[YYN] -- source line where rule number YYN was defined. */
+static const short yyrline[] =
+{
+       0,   150,   158,   162,   166,   170,   174,   178,   182,   186,
+     190,   194,   199
 };
 #endif
 
 
-#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
-
-static const char * const yytname[] = {   "$","error","$undefined.","'?'","'|'",
-"'&'","EQUOP2","CMPOP2","ADDOP2","MULOP2","'!'","NUMBER","':'","'n'","'('","')'",
-"start","exp", NULL
+#if (YYDEBUG) || defined YYERROR_VERBOSE
+
+/* YYTNAME[TOKEN_NUM] -- String name of the token TOKEN_NUM. */
+static const char *const yytname[] =
+{
+  "$", "error", "$undefined.", "'?'", "'|'", "'&'", "EQUOP2", "CMPOP2", 
+  "ADDOP2", "MULOP2", "'!'", "NUMBER", "':'", "'n'", "'('", "')'", 
+  "start", "exp", 0
 };
 #endif
 
-static const short yyr1[] = {     0,
-    16,    17,    17,    17,    17,    17,    17,    17,    17,    17,
-    17,    17
+/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives. */
+static const short yyr1[] =
+{
+       0,    16,    17,    17,    17,    17,    17,    17,    17,    17,
+      17,    17,    17
 };
 
-static const short yyr2[] = {     0,
-     1,     5,     3,     3,     3,     3,     3,     3,     2,     1,
-     1,     3
+/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN. */
+static const short yyr2[] =
+{
+       0,     1,     5,     3,     3,     3,     3,     3,     3,     2,
+       1,     1,     3
 };
 
-static const short yydefact[] = {     0,
-     0,    11,    10,     0,     1,     9,     0,     0,     0,     0,
-     0,     0,     0,     0,    12,     0,     3,     4,     5,     6,
-     7,     8,     0,     2,     0,     0,     0
+/* YYDEFACT[S] -- default rule to reduce with in state S when YYTABLE
+   doesn't specify something else to do.  Zero means the default is an
+   error. */
+static const short yydefact[] =
+{
+       0,     0,    11,    10,     0,     1,     9,     0,     0,     0,
+       0,     0,     0,     0,     0,    12,     0,     3,     4,     5,
+       6,     7,     8,     0,     2,     0,     0,     0
 };
 
-static const short yydefgoto[] = {    25,
-     5
+static const short yydefgoto[] =
+{
+      25,     5
 };
 
-static const short yypact[] = {    -9,
-    -9,-32768,-32768,    -9,    34,-32768,    11,    -9,    -9,    -9,
-    -9,    -9,    -9,    -9,-32768,    24,    39,    43,    16,    26,
-    -3,-32768,    -9,    34,    21,    53,-32768
+static const short yypact[] =
+{
+      -9,    -9,-32768,-32768,    -9,    34,-32768,    11,    -9,    -9,
+      -9,    -9,    -9,    -9,    -9,-32768,    24,    39,    43,    16,
+      26,    -3,-32768,    -9,    34,    21,    53,-32768
 };
 
-static const short yypgoto[] = {-32768,
-    -1
+static const short yypgoto[] =
+{
+  -32768,    -1
 };
 
 
 #define	YYLAST		53
 
 
-static const short yytable[] = {     6,
-     1,     2,     7,     3,     4,    14,    16,    17,    18,    19,
-    20,    21,    22,     8,     9,    10,    11,    12,    13,    14,
-    26,    24,    12,    13,    14,    15,     8,     9,    10,    11,
-    12,    13,    14,    13,    14,    23,     8,     9,    10,    11,
-    12,    13,    14,    10,    11,    12,    13,    14,    11,    12,
-    13,    14,    27
+static const short yytable[] =
+{
+       6,     1,     2,     7,     3,     4,    14,    16,    17,    18,
+      19,    20,    21,    22,     8,     9,    10,    11,    12,    13,
+      14,    26,    24,    12,    13,    14,    15,     8,     9,    10,
+      11,    12,    13,    14,    13,    14,    23,     8,     9,    10,
+      11,    12,    13,    14,    10,    11,    12,    13,    14,    11,
+      12,    13,    14,    27
 };
 
-static const short yycheck[] = {     1,
-    10,    11,     4,    13,    14,     9,     8,     9,    10,    11,
-    12,    13,    14,     3,     4,     5,     6,     7,     8,     9,
-     0,    23,     7,     8,     9,    15,     3,     4,     5,     6,
-     7,     8,     9,     8,     9,    12,     3,     4,     5,     6,
-     7,     8,     9,     5,     6,     7,     8,     9,     6,     7,
-     8,     9,     0
+static const short yycheck[] =
+{
+       1,    10,    11,     4,    13,    14,     9,     8,     9,    10,
+      11,    12,    13,    14,     3,     4,     5,     6,     7,     8,
+       9,     0,    23,     7,     8,     9,    15,     3,     4,     5,
+       6,     7,     8,     9,     8,     9,    12,     3,     4,     5,
+       6,     7,     8,     9,     5,     6,     7,     8,     9,     6,
+       7,     8,     9,     0
 };
 #define YYPURE 1
 
 /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
-#line 3 "/usr/local/share/bison.simple"
-/* This file comes from bison-1.28.  */
+#line 3 "/usr/local/share/bison/bison.simple"
 
 /* Skeleton output parser for bison,
-   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002 Free Software
+   Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -325,62 +323,131 @@ static const short yycheck[] = {     1,
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-/* This is the parser code that is written into each bison parser
-  when the %semantic_parser declaration is not specified in the grammar.
-  It was written by Richard Stallman by simplifying the hairy parser
-  used when %semantic_parser is specified.  */
-
-#ifndef YYSTACK_USE_ALLOCA
-#ifdef alloca
-#define YYSTACK_USE_ALLOCA
-#else /* alloca not defined */
-#ifdef __GNUC__
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#else /* not GNU C.  */
-#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
-#define YYSTACK_USE_ALLOCA
-#include <alloca.h>
-#else /* not sparc */
-/* We think this test detects Watcom and Microsoft C.  */
-/* This used to test MSDOS, but that is a bad idea
-   since that symbol is in the user namespace.  */
-#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
-#if 0 /* No need for malloc.h, which pollutes the namespace;
-	 instead, just don't use alloca.  */
-#include <malloc.h>
-#endif
-#else /* not MSDOS, or __TURBOC__ */
-#if defined(_AIX)
-/* I don't know what this was needed for, but it pollutes the namespace.
-   So I turned it off.   rms, 2 May 1997.  */
-/* #include <malloc.h>  */
- #pragma alloca
-#define YYSTACK_USE_ALLOCA
-#else /* not MSDOS, or __TURBOC__, or _AIX */
-#if 0
-#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
-		 and on HPUX 10.  Eventually we can turn this on.  */
-#define YYSTACK_USE_ALLOCA
-#define alloca __builtin_alloca
-#endif /* __hpux */
-#endif
-#endif /* not _AIX */
-#endif /* not MSDOS, or __TURBOC__ */
-#endif /* not sparc */
-#endif /* not GNU C */
-#endif /* alloca not defined */
-#endif /* YYSTACK_USE_ALLOCA not defined */
-
-#ifdef YYSTACK_USE_ALLOCA
-#define YYSTACK_ALLOC alloca
-#else
-#define YYSTACK_ALLOC malloc
-#endif
-
-/* Note: there must be only one dollar sign in this file.
-   It is replaced by the list of actions, each action
-   as one case of the switch.  */
+/* This is the parser code that is written into each bison parser when
+   the %semantic_parser declaration is not specified in the grammar.
+   It was written by Richard Stallman by simplifying the hairy parser
+   used when %semantic_parser is specified.  */
+
+/* All symbols defined below should begin with yy or YY, to avoid
+   infringing on user name space.  This should be done even for local
+   variables, as they might otherwise be expanded by user macros.
+   There are some unavoidable exceptions within include files to
+   define necessary library symbols; they are noted "INFRINGES ON
+   USER NAME SPACE" below.  */
+
+#if ! defined (yyoverflow) || defined (YYERROR_VERBOSE)
+
+/* The parser invokes alloca or malloc; define the necessary symbols.  */
+
+# if YYSTACK_USE_ALLOCA
+#  define YYSTACK_ALLOC alloca
+# else
+#  ifndef YYSTACK_USE_ALLOCA
+#   if defined (alloca) || defined (_ALLOCA_H)
+#    define YYSTACK_ALLOC alloca
+#   else
+#    ifdef __GNUC__
+#     define YYSTACK_ALLOC __builtin_alloca
+#    endif
+#   endif
+#  endif
+# endif
+
+# ifdef YYSTACK_ALLOC
+   /* Pacify GCC's `empty if-body' warning. */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+# else
+#  if defined (__STDC__) || defined (__cplusplus)
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   define YYSIZE_T size_t
+#  endif
+#  define YYSTACK_ALLOC malloc
+#  define YYSTACK_FREE free
+# endif
+#endif /* ! defined (yyoverflow) || defined (YYERROR_VERBOSE) */
+
+
+#if (! defined (yyoverflow) \
+     && (! defined (__cplusplus) \
+	 || (YYLTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
+
+/* A type that is properly aligned for any stack member.  */
+union yyalloc
+{
+  short yyss;
+  YYSTYPE yyvs;
+# if YYLSP_NEEDED
+  YYLTYPE yyls;
+# endif
+};
+
+/* The size of the maximum gap between one aligned stack and the next.  */
+# define YYSTACK_GAP_MAX (sizeof (union yyalloc) - 1)
+
+/* The size of an array large to enough to hold all stacks, each with
+   N elements.  */
+# if YYLSP_NEEDED
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+      + 2 * YYSTACK_GAP_MAX)
+# else
+#  define YYSTACK_BYTES(N) \
+     ((N) * (sizeof (short) + sizeof (YYSTYPE))				\
+      + YYSTACK_GAP_MAX)
+# endif
+
+/* Copy COUNT objects from FROM to TO.  The source and destination do
+   not overlap.  */
+# ifndef YYCOPY
+#  if 1 < __GNUC__
+#   define YYCOPY(To, From, Count) \
+      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
+#  else
+#   define YYCOPY(To, From, Count)		\
+      do					\
+	{					\
+	  register YYSIZE_T yyi;		\
+	  for (yyi = 0; yyi < (Count); yyi++)	\
+	    (To)[yyi] = (From)[yyi];		\
+	}					\
+      while (0)
+#  endif
+# endif
+
+/* Relocate STACK from its old location to the new one.  The
+   local variables YYSIZE and YYSTACKSIZE give the old and new number of
+   elements in the stack, and YYPTR gives the new location of the
+   stack.  Advance YYPTR to a properly aligned location for the next
+   stack.  */
+# define YYSTACK_RELOCATE(Stack)					\
+    do									\
+      {									\
+	YYSIZE_T yynewbytes;						\
+	YYCOPY (&yyptr->Stack, Stack, yysize);				\
+	Stack = &yyptr->Stack;						\
+	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAX;	\
+	yyptr += yynewbytes / sizeof (*yyptr);				\
+      }									\
+    while (0)
+
+#endif
+
+
+#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
+# define YYSIZE_T __SIZE_TYPE__
+#endif
+#if ! defined (YYSIZE_T) && defined (size_t)
+# define YYSIZE_T size_t
+#endif
+#if ! defined (YYSIZE_T)
+# if defined (__STDC__) || defined (__cplusplus)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# endif
+#endif
+#if ! defined (YYSIZE_T)
+# define YYSIZE_T unsigned int
+#endif
 
 #define yyerrok		(yyerrstatus = 0)
 #define yyclearin	(yychar = YYEMPTY)
@@ -389,131 +456,161 @@ static const short yycheck[] = {     1,
 #define YYACCEPT	goto yyacceptlab
 #define YYABORT 	goto yyabortlab
 #define YYERROR		goto yyerrlab1
-/* Like YYERROR except do call yyerror.
-   This remains here temporarily to ease the
-   transition to the new meaning of YYERROR, for GCC.
+/* Like YYERROR except do call yyerror.  This remains here temporarily
+   to ease the transition to the new meaning of YYERROR, for GCC.
    Once GCC version 2 has supplanted version 1, this can go.  */
 #define YYFAIL		goto yyerrlab
 #define YYRECOVERING()  (!!yyerrstatus)
-#define YYBACKUP(token, value) \
+#define YYBACKUP(Token, Value)					\
 do								\
   if (yychar == YYEMPTY && yylen == 1)				\
-    { yychar = (token), yylval = (value);			\
+    {								\
+      yychar = (Token);						\
+      yylval = (Value);						\
       yychar1 = YYTRANSLATE (yychar);				\
       YYPOPSTACK;						\
       goto yybackup;						\
     }								\
   else								\
-    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+    { 								\
+      yyerror ("syntax error: cannot back up");			\
+      YYERROR;							\
+    }								\
 while (0)
 
 #define YYTERROR	1
 #define YYERRCODE	256
 
-#ifndef YYPURE
-#define YYLEX		yylex()
-#endif
-
-#ifdef YYPURE
-#ifdef YYLSP_NEEDED
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval, &yylloc)
-#endif
-#else /* not YYLSP_NEEDED */
-#ifdef YYLEX_PARAM
-#define YYLEX		yylex(&yylval, YYLEX_PARAM)
-#else
-#define YYLEX		yylex(&yylval)
-#endif
-#endif /* not YYLSP_NEEDED */
-#endif
-
-/* If nonreentrant, generate the variables here */
-
-#ifndef YYPURE
-
-int	yychar;			/*  the lookahead symbol		*/
-YYSTYPE	yylval;			/*  the semantic value of the		*/
-				/*  lookahead symbol			*/
-
-#ifdef YYLSP_NEEDED
-YYLTYPE yylloc;			/*  location data for the lookahead	*/
-				/*  symbol				*/
-#endif
-
-int yynerrs;			/*  number of parse errors so far       */
-#endif  /* not YYPURE */
-
-#if YYDEBUG != 0
-int yydebug;			/*  nonzero means print parse trace	*/
-/* Since this is uninitialized, it does not stop multiple parsers
-   from coexisting.  */
-#endif
-
-/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
-
+
+/* YYLLOC_DEFAULT -- Compute the default location (before the actions
+   are run).
+
+   When YYLLOC_DEFAULT is run, CURRENT is set the location of the
+   first token.  By default, to implement support for ranges, extend
+   its range to the last symbol.  */
+
+#ifndef YYLLOC_DEFAULT
+# define YYLLOC_DEFAULT(Current, Rhs, N)       	\
+   Current.last_line   = Rhs[N].last_line;	\
+   Current.last_column = Rhs[N].last_column;
+#endif
+
+
+/* YYLEX -- calling `yylex' with the right arguments.  */
+
+#if YYPURE
+# if YYLSP_NEEDED
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, &yylloc, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval, &yylloc)
+#  endif
+# else /* !YYLSP_NEEDED */
+#  ifdef YYLEX_PARAM
+#   define YYLEX		yylex (&yylval, YYLEX_PARAM)
+#  else
+#   define YYLEX		yylex (&yylval)
+#  endif
+# endif /* !YYLSP_NEEDED */
+#else /* !YYPURE */
+# define YYLEX			yylex ()
+#endif /* !YYPURE */
+
+
+/* Enable debugging if requested.  */
+#if YYDEBUG
+
+# ifndef YYFPRINTF
+#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYFPRINTF fprintf
+# endif
+
+# define YYDPRINTF(Args)			\
+do {						\
+  if (yydebug)					\
+    YYFPRINTF Args;				\
+} while (0)
+/* Nonzero means print parse trace.  It is left uninitialized so that
+   multiple parsers can coexist.  */
+int yydebug;
+#else /* !YYDEBUG */
+# define YYDPRINTF(Args)
+#endif /* !YYDEBUG */
+
+/* YYINITDEPTH -- initial size of the parser's stacks.  */
 #ifndef	YYINITDEPTH
-#define YYINITDEPTH 200
-#endif
-
-/*  YYMAXDEPTH is the maximum size the stacks can grow to
-    (effective only if the built-in stack extension method is used).  */
+# define YYINITDEPTH 200
+#endif
+
+/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
+   if the built-in stack extension method is used).
+
+   Do not make this value too large; the results are undefined if
+   SIZE_MAX < YYSTACK_BYTES (YYMAXDEPTH)
+   evaluated with infinite-precision integer arithmetic.  */
 
 #if YYMAXDEPTH == 0
-#undef YYMAXDEPTH
+# undef YYMAXDEPTH
 #endif
 
 #ifndef YYMAXDEPTH
-#define YYMAXDEPTH 10000
+# define YYMAXDEPTH 10000
 #endif
 
-/* Define __yy_memcpy.  Note that the size argument
-   should be passed with type unsigned int, because that is what the non-GCC
-   definitions require.  With GCC, __builtin_memcpy takes an arg
-   of type size_t, but it can handle unsigned int.  */
-
-#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
-#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
-#else				/* not GNU C or C++ */
-#ifndef __cplusplus
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (to, from, count)
-     char *to;
-     char *from;
-     unsigned int count;
-{
-  register char *f = from;
-  register char *t = to;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
+#ifdef YYERROR_VERBOSE
+
+# ifndef yystrlen
+#  if defined (__GLIBC__) && defined (_STRING_H)
+#   define yystrlen strlen
+#  else
+/* Return the length of YYSTR.  */
+static YYSIZE_T
+#   if defined (__STDC__) || defined (__cplusplus)
+yystrlen (const char *yystr)
+#   else
+yystrlen (yystr)
+     const char *yystr;
+#   endif
+{
+  register const char *yys = yystr;
+
+  while (*yys++ != '\0')
+    continue;
+
+  return yys - yystr - 1;
 }
-
-#else /* __cplusplus */
-
-/* This is the most reliable way to avoid incompatibilities
-   in available built-in functions on various systems.  */
-static void
-__yy_memcpy (char *to, char *from, unsigned int count)
-{
-  register char *t = to;
-  register char *f = from;
-  register int i = count;
-
-  while (i-- > 0)
-    *t++ = *f++;
+#  endif
+# endif
+
+# ifndef yystpcpy
+#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#   define yystpcpy stpcpy
+#  else
+/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
+   YYDEST.  */
+static char *
+#   if defined (__STDC__) || defined (__cplusplus)
+yystpcpy (char *yydest, const char *yysrc)
+#   else
+yystpcpy (yydest, yysrc)
+     char *yydest;
+     const char *yysrc;
+#   endif
+{
+  register char *yyd = yydest;
+  register const char *yys = yysrc;
+
+  while ((*yyd++ = *yys++) != '\0')
+    continue;
+
+  return yyd - 1;
 }
-
-#endif
+#  endif
+# endif
 #endif
 
-#line 217 "/usr/local/share/bison.simple"
+#line 315 "/usr/local/share/bison/bison.simple"
+
 
 /* The user can define YYPARSE_PARAM as the name of an argument to be passed
    into yyparse.  The argument should have type void *.
@@ -522,76 +619,121 @@ __yy_memcpy (char *to, char *from, unsig
    to the proper pointer type.  */
 
 #ifdef YYPARSE_PARAM
-#ifdef __cplusplus
-#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL
-#else /* not __cplusplus */
-#define YYPARSE_PARAM_ARG YYPARSE_PARAM
-#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
-#endif /* not __cplusplus */
-#else /* not YYPARSE_PARAM */
-#define YYPARSE_PARAM_ARG
-#define YYPARSE_PARAM_DECL
-#endif /* not YYPARSE_PARAM */
+# if defined (__STDC__) || defined (__cplusplus)
+#  define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL
+# else
+#  define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#  define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+# endif
+#else /* !YYPARSE_PARAM */
+# define YYPARSE_PARAM_ARG
+# define YYPARSE_PARAM_DECL
+#endif /* !YYPARSE_PARAM */
 
 /* Prevent warning if -Wstrict-prototypes.  */
 #ifdef __GNUC__
-#ifdef YYPARSE_PARAM
+# ifdef YYPARSE_PARAM
 int yyparse (void *);
+# else
+int yyparse (void);
+# endif
+#endif
+
+/* YY_DECL_VARIABLES -- depending whether we use a pure parser,
+   variables are global, or local to YYPARSE.  */
+
+#define YY_DECL_NON_LSP_VARIABLES			\
+/* The lookahead symbol.  */				\
+int yychar;						\
+							\
+/* The semantic value of the lookahead symbol. */	\
+YYSTYPE yylval;						\
+							\
+/* Number of parse errors so far.  */			\
+int yynerrs;
+
+#if YYLSP_NEEDED
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES			\
+						\
+/* Location data for the lookahead symbol.  */	\
+YYLTYPE yylloc;
 #else
-int yyparse (void);
-#endif
-#endif
+# define YY_DECL_VARIABLES			\
+YY_DECL_NON_LSP_VARIABLES
+#endif
+
+
+/* If nonreentrant, generate the variables here. */
+
+#if !YYPURE
+YY_DECL_VARIABLES
+#endif  /* !YYPURE */
 
 int
-yyparse(YYPARSE_PARAM_ARG)
+yyparse (YYPARSE_PARAM_ARG)
      YYPARSE_PARAM_DECL
 {
+  /* If reentrant, generate the variables here. */
+#if YYPURE
+  YY_DECL_VARIABLES
+#endif  /* !YYPURE */
+
   register int yystate;
   register int yyn;
+  int yyresult;
+  /* Number of tokens to shift before error messages enabled.  */
+  int yyerrstatus;
+  /* Lookahead token as an internal (translated) token number.  */
+  int yychar1 = 0;
+
+  /* Three stacks and their tools:
+     `yyss': related to states,
+     `yyvs': related to semantic values,
+     `yyls': related to locations.
+
+     Refer to the stacks thru separate pointers, to allow yyoverflow
+     to reallocate them elsewhere.  */
+
+  /* The state stack. */
+  short	yyssa[YYINITDEPTH];
+  short *yyss = yyssa;
   register short *yyssp;
+
+  /* The semantic value stack.  */
+  YYSTYPE yyvsa[YYINITDEPTH];
+  YYSTYPE *yyvs = yyvsa;
   register YYSTYPE *yyvsp;
-  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
-  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
-
-  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
-  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
-
-  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
-  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
-
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+
+#if YYLSP_NEEDED
+  /* The location stack.  */
+  YYLTYPE yylsa[YYINITDEPTH];
   YYLTYPE *yyls = yylsa;
   YYLTYPE *yylsp;
-
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#endif
+
+#if YYLSP_NEEDED
+# define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
 #else
-#define YYPOPSTACK   (yyvsp--, yyssp--)
-#endif
-
-  int yystacksize = YYINITDEPTH;
-  int yyfree_stacks = 0;
-
-#ifdef YYPURE
-  int yychar;
-  YYSTYPE yylval;
-  int yynerrs;
-#ifdef YYLSP_NEEDED
-  YYLTYPE yylloc;
-#endif
-#endif
-
-  YYSTYPE yyval;		/*  the variable used to return		*/
-				/*  semantic values from the action	*/
-				/*  routines				*/
-
+# define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  YYSIZE_T yystacksize = YYINITDEPTH;
+
+
+  /* The variables used to return semantic value and location from the
+     action routines.  */
+  YYSTYPE yyval;
+#if YYLSP_NEEDED
+  YYLTYPE yyloc;
+#endif
+
+  /* When reducing, the number of symbols on the RHS of the reduced
+     rule. */
   int yylen;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Starting parse\n");
-#endif
+  YYDPRINTF ((stderr, "Starting parse\n"));
 
   yystate = 0;
   yyerrstatus = 0;
@@ -603,110 +745,110 @@ yyparse(YYPARSE_PARAM_ARG)
      so that they stay on the same level as the state stack.
      The wasted elements are never initialized.  */
 
-  yyssp = yyss - 1;
+  yyssp = yyss;
   yyvsp = yyvs;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp = yyls;
 #endif
-
-/* Push a new state, which is found in  yystate  .  */
-/* In all cases, when you get here, the value and location stacks
-   have just been pushed. so pushing a state here evens the stacks.  */
-yynewstate:
-
-  *++yyssp = yystate;
+  goto yysetstate;
+
+/*------------------------------------------------------------.
+| yynewstate -- Push a new state, which is found in yystate.  |
+`------------------------------------------------------------*/
+ yynewstate:
+  /* In all cases, when you get here, the value and location stacks
+     have just been pushed. so pushing a state here evens the stacks.
+     */
+  yyssp++;
+
+ yysetstate:
+  *yyssp = yystate;
 
   if (yyssp >= yyss + yystacksize - 1)
     {
-      /* Give user a chance to reallocate the stack */
-      /* Use copies of these so that the &'s don't force the real ones into memory. */
-      YYSTYPE *yyvs1 = yyvs;
-      short *yyss1 = yyss;
-#ifdef YYLSP_NEEDED
-      YYLTYPE *yyls1 = yyls;
-#endif
-
       /* Get the current used size of the three stacks, in elements.  */
-      int size = yyssp - yyss + 1;
+      YYSIZE_T yysize = yyssp - yyss + 1;
 
 #ifdef yyoverflow
-      /* Each stack pointer address is followed by the size of
-	 the data in use in that stack, in bytes.  */
-#ifdef YYLSP_NEEDED
-      /* This used to be a conditional around just the two extra args,
-	 but that might be undefined if yyoverflow is a macro.  */
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yyls1, size * sizeof (*yylsp),
-		 &yystacksize);
-#else
-      yyoverflow("parser stack overflow",
-		 &yyss1, size * sizeof (*yyssp),
-		 &yyvs1, size * sizeof (*yyvsp),
-		 &yystacksize);
-#endif
-
-      yyss = yyss1; yyvs = yyvs1;
-#ifdef YYLSP_NEEDED
-      yyls = yyls1;
-#endif
+      {
+	/* Give user a chance to reallocate the stack. Use copies of
+	   these so that the &'s don't force the real ones into
+	   memory.  */
+	YYSTYPE *yyvs1 = yyvs;
+	short *yyss1 = yyss;
+
+	/* Each stack pointer address is followed by the size of the
+	   data in use in that stack, in bytes.  */
+# if YYLSP_NEEDED
+	YYLTYPE *yyls1 = yyls;
+	/* This used to be a conditional around just the two extra args,
+	   but that might be undefined if yyoverflow is a macro.  */
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yyls1, yysize * sizeof (*yylsp),
+		    &yystacksize);
+	yyls = yyls1;
+# else
+	yyoverflow ("parser stack overflow",
+		    &yyss1, yysize * sizeof (*yyssp),
+		    &yyvs1, yysize * sizeof (*yyvsp),
+		    &yystacksize);
+# endif
+	yyss = yyss1;
+	yyvs = yyvs1;
+      }
 #else /* no yyoverflow */
+# ifndef YYSTACK_RELOCATE
+      goto yyoverflowlab;
+# else
       /* Extend the stack our own way.  */
       if (yystacksize >= YYMAXDEPTH)
-	{
-	  yyerror("parser stack overflow");
-	  if (yyfree_stacks)
-	    {
-	      free (yyss);
-	      free (yyvs);
-#ifdef YYLSP_NEEDED
-	      free (yyls);
-#endif
-	    }
-	  return 2;
-	}
+	goto yyoverflowlab;
       yystacksize *= 2;
       if (yystacksize > YYMAXDEPTH)
 	yystacksize = YYMAXDEPTH;
-#ifndef YYSTACK_USE_ALLOCA
-      yyfree_stacks = 1;
-#endif
-      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
-      __yy_memcpy ((char *)yyss, (char *)yyss1,
-		   size * (unsigned int) sizeof (*yyssp));
-      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
-      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
-		   size * (unsigned int) sizeof (*yyvsp));
-#ifdef YYLSP_NEEDED
-      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
-      __yy_memcpy ((char *)yyls, (char *)yyls1,
-		   size * (unsigned int) sizeof (*yylsp));
-#endif
+
+      {
+	short *yyss1 = yyss;
+	union yyalloc *yyptr =
+	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
+	if (! yyptr)
+	  goto yyoverflowlab;
+	YYSTACK_RELOCATE (yyss);
+	YYSTACK_RELOCATE (yyvs);
+# if YYLSP_NEEDED
+	YYSTACK_RELOCATE (yyls);
+# endif
+# undef YYSTACK_RELOCATE
+	if (yyss1 != yyssa)
+	  YYSTACK_FREE (yyss1);
+      }
+# endif
 #endif /* no yyoverflow */
 
-      yyssp = yyss + size - 1;
-      yyvsp = yyvs + size - 1;
-#ifdef YYLSP_NEEDED
-      yylsp = yyls + size - 1;
-#endif
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
-#endif
+      yyssp = yyss + yysize - 1;
+      yyvsp = yyvs + yysize - 1;
+#if YYLSP_NEEDED
+      yylsp = yyls + yysize - 1;
+#endif
+
+      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
+		  (unsigned long int) yystacksize));
 
       if (yyssp >= yyss + yystacksize - 1)
 	YYABORT;
     }
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Entering state %d\n", yystate);
-#endif
+  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
 
   goto yybackup;
- yybackup:
+
+
+/*-----------.
+| yybackup.  |
+`-----------*/
+yybackup:
 
 /* Do appropriate processing given the current state.  */
 /* Read a lookahead token if we need one and don't already have one.  */
@@ -725,10 +867,7 @@ yynewstate:
 
   if (yychar == YYEMPTY)
     {
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Reading a token: ");
-#endif
+      YYDPRINTF ((stderr, "Reading a token: "));
       yychar = YYLEX;
     }
 
@@ -739,25 +878,25 @@ yynewstate:
       yychar1 = 0;
       yychar = YYEOF;		/* Don't call YYLEX any more */
 
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Now at end of input.\n");
-#endif
+      YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
   else
     {
-      yychar1 = YYTRANSLATE(yychar);
-
-#if YYDEBUG != 0
+      yychar1 = YYTRANSLATE (yychar);
+
+#if YYDEBUG
+     /* We have to keep this `#if YYDEBUG', since we use variables
+	which are defined only if `YYDEBUG' is set.  */
       if (yydebug)
 	{
-	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
-	  /* Give the individual parser a way to print the precise meaning
-	     of a token, for further debugging info.  */
-#ifdef YYPRINT
+	  YYFPRINTF (stderr, "Next token is %d (%s",
+		     yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise
+	     meaning of a token, for further debugging info.  */
+# ifdef YYPRINT
 	  YYPRINT (stderr, yychar, yylval);
-#endif
-	  fprintf (stderr, ")\n");
+# endif
+	  YYFPRINTF (stderr, ")\n");
 	}
 #endif
     }
@@ -789,177 +928,185 @@ yynewstate:
     YYACCEPT;
 
   /* Shift the lookahead token.  */
-
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
-#endif
+  YYDPRINTF ((stderr, "Shifting token %d (%s), ",
+	      yychar, yytname[yychar1]));
 
   /* Discard the token being shifted unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   *++yylsp = yylloc;
 #endif
 
-  /* count tokens shifted since error; after three, turn off error status.  */
-  if (yyerrstatus) yyerrstatus--;
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
 
   yystate = yyn;
   goto yynewstate;
 
-/* Do the default action for the current state.  */
+
+/*-----------------------------------------------------------.
+| yydefault -- do the default action for the current state.  |
+`-----------------------------------------------------------*/
 yydefault:
-
   yyn = yydefact[yystate];
   if (yyn == 0)
     goto yyerrlab;
-
-/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+  goto yyreduce;
+
+
+/*-----------------------------.
+| yyreduce -- Do a reduction.  |
+`-----------------------------*/
 yyreduce:
+  /* yyn is the number of a rule to reduce with.  */
   yylen = yyr2[yyn];
-  if (yylen > 0)
-    yyval = yyvsp[1-yylen]; /* implement default value of the action */
-
-#if YYDEBUG != 0
+
+  /* If YYLEN is nonzero, implement the default value of the action:
+     `$$ = $1'.
+
+     Otherwise, the following line sets YYVAL to the semantic value of
+     the lookahead token.  This behavior is undocumented and Bison
+     users should not rely upon it.  Assigning to YYVAL
+     unconditionally makes the parser a bit smaller, and it avoids a
+     GCC warning that YYVAL may be used uninitialized.  */
+  yyval = yyvsp[1-yylen];
+
+#if YYLSP_NEEDED
+  /* Similarly for the default location.  Let the user run additional
+     commands if for instance locations are ranges.  */
+  yyloc = yylsp[1-yylen];
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
+#endif
+
+#if YYDEBUG
+  /* We have to keep this `#if YYDEBUG', since we use variables which
+     are defined only if `YYDEBUG' is set.  */
   if (yydebug)
     {
-      int i;
-
-      fprintf (stderr, "Reducing via rule %d (line %d), ",
-	       yyn, yyrline[yyn]);
+      int yyi;
+
+      YYFPRINTF (stderr, "Reducing via rule %d (line %d), ",
+		 yyn, yyrline[yyn]);
 
       /* Print the symbols being reduced, and their result.  */
-      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
-	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
-      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
-    }
-#endif
-
+      for (yyi = yyprhs[yyn]; yyrhs[yyi] > 0; yyi++)
+	YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
+      YYFPRINTF (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
 
   switch (yyn) {
 
 case 1:
-#line 175 "plural.y"
+#line 151 "plural.y"
 {
 	    if (yyvsp[0].exp == NULL)
 	      YYABORT;
 	    ((struct parse_args *) arg)->res = yyvsp[0].exp;
-	  ;
-    break;}
+	  }
+    break;
 case 2:
+#line 159 "plural.y"
+{
+	    yyval.exp = new_exp_3 (qmop, yyvsp[-4].exp, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 3:
+#line 163 "plural.y"
+{
+	    yyval.exp = new_exp_2 (lor, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 4:
+#line 167 "plural.y"
+{
+	    yyval.exp = new_exp_2 (land, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 5:
+#line 171 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 6:
+#line 175 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 7:
+#line 179 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 8:
 #line 183 "plural.y"
 {
-	    yyval.exp = new_exp_3 (qmop, yyvsp[-4].exp, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 3:
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  }
+    break;
+case 9:
 #line 187 "plural.y"
 {
-	    yyval.exp = new_exp_2 (lor, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 4:
+	    yyval.exp = new_exp_1 (lnot, yyvsp[0].exp);
+	  }
+    break;
+case 10:
 #line 191 "plural.y"
 {
-	    yyval.exp = new_exp_2 (land, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 5:
+	    yyval.exp = new_exp_0 (var);
+	  }
+    break;
+case 11:
 #line 195 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 6:
-#line 199 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 7:
-#line 203 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 8:
-#line 207 "plural.y"
-{
-	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
-	  ;
-    break;}
-case 9:
-#line 211 "plural.y"
-{
-	    yyval.exp = new_exp_1 (lnot, yyvsp[0].exp);
-	  ;
-    break;}
-case 10:
-#line 215 "plural.y"
-{
-	    yyval.exp = new_exp_0 (var);
-	  ;
-    break;}
-case 11:
-#line 219 "plural.y"
 {
 	    if ((yyval.exp = new_exp_0 (num)) != NULL)
 	      yyval.exp->val.num = yyvsp[0].num;
-	  ;
-    break;}
+	  }
+    break;
 case 12:
-#line 224 "plural.y"
+#line 200 "plural.y"
 {
 	    yyval.exp = yyvsp[-1].exp;
-	  ;
-    break;}
+	  }
+    break;
 }
-   /* the action file gets copied in in place of this dollarsign */
-#line 543 "/usr/local/share/bison.simple"
+
+#line 705 "/usr/local/share/bison/bison.simple"
+
 
   yyvsp -= yylen;
   yyssp -= yylen;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp -= yylen;
 #endif
 
-#if YYDEBUG != 0
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
     }
 #endif
 
   *++yyvsp = yyval;
-
-#ifdef YYLSP_NEEDED
-  yylsp++;
-  if (yylen == 0)
-    {
-      yylsp->first_line = yylloc.first_line;
-      yylsp->first_column = yylloc.first_column;
-      yylsp->last_line = (yylsp-1)->last_line;
-      yylsp->last_column = (yylsp-1)->last_column;
-      yylsp->text = 0;
-    }
-  else
-    {
-      yylsp->last_line = (yylsp+yylen-1)->last_line;
-      yylsp->last_column = (yylsp+yylen-1)->last_column;
-    }
-#endif
-
-  /* Now "shift" the result of the reduction.
-     Determine what state that goes to,
-     based on the state we popped back to
-     and the rule number reduced by.  */
+#if YYLSP_NEEDED
+  *++yylsp = yyloc;
+#endif
+
+  /* Now `shift' the result of the reduction.  Determine what state
+     that goes to, based on the state we popped back to and the rule
+     number reduced by.  */
 
   yyn = yyr1[yyn];
 
@@ -971,10 +1118,13 @@ case 12:
 
   goto yynewstate;
 
-yyerrlab:   /* here on detecting error */
-
-  if (! yyerrstatus)
-    /* If not already recovering from an error, report this error.  */
+
+/*------------------------------------.
+| yyerrlab -- here on detecting error |
+`------------------------------------*/
+yyerrlab:
+  /* If not already recovering from an error, report this error.  */
+  if (!yyerrstatus)
     {
       ++yynerrs;
 
@@ -983,102 +1133,121 @@ yyerrlab:   /* here on detecting error *
 
       if (yyn > YYFLAG && yyn < YYLAST)
 	{
-	  int size = 0;
-	  char *msg;
-	  int x, count;
-
-	  count = 0;
-	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
-	  for (x = (yyn < 0 ? -yyn : 0);
-	       x < (sizeof(yytname) / sizeof(char *)); x++)
-	    if (yycheck[x + yyn] == x)
-	      size += strlen(yytname[x]) + 15, count++;
-	  msg = (char *) malloc(size + 15);
-	  if (msg != 0)
+	  YYSIZE_T yysize = 0;
+	  char *yymsg;
+	  int yyx, yycount;
+
+	  yycount = 0;
+	  /* Start YYX at -YYN if negative to avoid negative indexes in
+	     YYCHECK.  */
+	  for (yyx = yyn < 0 ? -yyn : 0;
+	       yyx < (int) (sizeof (yytname) / sizeof (char *)); yyx++)
+	    if (yycheck[yyx + yyn] == yyx)
+	      yysize += yystrlen (yytname[yyx]) + 15, yycount++;
+	  yysize += yystrlen ("parse error, unexpected ") + 1;
+	  yysize += yystrlen (yytname[YYTRANSLATE (yychar)]);
+	  yymsg = (char *) YYSTACK_ALLOC (yysize);
+	  if (yymsg != 0)
 	    {
-	      strcpy(msg, "parse error");
-
-	      if (count < 5)
+	      char *yyp = yystpcpy (yymsg, "parse error, unexpected ");
+	      yyp = yystpcpy (yyp, yytname[YYTRANSLATE (yychar)]);
+
+	      if (yycount < 5)
 		{
-		  count = 0;
-		  for (x = (yyn < 0 ? -yyn : 0);
-		       x < (sizeof(yytname) / sizeof(char *)); x++)
-		    if (yycheck[x + yyn] == x)
+		  yycount = 0;
+		  for (yyx = yyn < 0 ? -yyn : 0;
+		       yyx < (int) (sizeof (yytname) / sizeof (char *));
+		       yyx++)
+		    if (yycheck[yyx + yyn] == yyx)
 		      {
-			strcat(msg, count == 0 ? ", expecting `" : " or `");
-			strcat(msg, yytname[x]);
-			strcat(msg, "'");
-			count++;
+			const char *yyq = ! yycount ? ", expecting " : " or ";
+			yyp = yystpcpy (yyp, yyq);
+			yyp = yystpcpy (yyp, yytname[yyx]);
+			yycount++;
 		      }
 		}
-	      yyerror(msg);
-	      free(msg);
+	      yyerror (yymsg);
+	      YYSTACK_FREE (yymsg);
 	    }
 	  else
-	    yyerror ("parse error; also virtual memory exceeded");
+	    yyerror ("parse error; also virtual memory exhausted");
 	}
       else
-#endif /* YYERROR_VERBOSE */
-	yyerror("parse error");
-    }
-
+#endif /* defined (YYERROR_VERBOSE) */
+	yyerror ("parse error");
+    }
   goto yyerrlab1;
-yyerrlab1:   /* here on error raised explicitly by an action */
-
+
+
+/*--------------------------------------------------.
+| yyerrlab1 -- error raised explicitly by an action |
+`--------------------------------------------------*/
+yyerrlab1:
   if (yyerrstatus == 3)
     {
-      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+      /* If just tried and failed to reuse lookahead token after an
+	 error, discard it.  */
 
       /* return failure if at end of input */
       if (yychar == YYEOF)
 	YYABORT;
-
-#if YYDEBUG != 0
-      if (yydebug)
-	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
-#endif
-
+      YYDPRINTF ((stderr, "Discarding token %d (%s).\n",
+		  yychar, yytname[yychar1]));
       yychar = YYEMPTY;
     }
 
-  /* Else will try to reuse lookahead token
-     after shifting the error token.  */
+  /* Else will try to reuse lookahead token after shifting the error
+     token.  */
 
   yyerrstatus = 3;		/* Each real token shifted decrements this */
 
   goto yyerrhandle;
 
-yyerrdefault:  /* current state does not do anything special for the error token. */
-
+
+/*-------------------------------------------------------------------.
+| yyerrdefault -- current state does not do anything special for the |
+| error token.                                                       |
+`-------------------------------------------------------------------*/
+yyerrdefault:
 #if 0
   /* This is wrong; only states that explicitly want error tokens
      should shift them.  */
-  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
-  if (yyn) goto yydefault;
-#endif
-
-yyerrpop:   /* pop the current state because it cannot handle the error token */
-
-  if (yyssp == yyss) YYABORT;
+
+  /* If its default is to accept any token, ok.  Otherwise pop it.  */
+  yyn = yydefact[yystate];
+  if (yyn)
+    goto yydefault;
+#endif
+
+
+/*---------------------------------------------------------------.
+| yyerrpop -- pop the current state because it cannot handle the |
+| error token                                                    |
+`---------------------------------------------------------------*/
+yyerrpop:
+  if (yyssp == yyss)
+    YYABORT;
   yyvsp--;
   yystate = *--yyssp;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   yylsp--;
 #endif
 
-#if YYDEBUG != 0
+#if YYDEBUG
   if (yydebug)
     {
-      short *ssp1 = yyss - 1;
-      fprintf (stderr, "Error: state stack now");
-      while (ssp1 != yyssp)
-	fprintf (stderr, " %d", *++ssp1);
-      fprintf (stderr, "\n");
-    }
-#endif
-
+      short *yyssp1 = yyss - 1;
+      YYFPRINTF (stderr, "Error: state stack now");
+      while (yyssp1 != yyssp)
+	YYFPRINTF (stderr, " %d", *++yyssp1);
+      YYFPRINTF (stderr, "\n");
+    }
+#endif
+
+/*--------------.
+| yyerrhandle.  |
+`--------------*/
 yyerrhandle:
-
   yyn = yypact[yystate];
   if (yyn == YYFLAG)
     goto yyerrdefault;
@@ -1101,50 +1270,52 @@ yyerrhandle:
   if (yyn == YYFINAL)
     YYACCEPT;
 
-#if YYDEBUG != 0
-  if (yydebug)
-    fprintf(stderr, "Shifting error token, ");
-#endif
+  YYDPRINTF ((stderr, "Shifting error token, "));
 
   *++yyvsp = yylval;
-#ifdef YYLSP_NEEDED
+#if YYLSP_NEEDED
   *++yylsp = yylloc;
 #endif
 
   yystate = yyn;
   goto yynewstate;
 
- yyacceptlab:
-  /* YYACCEPT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 0;
-
- yyabortlab:
-  /* YYABORT comes here.  */
-  if (yyfree_stacks)
-    {
-      free (yyss);
-      free (yyvs);
-#ifdef YYLSP_NEEDED
-      free (yyls);
-#endif
-    }
-  return 1;
+
+/*-------------------------------------.
+| yyacceptlab -- YYACCEPT comes here.  |
+`-------------------------------------*/
+yyacceptlab:
+  yyresult = 0;
+  goto yyreturn;
+
+/*-----------------------------------.
+| yyabortlab -- YYABORT comes here.  |
+`-----------------------------------*/
+yyabortlab:
+  yyresult = 1;
+  goto yyreturn;
+
+/*---------------------------------------------.
+| yyoverflowab -- parser overflow comes here.  |
+`---------------------------------------------*/
+yyoverflowlab:
+  yyerror ("parser stack overflow");
+  yyresult = 2;
+  /* Fall through.  */
+
+yyreturn:
+#ifndef yyoverflow
+  if (yyss != yyssa)
+    YYSTACK_FREE (yyss);
+#endif
+  return yyresult;
 }
-#line 229 "plural.y"
+#line 205 "plural.y"
 
 
 void
 internal_function
-FREE_EXPRESSION (exp)
-     struct expression *exp;
+FREE_EXPRESSION (struct expression *exp)
 {
   if (exp == NULL)
     return;
@@ -1170,9 +1341,7 @@ FREE_EXPRESSION (exp)
 
 
 static int
-yylex (lval, pexp)
-     YYSTYPE *lval;
-     const char **pexp;
+yylex (YYSTYPE *lval, const char **pexp)
 {
   const char *exp = *pexp;
   int result;
@@ -1315,8 +1484,7 @@ yylex (lval, pexp)
 
 
 static void
-yyerror (str)
-     const char *str;
+yyerror (const char *str)
 {
   /* Do nothing.  We don't print error messages here.  */
 }
diff -r 4216c218ee44 -r e04165992166 intl/plural.y
--- a/intl/plural.y	Sat May 28 13:40:15 2005 +0000
+++ b/intl/plural.y	Sat May 28 13:45:22 2005 +0000
@@ -1,6 +1,6 @@
 %{
 /* Expression parsing for plural form selection.
-   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 2000-2001, 2003 Free Software Foundation, Inc.
    Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
 
    This program is free software; you can redistribute it and/or modify it
@@ -54,28 +54,13 @@
 
 %{
 /* Prototypes for local functions.  */
-static struct expression *new_exp PARAMS ((int nargs, enum operator op,
-					   struct expression * const *args));
-static inline struct expression *new_exp_0 PARAMS ((enum operator op));
-static inline struct expression *new_exp_1 PARAMS ((enum operator op,
-						   struct expression *right));
-static struct expression *new_exp_2 PARAMS ((enum operator op,
-					     struct expression *left,
-					     struct expression *right));
-static inline struct expression *new_exp_3 PARAMS ((enum operator op,
-						   struct expression *bexp,
-						   struct expression *tbranch,
-						   struct expression *fbranch));
-static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
-static void yyerror PARAMS ((const char *str));
+static int yylex (YYSTYPE *lval, const char **pexp);
+static void yyerror (const char *str);
 
 /* Allocation of expressions.  */
 
 static struct expression *
-new_exp (nargs, op, args)
-     int nargs;
-     enum operator op;
-     struct expression * const *args;
+new_exp (int nargs, enum operator op, struct expression * const *args)
 {
   int i;
   struct expression *newp;
@@ -104,16 +89,13 @@ new_exp (nargs, op, args)
 }
 
 static inline struct expression *
-new_exp_0 (op)
-     enum operator op;
+new_exp_0 (enum operator op)
 {
   return new_exp (0, op, NULL);
 }
 
 static inline struct expression *
-new_exp_1 (op, right)
-     enum operator op;
-     struct expression *right;
+new_exp_1 (enum operator op, struct expression *right)
 {
   struct expression *args[1];
 
@@ -122,10 +104,7 @@ new_exp_1 (op, right)
 }
 
 static struct expression *
-new_exp_2 (op, left, right)
-     enum operator op;
-     struct expression *left;
-     struct expression *right;
+new_exp_2 (enum operator op, struct expression *left, struct expression *right)
 {
   struct expression *args[2];
 
@@ -135,11 +114,8 @@ new_exp_2 (op, left, right)
 }
 
 static inline struct expression *
-new_exp_3 (op, bexp, tbranch, fbranch)
-     enum operator op;
-     struct expression *bexp;
-     struct expression *tbranch;
-     struct expression *fbranch;
+new_exp_3 (enum operator op, struct expression *bexp,
+	   struct expression *tbranch, struct expression *fbranch)
 {
   struct expression *args[3];
 
@@ -230,8 +206,7 @@ exp:	  exp '?' exp ':' exp
 
 void
 internal_function
-FREE_EXPRESSION (exp)
-     struct expression *exp;
+FREE_EXPRESSION (struct expression *exp)
 {
   if (exp == NULL)
     return;
@@ -257,9 +232,7 @@ FREE_EXPRESSION (exp)
 
 
 static int
-yylex (lval, pexp)
-     YYSTYPE *lval;
-     const char **pexp;
+yylex (YYSTYPE *lval, const char **pexp)
 {
   const char *exp = *pexp;
   int result;
@@ -402,8 +375,7 @@ yylex (lval, pexp)
 
 
 static void
-yyerror (str)
-     const char *str;
+yyerror (const char *str)
 {
   /* Do nothing.  We don't print error messages here.  */
 }
diff -r 4216c218ee44 -r e04165992166 intl/printf-args.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/printf-args.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,119 @@
+/* Decomposed printf argument list.
+   Copyright (C) 1999, 2002-2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+/* Specification.  */
+#include "printf-args.h"
+
+#ifdef STATIC
+STATIC
+#endif
+int
+printf_fetchargs (va_list args, arguments *a)
+{
+  size_t i;
+  argument *ap;
+
+  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)
+    switch (ap->type)
+      {
+      case TYPE_SCHAR:
+	ap->a.a_schar = va_arg (args, /*signed char*/ int);
+	break;
+      case TYPE_UCHAR:
+	ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);
+	break;
+      case TYPE_SHORT:
+	ap->a.a_short = va_arg (args, /*short*/ int);
+	break;
+      case TYPE_USHORT:
+	ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);
+	break;
+      case TYPE_INT:
+	ap->a.a_int = va_arg (args, int);
+	break;
+      case TYPE_UINT:
+	ap->a.a_uint = va_arg (args, unsigned int);
+	break;
+      case TYPE_LONGINT:
+	ap->a.a_longint = va_arg (args, long int);
+	break;
+      case TYPE_ULONGINT:
+	ap->a.a_ulongint = va_arg (args, unsigned long int);
+	break;
+#ifdef HAVE_LONG_LONG
+      case TYPE_LONGLONGINT:
+	ap->a.a_longlongint = va_arg (args, long long int);
+	break;
+      case TYPE_ULONGLONGINT:
+	ap->a.a_ulonglongint = va_arg (args, unsigned long long int);
+	break;
+#endif
+      case TYPE_DOUBLE:
+	ap->a.a_double = va_arg (args, double);
+	break;
+#ifdef HAVE_LONG_DOUBLE
+      case TYPE_LONGDOUBLE:
+	ap->a.a_longdouble = va_arg (args, long double);
+	break;
+#endif
+      case TYPE_CHAR:
+	ap->a.a_char = va_arg (args, int);
+	break;
+#ifdef HAVE_WINT_T
+      case TYPE_WIDE_CHAR:
+	ap->a.a_wide_char = va_arg (args, wint_t);
+	break;
+#endif
+      case TYPE_STRING:
+	ap->a.a_string = va_arg (args, const char *);
+	break;
+#ifdef HAVE_WCHAR_T
+      case TYPE_WIDE_STRING:
+	ap->a.a_wide_string = va_arg (args, const wchar_t *);
+	break;
+#endif
+      case TYPE_POINTER:
+	ap->a.a_pointer = va_arg (args, void *);
+	break;
+      case TYPE_COUNT_SCHAR_POINTER:
+	ap->a.a_count_schar_pointer = va_arg (args, signed char *);
+	break;
+      case TYPE_COUNT_SHORT_POINTER:
+	ap->a.a_count_short_pointer = va_arg (args, short *);
+	break;
+      case TYPE_COUNT_INT_POINTER:
+	ap->a.a_count_int_pointer = va_arg (args, int *);
+	break;
+      case TYPE_COUNT_LONGINT_POINTER:
+	ap->a.a_count_longint_pointer = va_arg (args, long int *);
+	break;
+#ifdef HAVE_LONG_LONG
+      case TYPE_COUNT_LONGLONGINT_POINTER:
+	ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);
+	break;
+#endif
+      default:
+	/* Unknown type.  */
+	return -1;
+      }
+  return 0;
+}
diff -r 4216c218ee44 -r e04165992166 intl/printf-args.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/printf-args.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,137 @@
+/* Decomposed printf argument list.
+   Copyright (C) 1999, 2002-2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _PRINTF_ARGS_H
+#define _PRINTF_ARGS_H
+
+/* Get size_t.  */
+#include <stddef.h>
+
+/* Get wchar_t.  */
+#ifdef HAVE_WCHAR_T
+# include <stddef.h>
+#endif
+
+/* Get wint_t.  */
+#ifdef HAVE_WINT_T
+# include <wchar.h>
+#endif
+
+/* Get va_list.  */
+#include <stdarg.h>
+
+
+/* Argument types */
+typedef enum
+{
+  TYPE_NONE,
+  TYPE_SCHAR,
+  TYPE_UCHAR,
+  TYPE_SHORT,
+  TYPE_USHORT,
+  TYPE_INT,
+  TYPE_UINT,
+  TYPE_LONGINT,
+  TYPE_ULONGINT,
+#ifdef HAVE_LONG_LONG
+  TYPE_LONGLONGINT,
+  TYPE_ULONGLONGINT,
+#endif
+  TYPE_DOUBLE,
+#ifdef HAVE_LONG_DOUBLE
+  TYPE_LONGDOUBLE,
+#endif
+  TYPE_CHAR,
+#ifdef HAVE_WINT_T
+  TYPE_WIDE_CHAR,
+#endif
+  TYPE_STRING,
+#ifdef HAVE_WCHAR_T
+  TYPE_WIDE_STRING,
+#endif
+  TYPE_POINTER,
+  TYPE_COUNT_SCHAR_POINTER,
+  TYPE_COUNT_SHORT_POINTER,
+  TYPE_COUNT_INT_POINTER,
+  TYPE_COUNT_LONGINT_POINTER
+#ifdef HAVE_LONG_LONG
+, TYPE_COUNT_LONGLONGINT_POINTER
+#endif
+} arg_type;
+
+/* Polymorphic argument */
+typedef struct
+{
+  arg_type type;
+  union
+  {
+    signed char			a_schar;
+    unsigned char		a_uchar;
+    short			a_short;
+    unsigned short		a_ushort;
+    int				a_int;
+    unsigned int		a_uint;
+    long int			a_longint;
+    unsigned long int		a_ulongint;
+#ifdef HAVE_LONG_LONG
+    long long int		a_longlongint;
+    unsigned long long int	a_ulonglongint;
+#endif
+    float			a_float;
+    double			a_double;
+#ifdef HAVE_LONG_DOUBLE
+    long double			a_longdouble;
+#endif
+    int				a_char;
+#ifdef HAVE_WINT_T
+    wint_t			a_wide_char;
+#endif
+    const char*			a_string;
+#ifdef HAVE_WCHAR_T
+    const wchar_t*		a_wide_string;
+#endif
+    void*			a_pointer;
+    signed char *		a_count_schar_pointer;
+    short *			a_count_short_pointer;
+    int *			a_count_int_pointer;
+    long int *			a_count_longint_pointer;
+#ifdef HAVE_LONG_LONG
+    long long int *		a_count_longlongint_pointer;
+#endif
+  }
+  a;
+}
+argument;
+
+typedef struct
+{
+  size_t count;
+  argument *arg;
+}
+arguments;
+
+
+/* Fetch the arguments, putting them into a. */
+#ifdef STATIC
+STATIC
+#else
+extern
+#endif
+int printf_fetchargs (va_list args, arguments *a);
+
+#endif /* _PRINTF_ARGS_H */
diff -r 4216c218ee44 -r e04165992166 intl/printf-parse.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/printf-parse.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,537 @@
+/* Formatted output to strings.
+   Copyright (C) 1999-2000, 2002-2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+/* Specification.  */
+#if WIDE_CHAR_VERSION
+# include "wprintf-parse.h"
+#else
+# include "printf-parse.h"
+#endif
+
+/* Get size_t, NULL.  */
+#include <stddef.h>
+
+/* Get intmax_t.  */
+#if HAVE_STDINT_H_WITH_UINTMAX
+# include <stdint.h>
+#endif
+#if HAVE_INTTYPES_H_WITH_UINTMAX
+# include <inttypes.h>
+#endif
+
+/* malloc(), realloc(), free().  */
+#include <stdlib.h>
+
+/* Checked size_t computations.  */
+#include "xsize.h"
+
+#if WIDE_CHAR_VERSION
+# define PRINTF_PARSE wprintf_parse
+# define CHAR_T wchar_t
+# define DIRECTIVE wchar_t_directive
+# define DIRECTIVES wchar_t_directives
+#else
+# define PRINTF_PARSE printf_parse
+# define CHAR_T char
+# define DIRECTIVE char_directive
+# define DIRECTIVES char_directives
+#endif
+
+#ifdef STATIC
+STATIC
+#endif
+int
+PRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)
+{
+  const CHAR_T *cp = format;		/* pointer into format */
+  size_t arg_posn = 0;		/* number of regular arguments consumed */
+  size_t d_allocated;			/* allocated elements of d->dir */
+  size_t a_allocated;			/* allocated elements of a->arg */
+  size_t max_width_length = 0;
+  size_t max_precision_length = 0;
+
+  d->count = 0;
+  d_allocated = 1;
+  d->dir = malloc (d_allocated * sizeof (DIRECTIVE));
+  if (d->dir == NULL)
+    /* Out of memory.  */
+    return -1;
+
+  a->count = 0;
+  a_allocated = 0;
+  a->arg = NULL;
+
+#define REGISTER_ARG(_index_,_type_) \
+  {									\
+    size_t n = (_index_);						\
+    if (n >= a_allocated)						\
+      {									\
+	size_t memory_size;						\
+	argument *memory;						\
+									\
+	a_allocated = xtimes (a_allocated, 2);				\
+	if (a_allocated <= n)						\
+	  a_allocated = xsum (n, 1);					\
+	memory_size = xtimes (a_allocated, sizeof (argument));		\
+	if (size_overflow_p (memory_size))				\
+	  /* Overflow, would lead to out of memory.  */			\
+	  goto error;							\
+	memory = (a->arg						\
+		  ? realloc (a->arg, memory_size)			\
+		  : malloc (memory_size));				\
+	if (memory == NULL)						\
+	  /* Out of memory.  */						\
+	  goto error;							\
+	a->arg = memory;						\
+      }									\
+    while (a->count <= n)						\
+      a->arg[a->count++].type = TYPE_NONE;				\
+    if (a->arg[n].type == TYPE_NONE)					\
+      a->arg[n].type = (_type_);					\
+    else if (a->arg[n].type != (_type_))				\
+      /* Ambiguous type for positional argument.  */			\
+      goto error;							\
+  }
+
+  while (*cp != '\0')
+    {
+      CHAR_T c = *cp++;
+      if (c == '%')
+	{
+	  size_t arg_index = ARG_NONE;
+	  DIRECTIVE *dp = &d->dir[d->count];/* pointer to next directive */
+
+	  /* Initialize the next directive.  */
+	  dp->dir_start = cp - 1;
+	  dp->flags = 0;
+	  dp->width_start = NULL;
+	  dp->width_end = NULL;
+	  dp->width_arg_index = ARG_NONE;
+	  dp->precision_start = NULL;
+	  dp->precision_end = NULL;
+	  dp->precision_arg_index = ARG_NONE;
+	  dp->arg_index = ARG_NONE;
+
+	  /* Test for positional argument.  */
+	  if (*cp >= '0' && *cp <= '9')
+	    {
+	      const CHAR_T *np;
+
+	      for (np = cp; *np >= '0' && *np <= '9'; np++)
+		;
+	      if (*np == '$')
+		{
+		  size_t n = 0;
+
+		  for (np = cp; *np >= '0' && *np <= '9'; np++)
+		    n = xsum (xtimes (n, 10), *np - '0');
+		  if (n == 0)
+		    /* Positional argument 0.  */
+		    goto error;
+		  if (size_overflow_p (n))
+		    /* n too large, would lead to out of memory later.  */
+		    goto error;
+		  arg_index = n - 1;
+		  cp = np + 1;
+		}
+	    }
+
+	  /* Read the flags.  */
+	  for (;;)
+	    {
+	      if (*cp == '\'')
+		{
+		  dp->flags |= FLAG_GROUP;
+		  cp++;
+		}
+	      else if (*cp == '-')
+		{
+		  dp->flags |= FLAG_LEFT;
+		  cp++;
+		}
+	      else if (*cp == '+')
+		{
+		  dp->flags |= FLAG_SHOWSIGN;
+		  cp++;
+		}
+	      else if (*cp == ' ')
+		{
+		  dp->flags |= FLAG_SPACE;
+		  cp++;
+		}
+	      else if (*cp == '#')
+		{
+		  dp->flags |= FLAG_ALT;
+		  cp++;
+		}
+	      else if (*cp == '0')
+		{
+		  dp->flags |= FLAG_ZERO;
+		  cp++;
+		}
+	      else
+		break;
+	    }
+
+	  /* Parse the field width.  */
+	  if (*cp == '*')
+	    {
+	      dp->width_start = cp;
+	      cp++;
+	      dp->width_end = cp;
+	      if (max_width_length < 1)
+		max_width_length = 1;
+
+	      /* Test for positional argument.  */
+	      if (*cp >= '0' && *cp <= '9')
+		{
+		  const CHAR_T *np;
+
+		  for (np = cp; *np >= '0' && *np <= '9'; np++)
+		    ;
+		  if (*np == '$')
+		    {
+		      size_t n = 0;
+
+		      for (np = cp; *np >= '0' && *np <= '9'; np++)
+			n = xsum (xtimes (n, 10), *np - '0');
+		      if (n == 0)
+			/* Positional argument 0.  */
+			goto error;
+		      if (size_overflow_p (n))
+			/* n too large, would lead to out of memory later.  */
+			goto error;
+		      dp->width_arg_index = n - 1;
+		      cp = np + 1;
+		    }
+		}
+	      if (dp->width_arg_index == ARG_NONE)
+		{
+		  dp->width_arg_index = arg_posn++;
+		  if (dp->width_arg_index == ARG_NONE)
+		    /* arg_posn wrapped around.  */
+		    goto error;
+		}
+	      REGISTER_ARG (dp->width_arg_index, TYPE_INT);
+	    }
+	  else if (*cp >= '0' && *cp <= '9')
+	    {
+	      size_t width_length;
+
+	      dp->width_start = cp;
+	      for (; *cp >= '0' && *cp <= '9'; cp++)
+		;
+	      dp->width_end = cp;
+	      width_length = dp->width_end - dp->width_start;
+	      if (max_width_length < width_length)
+		max_width_length = width_length;
+	    }
+
+	  /* Parse the precision.  */
+	  if (*cp == '.')
+	    {
+	      cp++;
+	      if (*cp == '*')
+		{
+		  dp->precision_start = cp - 1;
+		  cp++;
+		  dp->precision_end = cp;
+		  if (max_precision_length < 2)
+		    max_precision_length = 2;
+
+		  /* Test for positional argument.  */
+		  if (*cp >= '0' && *cp <= '9')
+		    {
+		      const CHAR_T *np;
+
+		      for (np = cp; *np >= '0' && *np <= '9'; np++)
+			;
+		      if (*np == '$')
+			{
+			  size_t n = 0;
+
+			  for (np = cp; *np >= '0' && *np <= '9'; np++)
+			    n = xsum (xtimes (n, 10), *np - '0');
+			  if (n == 0)
+			    /* Positional argument 0.  */
+			    goto error;
+			  if (size_overflow_p (n))
+			    /* n too large, would lead to out of memory
+			       later.  */
+			    goto error;
+			  dp->precision_arg_index = n - 1;
+			  cp = np + 1;
+			}
+		    }
+		  if (dp->precision_arg_index == ARG_NONE)
+		    {
+		      dp->precision_arg_index = arg_posn++;
+		      if (dp->precision_arg_index == ARG_NONE)
+			/* arg_posn wrapped around.  */
+			goto error;
+		    }
+		  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);
+		}
+	      else
+		{
+		  size_t precision_length;
+
+		  dp->precision_start = cp - 1;
+		  for (; *cp >= '0' && *cp <= '9'; cp++)
+		    ;
+		  dp->precision_end = cp;
+		  precision_length = dp->precision_end - dp->precision_start;
+		  if (max_precision_length < precision_length)
+		    max_precision_length = precision_length;
+		}
+	    }
+
+	  {
+	    arg_type type;
+
+	    /* Parse argument type/size specifiers.  */
+	    {
+	      int flags = 0;
+
+	      for (;;)
+		{
+		  if (*cp == 'h')
+		    {
+		      flags |= (1 << (flags & 1));
+		      cp++;
+		    }
+		  else if (*cp == 'L')
+		    {
+		      flags |= 4;
+		      cp++;
+		    }
+		  else if (*cp == 'l')
+		    {
+		      flags += 8;
+		      cp++;
+		    }
+#ifdef HAVE_INTMAX_T
+		  else if (*cp == 'j')
+		    {
+		      if (sizeof (intmax_t) > sizeof (long))
+			{
+			  /* intmax_t = long long */
+			  flags += 16;
+			}
+		      else if (sizeof (intmax_t) > sizeof (int))
+			{
+			  /* intmax_t = long */
+			  flags += 8;
+			}
+		      cp++;
+		    }
+#endif
+		  else if (*cp == 'z' || *cp == 'Z')
+		    {
+		      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'
+			 because the warning facility in gcc-2.95.2 understands
+			 only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */
+		      if (sizeof (size_t) > sizeof (long))
+			{
+			  /* size_t = long long */
+			  flags += 16;
+			}
+		      else if (sizeof (size_t) > sizeof (int))
+			{
+			  /* size_t = long */
+			  flags += 8;
+			}
+		      cp++;
+		    }
+		  else if (*cp == 't')
+		    {
+		      if (sizeof (ptrdiff_t) > sizeof (long))
+			{
+			  /* ptrdiff_t = long long */
+			  flags += 16;
+			}
+		      else if (sizeof (ptrdiff_t) > sizeof (int))
+			{
+			  /* ptrdiff_t = long */
+			  flags += 8;
+			}
+		      cp++;
+		    }
+		  else
+		    break;
+		}
+
+	      /* Read the conversion character.  */
+	      c = *cp++;
+	      switch (c)
+		{
+		case 'd': case 'i':
+#ifdef HAVE_LONG_LONG
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_LONGLONGINT;
+		  else
+#endif
+		  if (flags >= 8)
+		    type = TYPE_LONGINT;
+		  else if (flags & 2)
+		    type = TYPE_SCHAR;
+		  else if (flags & 1)
+		    type = TYPE_SHORT;
+		  else
+		    type = TYPE_INT;
+		  break;
+		case 'o': case 'u': case 'x': case 'X':
+#ifdef HAVE_LONG_LONG
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_ULONGLONGINT;
+		  else
+#endif
+		  if (flags >= 8)
+		    type = TYPE_ULONGINT;
+		  else if (flags & 2)
+		    type = TYPE_UCHAR;
+		  else if (flags & 1)
+		    type = TYPE_USHORT;
+		  else
+		    type = TYPE_UINT;
+		  break;
+		case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':
+		case 'a': case 'A':
+#ifdef HAVE_LONG_DOUBLE
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_LONGDOUBLE;
+		  else
+#endif
+		  type = TYPE_DOUBLE;
+		  break;
+		case 'c':
+		  if (flags >= 8)
+#ifdef HAVE_WINT_T
+		    type = TYPE_WIDE_CHAR;
+#else
+		    goto error;
+#endif
+		  else
+		    type = TYPE_CHAR;
+		  break;
+#ifdef HAVE_WINT_T
+		case 'C':
+		  type = TYPE_WIDE_CHAR;
+		  c = 'c';
+		  break;
+#endif
+		case 's':
+		  if (flags >= 8)
+#ifdef HAVE_WCHAR_T
+		    type = TYPE_WIDE_STRING;
+#else
+		    goto error;
+#endif
+		  else
+		    type = TYPE_STRING;
+		  break;
+#ifdef HAVE_WCHAR_T
+		case 'S':
+		  type = TYPE_WIDE_STRING;
+		  c = 's';
+		  break;
+#endif
+		case 'p':
+		  type = TYPE_POINTER;
+		  break;
+		case 'n':
+#ifdef HAVE_LONG_LONG
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_COUNT_LONGLONGINT_POINTER;
+		  else
+#endif
+		  if (flags >= 8)
+		    type = TYPE_COUNT_LONGINT_POINTER;
+		  else if (flags & 2)
+		    type = TYPE_COUNT_SCHAR_POINTER;
+		  else if (flags & 1)
+		    type = TYPE_COUNT_SHORT_POINTER;
+		  else
+		    type = TYPE_COUNT_INT_POINTER;
+		  break;
+		case '%':
+		  type = TYPE_NONE;
+		  break;
+		default:
+		  /* Unknown conversion character.  */
+		  goto error;
+		}
+	    }
+
+	    if (type != TYPE_NONE)
+	      {
+		dp->arg_index = arg_index;
+		if (dp->arg_index == ARG_NONE)
+		  {
+		    dp->arg_index = arg_posn++;
+		    if (dp->arg_index == ARG_NONE)
+		      /* arg_posn wrapped around.  */
+		      goto error;
+		  }
+		REGISTER_ARG (dp->arg_index, type);
+	      }
+	    dp->conversion = c;
+	    dp->dir_end = cp;
+	  }
+
+	  d->count++;
+	  if (d->count >= d_allocated)
+	    {
+	      size_t memory_size;
+	      DIRECTIVE *memory;
+
+	      d_allocated = xtimes (d_allocated, 2);
+	      memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));
+	      if (size_overflow_p (memory_size))
+		/* Overflow, would lead to out of memory.  */
+		goto error;
+	      memory = realloc (d->dir, memory_size);
+	      if (memory == NULL)
+		/* Out of memory.  */
+		goto error;
+	      d->dir = memory;
+	    }
+	}
+    }
+  d->dir[d->count].dir_start = cp;
+
+  d->max_width_length = max_width_length;
+  d->max_precision_length = max_precision_length;
+  return 0;
+
+error:
+  if (a->arg)
+    free (a->arg);
+  if (d->dir)
+    free (d->dir);
+  return -1;
+}
+
+#undef DIRECTIVES
+#undef DIRECTIVE
+#undef CHAR_T
+#undef PRINTF_PARSE
diff -r 4216c218ee44 -r e04165992166 intl/printf-parse.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/printf-parse.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,75 @@
+/* Parse printf format string.
+   Copyright (C) 1999, 2002-2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _PRINTF_PARSE_H
+#define _PRINTF_PARSE_H
+
+#include "printf-args.h"
+
+
+/* Flags */
+#define FLAG_GROUP	 1	/* ' flag */
+#define FLAG_LEFT	 2	/* - flag */
+#define FLAG_SHOWSIGN	 4	/* + flag */
+#define FLAG_SPACE	 8	/* space flag */
+#define FLAG_ALT	16	/* # flag */
+#define FLAG_ZERO	32
+
+/* arg_index value indicating that no argument is consumed.  */
+#define ARG_NONE	(~(size_t)0)
+
+/* A parsed directive.  */
+typedef struct
+{
+  const char* dir_start;
+  const char* dir_end;
+  int flags;
+  const char* width_start;
+  const char* width_end;
+  size_t width_arg_index;
+  const char* precision_start;
+  const char* precision_end;
+  size_t precision_arg_index;
+  char conversion; /* d i o u x X f e E g G c s p n U % but not C S */
+  size_t arg_index;
+}
+char_directive;
+
+/* A parsed format string.  */
+typedef struct
+{
+  size_t count;
+  char_directive *dir;
+  size_t max_width_length;
+  size_t max_precision_length;
+}
+char_directives;
+
+
+/* Parses the format string.  Fills in the number N of directives, and fills
+   in directives[0], ..., directives[N-1], and sets directives[N].dir_start
+   to the end of the format string.  Also fills in the arg_type fields of the
+   arguments and the needed count of arguments.  */
+#ifdef STATIC
+STATIC
+#else
+extern
+#endif
+int printf_parse (const char *format, char_directives *d, arguments *a);
+
+#endif /* _PRINTF_PARSE_H */
diff -r 4216c218ee44 -r e04165992166 intl/printf.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/printf.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,371 @@
+/* Formatted output to strings, using POSIX/XSI format strings with positions.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2003.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if defined HAVE_ALLOCA_H || defined _LIBC
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+#include <stdio.h>
+
+#if !HAVE_POSIX_PRINTF
+
+#include <stdlib.h>
+#include <string.h>
+
+/* When building a DLL, we must export some functions.  Note that because
+   the functions are only defined for binary backward compatibility, we
+   don't need to use __declspec(dllimport) in any case.  */
+#if defined _MSC_VER && BUILDING_DLL
+# define DLL_EXPORTED __declspec(dllexport)
+#else
+# define DLL_EXPORTED
+#endif
+
+#define STATIC static
+
+/* Define auxiliary functions declared in "printf-args.h".  */
+#include "printf-args.c"
+
+/* Define auxiliary functions declared in "printf-parse.h".  */
+#include "printf-parse.c"
+
+/* Define functions declared in "vasnprintf.h".  */
+#define vasnprintf libintl_vasnprintf
+#include "vasnprintf.c"
+#if 0 /* not needed */
+#define asnprintf libintl_asnprintf
+#include "asnprintf.c"
+#endif
+
+DLL_EXPORTED
+int
+libintl_vfprintf (FILE *stream, const char *format, va_list args)
+{
+  if (strchr (format, '$') == NULL)
+    return vfprintf (stream, format, args);
+  else
+    {
+      size_t length;
+      char *result = libintl_vasnprintf (NULL, &length, format, args);
+      int retval = -1;
+      if (result != NULL)
+	{
+	  if (fwrite (result, 1, length, stream) == length)
+	    retval = length;
+	  free (result);
+	}
+      return retval;
+    }
+}
+
+DLL_EXPORTED
+int
+libintl_fprintf (FILE *stream, const char *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vfprintf (stream, format, args);
+  va_end (args);
+  return retval;
+}
+
+DLL_EXPORTED
+int
+libintl_vprintf (const char *format, va_list args)
+{
+  return libintl_vfprintf (stdout, format, args);
+}
+
+DLL_EXPORTED
+int
+libintl_printf (const char *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vprintf (format, args);
+  va_end (args);
+  return retval;
+}
+
+DLL_EXPORTED
+int
+libintl_vsprintf (char *resultbuf, const char *format, va_list args)
+{
+  if (strchr (format, '$') == NULL)
+    return vsprintf (resultbuf, format, args);
+  else
+    {
+      size_t length = (size_t) ~0 / (4 * sizeof (char));
+      char *result = libintl_vasnprintf (resultbuf, &length, format, args);
+      if (result != resultbuf)
+	{
+	  free (result);
+	  return -1;
+	}
+      else
+	return length;
+    }
+}
+
+DLL_EXPORTED
+int
+libintl_sprintf (char *resultbuf, const char *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vsprintf (resultbuf, format, args);
+  va_end (args);
+  return retval;
+}
+
+#if HAVE_SNPRINTF
+
+# if HAVE_DECL__SNPRINTF
+   /* Windows.  */
+#  define system_vsnprintf _vsnprintf
+# else
+   /* Unix.  */
+#  define system_vsnprintf vsnprintf
+# endif
+
+DLL_EXPORTED
+int
+libintl_vsnprintf (char *resultbuf, size_t length, const char *format, va_list args)
+{
+  if (strchr (format, '$') == NULL)
+    return system_vsnprintf (resultbuf, length, format, args);
+  else
+    {
+      size_t maxlength = length;
+      char *result = libintl_vasnprintf (resultbuf, &length, format, args);
+      if (result != resultbuf)
+	{
+	  if (maxlength > 0)
+	    {
+	      if (length < maxlength)
+		abort ();
+	      memcpy (resultbuf, result, maxlength - 1);
+	      resultbuf[maxlength - 1] = '\0';
+	    }
+	  free (result);
+	  return -1;
+	}
+      else
+	return length;
+    }
+}
+
+DLL_EXPORTED
+int
+libintl_snprintf (char *resultbuf, size_t length, const char *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vsnprintf (resultbuf, length, format, args);
+  va_end (args);
+  return retval;
+}
+
+#endif
+
+#if HAVE_ASPRINTF
+
+DLL_EXPORTED
+int
+libintl_vasprintf (char **resultp, const char *format, va_list args)
+{
+  size_t length;
+  char *result = libintl_vasnprintf (NULL, &length, format, args);
+  if (result == NULL)
+    return -1;
+  *resultp = result;
+  return length;
+}
+
+DLL_EXPORTED
+int
+libintl_asprintf (char **resultp, const char *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vasprintf (resultp, format, args);
+  va_end (args);
+  return retval;
+}
+
+#endif
+
+#if HAVE_FWPRINTF
+
+#include <wchar.h>
+
+#define WIDE_CHAR_VERSION 1
+
+/* Define auxiliary functions declared in "wprintf-parse.h".  */
+#include "printf-parse.c"
+
+/* Define functions declared in "vasnprintf.h".  */
+#define vasnwprintf libintl_vasnwprintf
+#include "vasnprintf.c"
+#if 0 /* not needed */
+#define asnwprintf libintl_asnwprintf
+#include "asnprintf.c"
+#endif
+
+# if HAVE_DECL__SNWPRINTF
+   /* Windows.  */
+#  define system_vswprintf _vsnwprintf
+# else
+   /* Unix.  */
+#  define system_vswprintf vswprintf
+# endif
+
+DLL_EXPORTED
+int
+libintl_vfwprintf (FILE *stream, const wchar_t *format, va_list args)
+{
+  if (wcschr (format, '$') == NULL)
+    return vfwprintf (stream, format, args);
+  else
+    {
+      size_t length;
+      wchar_t *result = libintl_vasnwprintf (NULL, &length, format, args);
+      int retval = -1;
+      if (result != NULL)
+	{
+	  size_t i;
+	  for (i = 0; i < length; i++)
+	    if (fputwc (result[i], stream) == WEOF)
+	      break;
+	  if (i == length)
+	    retval = length;
+	  free (result);
+	}
+      return retval;
+    }
+}
+
+DLL_EXPORTED
+int
+libintl_fwprintf (FILE *stream, const wchar_t *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vfwprintf (stream, format, args);
+  va_end (args);
+  return retval;
+}
+
+DLL_EXPORTED
+int
+libintl_vwprintf (const wchar_t *format, va_list args)
+{
+  return libintl_vfwprintf (stdout, format, args);
+}
+
+DLL_EXPORTED
+int
+libintl_wprintf (const wchar_t *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vwprintf (format, args);
+  va_end (args);
+  return retval;
+}
+
+DLL_EXPORTED
+int
+libintl_vswprintf (wchar_t *resultbuf, size_t length, const wchar_t *format, va_list args)
+{
+  if (wcschr (format, '$') == NULL)
+    return system_vswprintf (resultbuf, length, format, args);
+  else
+    {
+      size_t maxlength = length;
+      wchar_t *result = libintl_vasnwprintf (resultbuf, &length, format, args);
+      if (result != resultbuf)
+	{
+	  if (maxlength > 0)
+	    {
+	      if (length < maxlength)
+		abort ();
+	      memcpy (resultbuf, result, (maxlength - 1) * sizeof (wchar_t));
+	      resultbuf[maxlength - 1] = 0;
+	    }
+	  free (result);
+	  return -1;
+	}
+      else
+	return length;
+    }
+}
+
+DLL_EXPORTED
+int
+libintl_swprintf (wchar_t *resultbuf, size_t length, const wchar_t *format, ...)
+{
+  va_list args;
+  int retval;
+
+  va_start (args, format);
+  retval = libintl_vswprintf (resultbuf, length, format, args);
+  va_end (args);
+  return retval;
+}
+
+#endif
+
+#endif
diff -r 4216c218ee44 -r e04165992166 intl/relocatable.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/relocatable.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,449 @@
+/* Provide relocatable packages.
+   Copyright (C) 2003-2004 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2003.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+
+/* Tell glibc's <stdio.h> to provide a prototype for getline().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+/* Specification.  */
+#include "relocatable.h"
+
+#if ENABLE_RELOCATABLE
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef NO_XMALLOC
+# define xmalloc malloc
+#else
+# include "xalloc.h"
+#endif
+
+#if defined _WIN32 || defined __WIN32__
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
+
+#if DEPENDS_ON_LIBCHARSET
+# include <libcharset.h>
+#endif
+#if DEPENDS_ON_LIBICONV && HAVE_ICONV
+# include <iconv.h>
+#endif
+#if DEPENDS_ON_LIBINTL && ENABLE_NLS
+# include <libintl.h>
+#endif
+
+/* Faked cheap 'bool'.  */
+#undef bool
+#undef false
+#undef true
+#define bool int
+#define false 0
+#define true 1
+
+/* Pathname support.
+   ISSLASH(C)           tests whether C is a directory separator character.
+   IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
+ */
+#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, Cygwin, OS/2, DOS */
+# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+# define HAS_DEVICE(P) \
+    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
+     && (P)[1] == ':')
+# define IS_PATH_WITH_DIR(P) \
+    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
+# define FILE_SYSTEM_PREFIX_LEN(P) (HAS_DEVICE (P) ? 2 : 0)
+#else
+  /* Unix */
+# define ISSLASH(C) ((C) == '/')
+# define IS_PATH_WITH_DIR(P) (strchr (P, '/') != NULL)
+# define FILE_SYSTEM_PREFIX_LEN(P) 0
+#endif
+
+/* Original installation prefix.  */
+static char *orig_prefix;
+static size_t orig_prefix_len;
+/* Current installation prefix.  */
+static char *curr_prefix;
+static size_t curr_prefix_len;
+/* These prefixes do not end in a slash.  Anything that will be concatenated
+   to them must start with a slash.  */
+
+/* Sets the original and the current installation prefix of this module.
+   Relocation simply replaces a pathname starting with the original prefix
+   by the corresponding pathname with the current prefix instead.  Both
+   prefixes should be directory names without trailing slash (i.e. use ""
+   instead of "/").  */
+static void
+set_this_relocation_prefix (const char *orig_prefix_arg,
+			    const char *curr_prefix_arg)
+{
+  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL
+      /* Optimization: if orig_prefix and curr_prefix are equal, the
+	 relocation is a nop.  */
+      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)
+    {
+      /* Duplicate the argument strings.  */
+      char *memory;
+
+      orig_prefix_len = strlen (orig_prefix_arg);
+      curr_prefix_len = strlen (curr_prefix_arg);
+      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);
+#ifdef NO_XMALLOC
+      if (memory != NULL)
+#endif
+	{
+	  memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);
+	  orig_prefix = memory;
+	  memory += orig_prefix_len + 1;
+	  memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);
+	  curr_prefix = memory;
+	  return;
+	}
+    }
+  orig_prefix = NULL;
+  curr_prefix = NULL;
+  /* Don't worry about wasted memory here - this function is usually only
+     called once.  */
+}
+
+/* Sets the original and the current installation prefix of the package.
+   Relocation simply replaces a pathname starting with the original prefix
+   by the corresponding pathname with the current prefix instead.  Both
+   prefixes should be directory names without trailing slash (i.e. use ""
+   instead of "/").  */
+void
+set_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)
+{
+  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
+
+  /* Now notify all dependent libraries.  */
+#if DEPENDS_ON_LIBCHARSET
+  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
+#endif
+#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109
+  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
+#endif
+#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix
+  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
+#endif
+}
+
+#if !defined IN_LIBRARY || (defined PIC && defined INSTALLDIR)
+
+/* Convenience function:
+   Computes the current installation prefix, based on the original
+   installation prefix, the original installation directory of a particular
+   file, and the current pathname of this file.  Returns NULL upon failure.  */
+#ifdef IN_LIBRARY
+#define compute_curr_prefix local_compute_curr_prefix
+static
+#endif
+const char *
+compute_curr_prefix (const char *orig_installprefix,
+		     const char *orig_installdir,
+		     const char *curr_pathname)
+{
+  const char *curr_installdir;
+  const char *rel_installdir;
+
+  if (curr_pathname == NULL)
+    return NULL;
+
+  /* Determine the relative installation directory, relative to the prefix.
+     This is simply the difference between orig_installprefix and
+     orig_installdir.  */
+  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))
+      != 0)
+    /* Shouldn't happen - nothing should be installed outside $(prefix).  */
+    return NULL;
+  rel_installdir = orig_installdir + strlen (orig_installprefix);
+
+  /* Determine the current installation directory.  */
+  {
+    const char *p_base = curr_pathname + FILE_SYSTEM_PREFIX_LEN (curr_pathname);
+    const char *p = curr_pathname + strlen (curr_pathname);
+    char *q;
+
+    while (p > p_base)
+      {
+	p--;
+	if (ISSLASH (*p))
+	  break;
+      }
+
+    q = (char *) xmalloc (p - curr_pathname + 1);
+#ifdef NO_XMALLOC
+    if (q == NULL)
+      return NULL;
+#endif
+    memcpy (q, curr_pathname, p - curr_pathname);
+    q[p - curr_pathname] = '\0';
+    curr_installdir = q;
+  }
+
+  /* Compute the current installation prefix by removing the trailing
+     rel_installdir from it.  */
+  {
+    const char *rp = rel_installdir + strlen (rel_installdir);
+    const char *cp = curr_installdir + strlen (curr_installdir);
+    const char *cp_base =
+      curr_installdir + FILE_SYSTEM_PREFIX_LEN (curr_installdir);
+
+    while (rp > rel_installdir && cp > cp_base)
+      {
+	bool same = false;
+	const char *rpi = rp;
+	const char *cpi = cp;
+
+	while (rpi > rel_installdir && cpi > cp_base)
+	  {
+	    rpi--;
+	    cpi--;
+	    if (ISSLASH (*rpi) || ISSLASH (*cpi))
+	      {
+		if (ISSLASH (*rpi) && ISSLASH (*cpi))
+		  same = true;
+		break;
+	      }
+#if defined _WIN32 || defined __WIN32__ || defined __CYGWIN__ || defined __EMX__ || defined __DJGPP__
+	    /* Win32, Cygwin, OS/2, DOS - case insignificant filesystem */
+	    if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)
+		!= (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))
+	      break;
+#else
+	    if (*rpi != *cpi)
+	      break;
+#endif
+	  }
+	if (!same)
+	  break;
+	/* The last pathname component was the same.  opi and cpi now point
+	   to the slash before it.  */
+	rp = rpi;
+	cp = cpi;
+      }
+
+    if (rp > rel_installdir)
+      /* Unexpected: The curr_installdir does not end with rel_installdir.  */
+      return NULL;
+
+    {
+      size_t curr_prefix_len = cp - curr_installdir;
+      char *curr_prefix;
+
+      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);
+#ifdef NO_XMALLOC
+      if (curr_prefix == NULL)
+	return NULL;
+#endif
+      memcpy (curr_prefix, curr_installdir, curr_prefix_len);
+      curr_prefix[curr_prefix_len] = '\0';
+
+      return curr_prefix;
+    }
+  }
+}
+
+#endif /* !IN_LIBRARY || PIC */
+
+#if defined PIC && defined INSTALLDIR
+
+/* Full pathname of shared library, or NULL.  */
+static char *shared_library_fullname;
+
+#if defined _WIN32 || defined __WIN32__
+
+/* Determine the full pathname of the shared library when it is loaded.  */
+
+BOOL WINAPI
+DllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)
+{
+  (void) reserved;
+
+  if (event == DLL_PROCESS_ATTACH)
+    {
+      /* The DLL is being loaded into an application's address range.  */
+      static char location[MAX_PATH];
+
+      if (!GetModuleFileName (module_handle, location, sizeof (location)))
+	/* Shouldn't happen.  */
+	return FALSE;
+
+      if (!IS_PATH_WITH_DIR (location))
+	/* Shouldn't happen.  */
+	return FALSE;
+
+      shared_library_fullname = strdup (location);
+    }
+
+  return TRUE;
+}
+
+#else /* Unix */
+
+static void
+find_shared_library_fullname ()
+{
+#if defined __linux__ && __GLIBC__ >= 2
+  /* Linux has /proc/self/maps. glibc 2 has the getline() function.  */
+  FILE *fp;
+
+  /* Open the current process' maps file.  It describes one VMA per line.  */
+  fp = fopen ("/proc/self/maps", "r");
+  if (fp)
+    {
+      unsigned long address = (unsigned long) &find_shared_library_fullname;
+      for (;;)
+	{
+	  unsigned long start, end;
+	  int c;
+
+	  if (fscanf (fp, "%lx-%lx", &start, &end) != 2)
+	    break;
+	  if (address >= start && address <= end - 1)
+	    {
+	      /* Found it.  Now see if this line contains a filename.  */
+	      while (c = getc (fp), c != EOF && c != '\n' && c != '/')
+		continue;
+	      if (c == '/')
+		{
+		  size_t size;
+		  int len;
+
+		  ungetc (c, fp);
+		  shared_library_fullname = NULL; size = 0;
+		  len = getline (&shared_library_fullname, &size, fp);
+		  if (len >= 0)
+		    {
+		      /* Success: filled shared_library_fullname.  */
+		      if (len > 0 && shared_library_fullname[len - 1] == '\n')
+			shared_library_fullname[len - 1] = '\0';
+		    }
+		}
+	      break;
+	    }
+	  while (c = getc (fp), c != EOF && c != '\n')
+	    continue;
+	}
+      fclose (fp);
+    }
+#endif
+}
+
+#endif /* WIN32 / Unix */
+
+/* Return the full pathname of the current shared library.
+   Return NULL if unknown.
+   Guaranteed to work only on Linux and Woe32.  */
+static char *
+get_shared_library_fullname ()
+{
+#if !(defined _WIN32 || defined __WIN32__)
+  static bool tried_find_shared_library_fullname;
+  if (!tried_find_shared_library_fullname)
+    {
+      find_shared_library_fullname ();
+      tried_find_shared_library_fullname = true;
+    }
+#endif
+  return shared_library_fullname;
+}
+
+#endif /* PIC */
+
+/* Returns the pathname, relocated according to the current installation
+   directory.  */
+const char *
+relocate (const char *pathname)
+{
+#if defined PIC && defined INSTALLDIR
+  static int initialized;
+
+  /* Initialization code for a shared library.  */
+  if (!initialized)
+    {
+      /* At this point, orig_prefix and curr_prefix likely have already been
+	 set through the main program's set_program_name_and_installdir
+	 function.  This is sufficient in the case that the library has
+	 initially been installed in the same orig_prefix.  But we can do
+	 better, to also cover the cases that 1. it has been installed
+	 in a different prefix before being moved to orig_prefix and (later)
+	 to curr_prefix, 2. unlike the program, it has not moved away from
+	 orig_prefix.  */
+      const char *orig_installprefix = INSTALLPREFIX;
+      const char *orig_installdir = INSTALLDIR;
+      const char *curr_prefix_better;
+
+      curr_prefix_better =
+	compute_curr_prefix (orig_installprefix, orig_installdir,
+			     get_shared_library_fullname ());
+      if (curr_prefix_better == NULL)
+	curr_prefix_better = curr_prefix;
+
+      set_relocation_prefix (orig_installprefix, curr_prefix_better);
+
+      initialized = 1;
+    }
+#endif
+
+  /* Note: It is not necessary to perform case insensitive comparison here,
+     even for DOS-like filesystems, because the pathname argument was
+     typically created from the same Makefile variable as orig_prefix came
+     from.  */
+  if (orig_prefix != NULL && curr_prefix != NULL
+      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)
+    {
+      if (pathname[orig_prefix_len] == '\0')
+	/* pathname equals orig_prefix.  */
+	return curr_prefix;
+      if (ISSLASH (pathname[orig_prefix_len]))
+	{
+	  /* pathname starts with orig_prefix.  */
+	  const char *pathname_tail = &pathname[orig_prefix_len];
+	  char *result =
+	    (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);
+
+#ifdef NO_XMALLOC
+	  if (result != NULL)
+#endif
+	    {
+	      memcpy (result, curr_prefix, curr_prefix_len);
+	      strcpy (result + curr_prefix_len, pathname_tail);
+	      return result;
+	    }
+	}
+    }
+  /* Nothing to relocate.  */
+  return pathname;
+}
+
+#endif
diff -r 4216c218ee44 -r e04165992166 intl/relocatable.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/relocatable.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,77 @@
+/* Provide relocatable packages.
+   Copyright (C) 2003 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2003.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _RELOCATABLE_H
+#define _RELOCATABLE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* This can be enabled through the configure --enable-relocatable option.  */
+#if ENABLE_RELOCATABLE
+
+/* When building a DLL, we must export some functions.  Note that because
+   this is a private .h file, we don't need to use __declspec(dllimport)
+   in any case.  */
+#if defined _MSC_VER && BUILDING_DLL
+# define RELOCATABLE_DLL_EXPORTED __declspec(dllexport)
+#else
+# define RELOCATABLE_DLL_EXPORTED
+#endif
+
+/* Sets the original and the current installation prefix of the package.
+   Relocation simply replaces a pathname starting with the original prefix
+   by the corresponding pathname with the current prefix instead.  Both
+   prefixes should be directory names without trailing slash (i.e. use ""
+   instead of "/").  */
+extern RELOCATABLE_DLL_EXPORTED void
+       set_relocation_prefix (const char *orig_prefix,
+			      const char *curr_prefix);
+
+/* Returns the pathname, relocated according to the current installation
+   directory.  */
+extern const char * relocate (const char *pathname);
+
+/* Memory management: relocate() leaks memory, because it has to construct
+   a fresh pathname.  If this is a problem because your program calls
+   relocate() frequently, think about caching the result.  */
+
+/* Convenience function:
+   Computes the current installation prefix, based on the original
+   installation prefix, the original installation directory of a particular
+   file, and the current pathname of this file.  Returns NULL upon failure.  */
+extern const char * compute_curr_prefix (const char *orig_installprefix,
+					 const char *orig_installdir,
+					 const char *curr_pathname);
+
+#else
+
+/* By default, we use the hardwired pathnames.  */
+#define relocate(pathname) (pathname)
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _RELOCATABLE_H */
diff -r 4216c218ee44 -r e04165992166 intl/textdomain.c
--- a/intl/textdomain.c	Sat May 28 13:40:15 2005 +0000
+++ b/intl/textdomain.c	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 /* Implementation of the textdomain(3) function.
-   Copyright (C) 1995-1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Copyright (C) 1995-1998, 2000-2003 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify it
    under the terms of the GNU Library General Public License as published
@@ -77,8 +77,7 @@ __libc_rwlock_define (extern, _nl_state_
    If DOMAINNAME is null, return the current default.
    If DOMAINNAME is "", reset to the default of "messages".  */
 char *
-TEXTDOMAIN (domainname)
-     const char *domainname;
+TEXTDOMAIN (const char *domainname)
 {
   char *new_domain;
   char *old_domain;
diff -r 4216c218ee44 -r e04165992166 intl/vasnprintf.c
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/vasnprintf.c	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,902 @@
+/* vsprintf with automatic memory allocation.
+   Copyright (C) 1999, 2002-2005 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Tell glibc's <stdio.h> to provide a prototype for snprintf().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE    1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+#ifndef IN_LIBINTL
+# include <alloca.h>
+#endif
+
+/* Specification.  */
+#if WIDE_CHAR_VERSION
+# include "vasnwprintf.h"
+#else
+# include "vasnprintf.h"
+#endif
+
+#include <stdio.h>	/* snprintf(), sprintf() */
+#include <stdlib.h>	/* abort(), malloc(), realloc(), free() */
+#include <string.h>	/* memcpy(), strlen() */
+#include <errno.h>	/* errno */
+#include <limits.h>	/* CHAR_BIT, INT_MAX */
+#include <float.h>	/* DBL_MAX_EXP, LDBL_MAX_EXP */
+#if WIDE_CHAR_VERSION
+# include "wprintf-parse.h"
+#else
+# include "printf-parse.h"
+#endif
+
+/* Checked size_t computations.  */
+#include "xsize.h"
+
+/* Some systems, like OSF/1 4.0 and Woe32, don't have EOVERFLOW.  */
+#ifndef EOVERFLOW
+# define EOVERFLOW E2BIG
+#endif
+
+#ifdef HAVE_WCHAR_T
+# ifdef HAVE_WCSLEN
+#  define local_wcslen wcslen
+# else
+   /* Solaris 2.5.1 has wcslen() in a separate library libw.so. To avoid
+      a dependency towards this library, here is a local substitute.
+      Define this substitute only once, even if this file is included
+      twice in the same compilation unit.  */
+#  ifndef local_wcslen_defined
+#   define local_wcslen_defined 1
+static size_t
+local_wcslen (const wchar_t *s)
+{
+  const wchar_t *ptr;
+
+  for (ptr = s; *ptr != (wchar_t) 0; ptr++)
+    ;
+  return ptr - s;
+}
+#  endif
+# endif
+#endif
+
+#if WIDE_CHAR_VERSION
+# define VASNPRINTF vasnwprintf
+# define CHAR_T wchar_t
+# define DIRECTIVE wchar_t_directive
+# define DIRECTIVES wchar_t_directives
+# define PRINTF_PARSE wprintf_parse
+# define USE_SNPRINTF 1
+# if HAVE_DECL__SNWPRINTF
+   /* On Windows, the function swprintf() has a different signature than
+      on Unix; we use the _snwprintf() function instead.  */
+#  define SNPRINTF _snwprintf
+# else
+   /* Unix.  */
+#  define SNPRINTF swprintf
+# endif
+#else
+# define VASNPRINTF vasnprintf
+# define CHAR_T char
+# define DIRECTIVE char_directive
+# define DIRECTIVES char_directives
+# define PRINTF_PARSE printf_parse
+# define USE_SNPRINTF (HAVE_DECL__SNPRINTF || HAVE_SNPRINTF)
+# if HAVE_DECL__SNPRINTF
+   /* Windows.  */
+#  define SNPRINTF _snprintf
+# else
+   /* Unix.  */
+#  define SNPRINTF snprintf
+# endif
+#endif
+
+CHAR_T *
+VASNPRINTF (CHAR_T *resultbuf, size_t *lengthp, const CHAR_T *format, va_list args)
+{
+  DIRECTIVES d;
+  arguments a;
+
+  if (PRINTF_PARSE (format, &d, &a) < 0)
+    {
+      errno = EINVAL;
+      return NULL;
+    }
+
+#define CLEANUP() \
+  free (d.dir);								\
+  if (a.arg)								\
+    free (a.arg);
+
+  if (printf_fetchargs (args, &a) < 0)
+    {
+      CLEANUP ();
+      errno = EINVAL;
+      return NULL;
+    }
+
+  {
+    size_t buf_neededlength;
+    CHAR_T *buf;
+    CHAR_T *buf_malloced;
+    const CHAR_T *cp;
+    size_t i;
+    DIRECTIVE *dp;
+    /* Output string accumulator.  */
+    CHAR_T *result;
+    size_t allocated;
+    size_t length;
+
+    /* Allocate a small buffer that will hold a directive passed to
+       sprintf or snprintf.  */
+    buf_neededlength =
+      xsum4 (7, d.max_width_length, d.max_precision_length, 6);
+#if HAVE_ALLOCA
+    if (buf_neededlength < 4000 / sizeof (CHAR_T))
+      {
+	buf = (CHAR_T *) alloca (buf_neededlength * sizeof (CHAR_T));
+	buf_malloced = NULL;
+      }
+    else
+#endif
+      {
+	size_t buf_memsize = xtimes (buf_neededlength, sizeof (CHAR_T));
+	if (size_overflow_p (buf_memsize))
+	  goto out_of_memory_1;
+	buf = (CHAR_T *) malloc (buf_memsize);
+	if (buf == NULL)
+	  goto out_of_memory_1;
+	buf_malloced = buf;
+      }
+
+    if (resultbuf != NULL)
+      {
+	result = resultbuf;
+	allocated = *lengthp;
+      }
+    else
+      {
+	result = NULL;
+	allocated = 0;
+      }
+    length = 0;
+    /* Invariants:
+       result is either == resultbuf or == NULL or malloc-allocated.
+       If length > 0, then result != NULL.  */
+
+    /* Ensures that allocated >= needed.  Aborts through a jump to
+       out_of_memory if needed is SIZE_MAX or otherwise too big.  */
+#define ENSURE_ALLOCATION(needed) \
+    if ((needed) > allocated)						     \
+      {									     \
+	size_t memory_size;						     \
+	CHAR_T *memory;							     \
+									     \
+	allocated = (allocated > 0 ? xtimes (allocated, 2) : 12);	     \
+	if ((needed) > allocated)					     \
+	  allocated = (needed);						     \
+	memory_size = xtimes (allocated, sizeof (CHAR_T));		     \
+	if (size_overflow_p (memory_size))				     \
+	  goto out_of_memory;						     \
+	if (result == resultbuf || result == NULL)			     \
+	  memory = (CHAR_T *) malloc (memory_size);			     \
+	else								     \
+	  memory = (CHAR_T *) realloc (result, memory_size);		     \
+	if (memory == NULL)						     \
+	  goto out_of_memory;						     \
+	if (result == resultbuf && length > 0)				     \
+	  memcpy (memory, result, length * sizeof (CHAR_T));		     \
+	result = memory;						     \
+      }
+
+    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)
+      {
+	if (cp != dp->dir_start)
+	  {
+	    size_t n = dp->dir_start - cp;
+	    size_t augmented_length = xsum (length, n);
+
+	    ENSURE_ALLOCATION (augmented_length);
+	    memcpy (result + length, cp, n * sizeof (CHAR_T));
+	    length = augmented_length;
+	  }
+	if (i == d.count)
+	  break;
+
+	/* Execute a single directive.  */
+	if (dp->conversion == '%')
+	  {
+	    size_t augmented_length;
+
+	    if (!(dp->arg_index == ARG_NONE))
+	      abort ();
+	    augmented_length = xsum (length, 1);
+	    ENSURE_ALLOCATION (augmented_length);
+	    result[length] = '%';
+	    length = augmented_length;
+	  }
+	else
+	  {
+	    if (!(dp->arg_index != ARG_NONE))
+	      abort ();
+
+	    if (dp->conversion == 'n')
+	      {
+		switch (a.arg[dp->arg_index].type)
+		  {
+		  case TYPE_COUNT_SCHAR_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_schar_pointer = length;
+		    break;
+		  case TYPE_COUNT_SHORT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_short_pointer = length;
+		    break;
+		  case TYPE_COUNT_INT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_int_pointer = length;
+		    break;
+		  case TYPE_COUNT_LONGINT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_longint_pointer = length;
+		    break;
+#ifdef HAVE_LONG_LONG
+		  case TYPE_COUNT_LONGLONGINT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_longlongint_pointer = length;
+		    break;
+#endif
+		  default:
+		    abort ();
+		  }
+	      }
+	    else
+	      {
+		arg_type type = a.arg[dp->arg_index].type;
+		CHAR_T *p;
+		unsigned int prefix_count;
+		int prefixes[2];
+#if !USE_SNPRINTF
+		size_t tmp_length;
+		CHAR_T tmpbuf[700];
+		CHAR_T *tmp;
+
+		/* Allocate a temporary buffer of sufficient size for calling
+		   sprintf.  */
+		{
+		  size_t width;
+		  size_t precision;
+
+		  width = 0;
+		  if (dp->width_start != dp->width_end)
+		    {
+		      if (dp->width_arg_index != ARG_NONE)
+			{
+			  int arg;
+
+			  if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+			    abort ();
+			  arg = a.arg[dp->width_arg_index].a.a_int;
+			  width = (arg < 0 ? (unsigned int) (-arg) : arg);
+			}
+		      else
+			{
+			  const CHAR_T *digitp = dp->width_start;
+
+			  do
+			    width = xsum (xtimes (width, 10), *digitp++ - '0');
+			  while (digitp != dp->width_end);
+			}
+		    }
+
+		  precision = 6;
+		  if (dp->precision_start != dp->precision_end)
+		    {
+		      if (dp->precision_arg_index != ARG_NONE)
+			{
+			  int arg;
+
+			  if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+			    abort ();
+			  arg = a.arg[dp->precision_arg_index].a.a_int;
+			  precision = (arg < 0 ? 0 : arg);
+			}
+		      else
+			{
+			  const CHAR_T *digitp = dp->precision_start + 1;
+
+			  precision = 0;
+			  while (digitp != dp->precision_end)
+			    precision = xsum (xtimes (precision, 10), *digitp++ - '0');
+			}
+		    }
+
+		  switch (dp->conversion)
+		    {
+
+		    case 'd': case 'i': case 'u':
+# ifdef HAVE_LONG_LONG
+		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 1; /* account for leading sign */
+		      else
+# endif
+		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 1; /* account for leading sign */
+		      else
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 1; /* account for leading sign */
+		      break;
+
+		    case 'o':
+# ifdef HAVE_LONG_LONG
+		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
+					  * 0.333334 /* binary -> octal */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 1; /* account for leading sign */
+		      else
+# endif
+		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
+					  * 0.333334 /* binary -> octal */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 1; /* account for leading sign */
+		      else
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
+					  * 0.333334 /* binary -> octal */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 1; /* account for leading sign */
+		      break;
+
+		    case 'x': case 'X':
+# ifdef HAVE_LONG_LONG
+		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
+					  * 0.25 /* binary -> hexadecimal */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 2; /* account for leading sign or alternate form */
+		      else
+# endif
+		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
+					  * 0.25 /* binary -> hexadecimal */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 2; /* account for leading sign or alternate form */
+		      else
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
+					  * 0.25 /* binary -> hexadecimal */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 2; /* account for leading sign or alternate form */
+		      break;
+
+		    case 'f': case 'F':
+# ifdef HAVE_LONG_DOUBLE
+		      if (type == TYPE_LONGDOUBLE)
+			tmp_length =
+			  (unsigned int) (LDBL_MAX_EXP
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 10; /* sign, decimal point etc. */
+		      else
+# endif
+			tmp_length =
+			  (unsigned int) (DBL_MAX_EXP
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 10; /* sign, decimal point etc. */
+		      tmp_length = xsum (tmp_length, precision);
+		      break;
+
+		    case 'e': case 'E': case 'g': case 'G':
+		    case 'a': case 'A':
+		      tmp_length =
+			12; /* sign, decimal point, exponent etc. */
+		      tmp_length = xsum (tmp_length, precision);
+		      break;
+
+		    case 'c':
+# if defined HAVE_WINT_T && !WIDE_CHAR_VERSION
+		      if (type == TYPE_WIDE_CHAR)
+			tmp_length = MB_CUR_MAX;
+		      else
+# endif
+			tmp_length = 1;
+		      break;
+
+		    case 's':
+# ifdef HAVE_WCHAR_T
+		      if (type == TYPE_WIDE_STRING)
+			{
+			  tmp_length =
+			    local_wcslen (a.arg[dp->arg_index].a.a_wide_string);
+
+#  if !WIDE_CHAR_VERSION
+			  tmp_length = xtimes (tmp_length, MB_CUR_MAX);
+#  endif
+			}
+		      else
+# endif
+			tmp_length = strlen (a.arg[dp->arg_index].a.a_string);
+		      break;
+
+		    case 'p':
+		      tmp_length =
+			(unsigned int) (sizeof (void *) * CHAR_BIT
+					* 0.25 /* binary -> hexadecimal */
+				       )
+			  + 1 /* turn floor into ceil */
+			  + 2; /* account for leading 0x */
+		      break;
+
+		    default:
+		      abort ();
+		    }
+
+		  if (tmp_length < width)
+		    tmp_length = width;
+
+		  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
+		}
+
+		if (tmp_length <= sizeof (tmpbuf) / sizeof (CHAR_T))
+		  tmp = tmpbuf;
+		else
+		  {
+		    size_t tmp_memsize = xtimes (tmp_length, sizeof (CHAR_T));
+
+		    if (size_overflow_p (tmp_memsize))
+		      /* Overflow, would lead to out of memory.  */
+		      goto out_of_memory;
+		    tmp = (CHAR_T *) malloc (tmp_memsize);
+		    if (tmp == NULL)
+		      /* Out of memory.  */
+		      goto out_of_memory;
+		  }
+#endif
+
+		/* Construct the format string for calling snprintf or
+		   sprintf.  */
+		p = buf;
+		*p++ = '%';
+		if (dp->flags & FLAG_GROUP)
+		  *p++ = '\'';
+		if (dp->flags & FLAG_LEFT)
+		  *p++ = '-';
+		if (dp->flags & FLAG_SHOWSIGN)
+		  *p++ = '+';
+		if (dp->flags & FLAG_SPACE)
+		  *p++ = ' ';
+		if (dp->flags & FLAG_ALT)
+		  *p++ = '#';
+		if (dp->flags & FLAG_ZERO)
+		  *p++ = '0';
+		if (dp->width_start != dp->width_end)
+		  {
+		    size_t n = dp->width_end - dp->width_start;
+		    memcpy (p, dp->width_start, n * sizeof (CHAR_T));
+		    p += n;
+		  }
+		if (dp->precision_start != dp->precision_end)
+		  {
+		    size_t n = dp->precision_end - dp->precision_start;
+		    memcpy (p, dp->precision_start, n * sizeof (CHAR_T));
+		    p += n;
+		  }
+
+		switch (type)
+		  {
+#ifdef HAVE_LONG_LONG
+		  case TYPE_LONGLONGINT:
+		  case TYPE_ULONGLONGINT:
+		    *p++ = 'l';
+		    /*FALLTHROUGH*/
+#endif
+		  case TYPE_LONGINT:
+		  case TYPE_ULONGINT:
+#ifdef HAVE_WINT_T
+		  case TYPE_WIDE_CHAR:
+#endif
+#ifdef HAVE_WCHAR_T
+		  case TYPE_WIDE_STRING:
+#endif
+		    *p++ = 'l';
+		    break;
+#ifdef HAVE_LONG_DOUBLE
+		  case TYPE_LONGDOUBLE:
+		    *p++ = 'L';
+		    break;
+#endif
+		  default:
+		    break;
+		  }
+		*p = dp->conversion;
+#if USE_SNPRINTF
+		p[1] = '%';
+		p[2] = 'n';
+		p[3] = '\0';
+#else
+		p[1] = '\0';
+#endif
+
+		/* Construct the arguments for calling snprintf or sprintf.  */
+		prefix_count = 0;
+		if (dp->width_arg_index != ARG_NONE)
+		  {
+		    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+		      abort ();
+		    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;
+		  }
+		if (dp->precision_arg_index != ARG_NONE)
+		  {
+		    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+		      abort ();
+		    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;
+		  }
+
+#if USE_SNPRINTF
+		/* Prepare checking whether snprintf returns the count
+		   via %n.  */
+		ENSURE_ALLOCATION (xsum (length, 1));
+		result[length] = '\0';
+#endif
+
+		for (;;)
+		  {
+		    size_t maxlen;
+		    int count;
+		    int retcount;
+
+		    maxlen = allocated - length;
+		    count = -1;
+		    retcount = 0;
+
+#if USE_SNPRINTF
+# define SNPRINTF_BUF(arg) \
+		    switch (prefix_count)				    \
+		      {							    \
+		      case 0:						    \
+			retcount = SNPRINTF (result + length, maxlen, buf,  \
+					     arg, &count);		    \
+			break;						    \
+		      case 1:						    \
+			retcount = SNPRINTF (result + length, maxlen, buf,  \
+					     prefixes[0], arg, &count);	    \
+			break;						    \
+		      case 2:						    \
+			retcount = SNPRINTF (result + length, maxlen, buf,  \
+					     prefixes[0], prefixes[1], arg, \
+					     &count);			    \
+			break;						    \
+		      default:						    \
+			abort ();					    \
+		      }
+#else
+# define SNPRINTF_BUF(arg) \
+		    switch (prefix_count)				    \
+		      {							    \
+		      case 0:						    \
+			count = sprintf (tmp, buf, arg);		    \
+			break;						    \
+		      case 1:						    \
+			count = sprintf (tmp, buf, prefixes[0], arg);	    \
+			break;						    \
+		      case 2:						    \
+			count = sprintf (tmp, buf, prefixes[0], prefixes[1],\
+					 arg);				    \
+			break;						    \
+		      default:						    \
+			abort ();					    \
+		      }
+#endif
+
+		    switch (type)
+		      {
+		      case TYPE_SCHAR:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_schar;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_UCHAR:
+			{
+			  unsigned int arg = a.arg[dp->arg_index].a.a_uchar;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_SHORT:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_short;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_USHORT:
+			{
+			  unsigned int arg = a.arg[dp->arg_index].a.a_ushort;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_INT:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_int;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_UINT:
+			{
+			  unsigned int arg = a.arg[dp->arg_index].a.a_uint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_LONGINT:
+			{
+			  long int arg = a.arg[dp->arg_index].a.a_longint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_ULONGINT:
+			{
+			  unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#ifdef HAVE_LONG_LONG
+		      case TYPE_LONGLONGINT:
+			{
+			  long long int arg = a.arg[dp->arg_index].a.a_longlongint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_ULONGLONGINT:
+			{
+			  unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_DOUBLE:
+			{
+			  double arg = a.arg[dp->arg_index].a.a_double;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#ifdef HAVE_LONG_DOUBLE
+		      case TYPE_LONGDOUBLE:
+			{
+			  long double arg = a.arg[dp->arg_index].a.a_longdouble;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_CHAR:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_char;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#ifdef HAVE_WINT_T
+		      case TYPE_WIDE_CHAR:
+			{
+			  wint_t arg = a.arg[dp->arg_index].a.a_wide_char;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_STRING:
+			{
+			  const char *arg = a.arg[dp->arg_index].a.a_string;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#ifdef HAVE_WCHAR_T
+		      case TYPE_WIDE_STRING:
+			{
+			  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_POINTER:
+			{
+			  void *arg = a.arg[dp->arg_index].a.a_pointer;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      default:
+			abort ();
+		      }
+
+#if USE_SNPRINTF
+		    /* Portability: Not all implementations of snprintf()
+		       are ISO C 99 compliant.  Determine the number of
+		       bytes that snprintf() has produced or would have
+		       produced.  */
+		    if (count >= 0)
+		      {
+			/* Verify that snprintf() has NUL-terminated its
+			   result.  */
+			if (count < maxlen && result[length + count] != '\0')
+			  abort ();
+			/* Portability hack.  */
+			if (retcount > count)
+			  count = retcount;
+		      }
+		    else
+		      {
+			/* snprintf() doesn't understand the '%n'
+			   directive.  */
+			if (p[1] != '\0')
+			  {
+			    /* Don't use the '%n' directive; instead, look
+			       at the snprintf() return value.  */
+			    p[1] = '\0';
+			    continue;
+			  }
+			else
+			  {
+			    /* Look at the snprintf() return value.  */
+			    if (retcount < 0)
+			      {
+				/* HP-UX 10.20 snprintf() is doubly deficient:
+				   It doesn't understand the '%n' directive,
+				   *and* it returns -1 (rather than the length
+				   that would have been required) when the
+				   buffer is too small.  */
+				size_t bigger_need =
+				  xsum (xtimes (allocated, 2), 12);
+				ENSURE_ALLOCATION (bigger_need);
+				continue;
+			      }
+			    else
+			      count = retcount;
+			  }
+		      }
+#endif
+
+		    /* Attempt to handle failure.  */
+		    if (count < 0)
+		      {
+			if (!(result == resultbuf || result == NULL))
+			  free (result);
+			if (buf_malloced != NULL)
+			  free (buf_malloced);
+			CLEANUP ();
+			errno = EINVAL;
+			return NULL;
+		      }
+
+#if !USE_SNPRINTF
+		    if (count >= tmp_length)
+		      /* tmp_length was incorrectly calculated - fix the
+			 code above!  */
+		      abort ();
+#endif
+
+		    /* Make room for the result.  */
+		    if (count >= maxlen)
+		      {
+			/* Need at least count bytes.  But allocate
+			   proportionally, to avoid looping eternally if
+			   snprintf() reports a too small count.  */
+			size_t n =
+			  xmax (xsum (length, count), xtimes (allocated, 2));
+
+			ENSURE_ALLOCATION (n);
+#if USE_SNPRINTF
+			continue;
+#endif
+		      }
+
+#if USE_SNPRINTF
+		    /* The snprintf() result did fit.  */
+#else
+		    /* Append the sprintf() result.  */
+		    memcpy (result + length, tmp, count * sizeof (CHAR_T));
+		    if (tmp != tmpbuf)
+		      free (tmp);
+#endif
+
+		    length += count;
+		    break;
+		  }
+	      }
+	  }
+      }
+
+    /* Add the final NUL.  */
+    ENSURE_ALLOCATION (xsum (length, 1));
+    result[length] = '\0';
+
+    if (result != resultbuf && length + 1 < allocated)
+      {
+	/* Shrink the allocated memory if possible.  */
+	CHAR_T *memory;
+
+	memory = (CHAR_T *) realloc (result, (length + 1) * sizeof (CHAR_T));
+	if (memory != NULL)
+	  result = memory;
+      }
+
+    if (buf_malloced != NULL)
+      free (buf_malloced);
+    CLEANUP ();
+    *lengthp = length;
+    if (length > INT_MAX)
+      goto length_overflow;
+    return result;
+
+  length_overflow:
+    /* We could produce such a big string, but its length doesn't fit into
+       an 'int'.  POSIX says that snprintf() fails with errno = EOVERFLOW in
+       this case.  */
+    if (result != resultbuf)
+      free (result);
+    errno = EOVERFLOW;
+    return NULL;
+
+  out_of_memory:
+    if (!(result == resultbuf || result == NULL))
+      free (result);
+    if (buf_malloced != NULL)
+      free (buf_malloced);
+  out_of_memory_1:
+    CLEANUP ();
+    errno = ENOMEM;
+    return NULL;
+  }
+}
+
+#undef SNPRINTF
+#undef USE_SNPRINTF
+#undef PRINTF_PARSE
+#undef DIRECTIVES
+#undef DIRECTIVE
+#undef CHAR_T
+#undef VASNPRINTF
diff -r 4216c218ee44 -r e04165992166 intl/vasnprintf.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/vasnprintf.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,78 @@
+/* vsprintf with automatic memory allocation.
+   Copyright (C) 2002-2004 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _VASNPRINTF_H
+#define _VASNPRINTF_H
+
+/* Get va_list.  */
+#include <stdarg.h>
+
+/* Get size_t.  */
+#include <stddef.h>
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The __-protected variants of `format' and `printf' attributes
+   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#  define __format__ format
+#  define __printf__ printf
+# endif
+#endif
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* Write formatted output to a string dynamically allocated with malloc().
+   You can pass a preallocated buffer for the result in RESULTBUF and its
+   size in *LENGTHP; otherwise you pass RESULTBUF = NULL.
+   If successful, return the address of the string (this may be = RESULTBUF
+   if no dynamic memory allocation was necessary) and set *LENGTHP to the
+   number of resulting bytes, excluding the trailing NUL.  Upon error, set
+   errno and return NULL.
+
+   When dynamic memory allocation occurs, the preallocated buffer is left
+   alone (with possibly modified contents).  This makes it possible to use
+   a statically allocated or stack-allocated buffer, like this:
+
+          char buf[100];
+          size_t len = sizeof (buf);
+          char *output = vasnprintf (buf, &len, format, args);
+          if (output == NULL)
+            ... error handling ...;
+          else
+            {
+              ... use the output string ...;
+              if (output != buf)
+                free (output);
+            }
+  */
+extern char * asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)
+       __attribute__ ((__format__ (__printf__, 3, 4)));
+extern char * vasnprintf (char *resultbuf, size_t *lengthp, const char *format, va_list args)
+       __attribute__ ((__format__ (__printf__, 3, 0)));
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* _VASNPRINTF_H */
diff -r 4216c218ee44 -r e04165992166 intl/vasnwprintf.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/vasnwprintf.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,46 @@
+/* vswprintf with automatic memory allocation.
+   Copyright (C) 2002-2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _VASNWPRINTF_H
+#define _VASNWPRINTF_H
+
+/* Get va_list.  */
+#include <stdarg.h>
+
+/* Get wchar_t, size_t.  */
+#include <stddef.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+/* Write formatted output to a string dynamically allocated with malloc().
+   You can pass a preallocated buffer for the result in RESULTBUF and its
+   size in *LENGTHP; otherwise you pass RESULTBUF = NULL.
+   If successful, return the address of the string (this may be = RESULTBUF
+   if no dynamic memory allocation was necessary) and set *LENGTHP to the
+   number of resulting bytes, excluding the trailing NUL.  Upon error, set
+   errno and return NULL.  */
+extern wchar_t * asnwprintf (wchar_t *resultbuf, size_t *lengthp, const wchar_t *format, ...);
+extern wchar_t * vasnwprintf (wchar_t *resultbuf, size_t *lengthp, const wchar_t *format, va_list args);
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif /* _VASNWPRINTF_H */
diff -r 4216c218ee44 -r e04165992166 intl/wprintf-parse.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/wprintf-parse.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,75 @@
+/* Parse printf format string.
+   Copyright (C) 1999, 2002-2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _WPRINTF_PARSE_H
+#define _WPRINTF_PARSE_H
+
+#include "printf-args.h"
+
+
+/* Flags */
+#define FLAG_GROUP	 1	/* ' flag */
+#define FLAG_LEFT	 2	/* - flag */
+#define FLAG_SHOWSIGN	 4	/* + flag */
+#define FLAG_SPACE	 8	/* space flag */
+#define FLAG_ALT	16	/* # flag */
+#define FLAG_ZERO	32
+
+/* arg_index value indicating that no argument is consumed.  */
+#define ARG_NONE	(~(size_t)0)
+
+/* A parsed directive.  */
+typedef struct
+{
+  const wchar_t* dir_start;
+  const wchar_t* dir_end;
+  int flags;
+  const wchar_t* width_start;
+  const wchar_t* width_end;
+  size_t width_arg_index;
+  const wchar_t* precision_start;
+  const wchar_t* precision_end;
+  size_t precision_arg_index;
+  wchar_t conversion; /* d i o u x X f e E g G c s p n U % but not C S */
+  size_t arg_index;
+}
+wchar_t_directive;
+
+/* A parsed format string.  */
+typedef struct
+{
+  size_t count;
+  wchar_t_directive *dir;
+  size_t max_width_length;
+  size_t max_precision_length;
+}
+wchar_t_directives;
+
+
+/* Parses the format string.  Fills in the number N of directives, and fills
+   in directives[0], ..., directives[N-1], and sets directives[N].dir_start
+   to the end of the format string.  Also fills in the arg_type fields of the
+   arguments and the needed count of arguments.  */
+#ifdef STATIC
+STATIC
+#else
+extern
+#endif
+int wprintf_parse (const wchar_t *format, wchar_t_directives *d, arguments *a);
+
+#endif /* _WPRINTF_PARSE_H */
diff -r 4216c218ee44 -r e04165992166 intl/xsize.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/intl/xsize.h	Sat May 28 13:45:22 2005 +0000
@@ -0,0 +1,109 @@
+/* xsize.h -- Checked size_t computations.
+
+   Copyright (C) 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _XSIZE_H
+#define _XSIZE_H
+
+/* Get size_t.  */
+#include <stddef.h>
+
+/* Get SIZE_MAX.  */
+#include <limits.h>
+#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+
+/* The size of memory objects is often computed through expressions of
+   type size_t. Example:
+      void* p = malloc (header_size + n * element_size).
+   These computations can lead to overflow.  When this happens, malloc()
+   returns a piece of memory that is way too small, and the program then
+   crashes while attempting to fill the memory.
+   To avoid this, the functions and macros in this file check for overflow.
+   The convention is that SIZE_MAX represents overflow.
+   malloc (SIZE_MAX) is not guaranteed to fail -- think of a malloc
+   implementation that uses mmap --, it's recommended to use size_overflow_p()
+   or size_in_bounds_p() before invoking malloc().
+   The example thus becomes:
+      size_t size = xsum (header_size, xtimes (n, element_size));
+      void *p = (size_in_bounds_p (size) ? malloc (size) : NULL);
+*/
+
+/* Convert an arbitrary value >= 0 to type size_t.  */
+#define xcast_size_t(N) \
+  ((N) <= SIZE_MAX ? (size_t) (N) : SIZE_MAX)
+
+/* Sum of two sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xsum (size_t size1, size_t size2)
+{
+  size_t sum = size1 + size2;
+  return (sum >= size1 ? sum : SIZE_MAX);
+}
+
+/* Sum of three sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xsum3 (size_t size1, size_t size2, size_t size3)
+{
+  return xsum (xsum (size1, size2), size3);
+}
+
+/* Sum of four sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xsum4 (size_t size1, size_t size2, size_t size3, size_t size4)
+{
+  return xsum (xsum (xsum (size1, size2), size3), size4);
+}
+
+/* Maximum of two sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xmax (size_t size1, size_t size2)
+{
+  /* No explicit check is needed here, because for any n:
+     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */
+  return (size1 >= size2 ? size1 : size2);
+}
+
+/* Multiplication of a count with an element size, with overflow check.
+   The count must be >= 0 and the element size must be > 0.
+   This is a macro, not an inline function, so that it works correctly even
+   when N is of a wider tupe and N > SIZE_MAX.  */
+#define xtimes(N, ELSIZE) \
+  ((N) <= SIZE_MAX / (ELSIZE) ? (size_t) (N) * (ELSIZE) : SIZE_MAX)
+
+/* Check for overflow.  */
+#define size_overflow_p(SIZE) \
+  ((SIZE) == SIZE_MAX)
+/* Check against overflow.  */
+#define size_in_bounds_p(SIZE) \
+  ((SIZE) != SIZE_MAX)
+
+#endif /* _XSIZE_H */
diff -r 4216c218ee44 -r e04165992166 po/Makefile.in.in
--- a/po/Makefile.in.in	Sat May 28 13:40:15 2005 +0000
+++ b/po/Makefile.in.in	Sat May 28 13:45:22 2005 +0000
@@ -1,5 +1,5 @@
 # Makefile for PO directory in any package using GNU gettext.
-# Copyright (C) 1995-1997, 2000-2002 by Ulrich Drepper <drepper@gnu.ai.mit.edu>
+# Copyright (C) 1995-1997, 2000-2005 by Ulrich Drepper <drepper@gnu.ai.mit.edu>
 #
 # This file can be copied and used freely without restrictions.  It can
 # be used in projects which are not available under the GNU General Public
@@ -7,9 +7,12 @@
 # functionality.
 # Please note that the actual code of GNU gettext is covered by the GNU
 # General Public License and is *not* in the public domain.
+#
+# Origin: gettext-0.14.4
 
 PACKAGE = @PACKAGE@
 VERSION = @VERSION@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
 
 SHELL = /bin/sh
 @SET_MAKE@
@@ -27,7 +30,7 @@ INSTALL = @INSTALL@
 INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
 MKINSTALLDIRS = @MKINSTALLDIRS@
-mkinstalldirs = $(SHELL) `case "$(MKINSTALLDIRS)" in /*) echo "$(MKINSTALLDIRS)" ;; *) echo "$(top_builddir)/$(MKINSTALLDIRS)" ;; esac`
+mkinstalldirs = $(SHELL) $(MKINSTALLDIRS)
 
 GMSGFMT = @GMSGFMT@
 MSGFMT = @MSGFMT@
@@ -42,9 +45,9 @@ GMOFILES = @GMOFILES@
 GMOFILES = @GMOFILES@
 UPDATEPOFILES = @UPDATEPOFILES@
 DUMMYPOFILES = @DUMMYPOFILES@
-DISTFILES.common = Makefile.in.in Makevars remove-potcdate.sin \
+DISTFILES.common = Makefile.in.in remove-potcdate.sin \
 $(DISTFILES.common.extra1) $(DISTFILES.common.extra2) $(DISTFILES.common.extra3)
-DISTFILES = $(DISTFILES.common) POTFILES.in $(DOMAIN).pot \
+DISTFILES = $(DISTFILES.common) Makevars POTFILES.in \
 $(POFILES) $(GMOFILES) \
 $(DISTFILES.extra1) $(DISTFILES.extra2) $(DISTFILES.extra3)
 
@@ -55,7 +58,7 @@ CATALOGS = @CATALOGS@
 # Makevars gets inserted here. (Don't remove this line!)
 
 .SUFFIXES:
-.SUFFIXES: .po .gmo .mo .sed .sin .nop .po-update
+.SUFFIXES: .po .gmo .mo .sed .sin .nop .po-create .po-update
 
 .po.mo:
 	@echo "$(MSGFMT) -c -o $@ $<"; \
@@ -74,18 +77,49 @@ CATALOGS = @CATALOGS@
 
 all: all-@USE_NLS@
 
-all-yes: $(CATALOGS)
+all-yes: stamp-po
 all-no:
+
+# $(srcdir)/$(DOMAIN).pot is only created when needed. When xgettext finds no
+# internationalized messages, no $(srcdir)/$(DOMAIN).pot is created (because
+# we don't want to bother translators with empty POT files). We assume that
+# LINGUAS is empty in this case, i.e. $(POFILES) and $(GMOFILES) are empty.
+# In this case, stamp-po is a nop (i.e. a phony target).
+
+# stamp-po is a timestamp denoting the last time at which the CATALOGS have
+# been loosely updated. Its purpose is that when a developer or translator
+# checks out the package via CVS, and the $(DOMAIN).pot file is not in CVS,
+# "make" will update the $(DOMAIN).pot and the $(CATALOGS), but subsequent
+# invocations of "make" will do nothing. This timestamp would not be necessary
+# if updating the $(CATALOGS) would always touch them; however, the rule for
+# $(POFILES) has been designed to not touch files that don't need to be
+# changed.
+stamp-po: $(srcdir)/$(DOMAIN).pot
+	test ! -f $(srcdir)/$(DOMAIN).pot || \
+	  test -z "$(GMOFILES)" || $(MAKE) $(GMOFILES)
+	@test ! -f $(srcdir)/$(DOMAIN).pot || { \
+	  echo "touch stamp-po" && \
+	  echo timestamp > stamp-poT && \
+	  mv stamp-poT stamp-po; \
+	}
 
 # Note: Target 'all' must not depend on target '$(DOMAIN).pot-update',
 # otherwise packages like GCC can not be built if only parts of the source
 # have been downloaded.
 
+# This target rebuilds $(DOMAIN).pot; it is an expensive operation.
+# Note that $(DOMAIN).pot is not touched if it doesn't need to be changed.
 $(DOMAIN).pot-update: $(POTFILES) $(srcdir)/POTFILES.in remove-potcdate.sed
+	if test -n '$(MSGID_BUGS_ADDRESS)' || test '$(PACKAGE_BUGREPORT)' = '@'PACKAGE_BUGREPORT'@'; then \
+	  msgid_bugs_address='$(MSGID_BUGS_ADDRESS)'; \
+	else \
+	  msgid_bugs_address='$(PACKAGE_BUGREPORT)'; \
+	fi; \
 	$(XGETTEXT) --default-domain=$(DOMAIN) --directory=$(top_srcdir) \
 	  --add-comments=TRANSLATORS: $(XGETTEXT_OPTIONS) \
 	  --files-from=$(srcdir)/POTFILES.in \
-	  --copyright-holder='$(COPYRIGHT_HOLDER)'
+	  --copyright-holder='$(COPYRIGHT_HOLDER)' \
+	  --msgid-bugs-address="$$msgid_bugs_address"
 	test ! -f $(DOMAIN).po || { \
 	  if test -f $(srcdir)/$(DOMAIN).pot; then \
 	    sed -f remove-potcdate.sed < $(srcdir)/$(DOMAIN).pot > $(DOMAIN).1po && \
@@ -101,24 +135,36 @@ all-no:
 	  fi; \
 	}
 
+# This rule has no dependencies: we don't need to update $(DOMAIN).pot at
+# every "make" invocation, only create it when it is missing.
+# Only "make $(DOMAIN).pot-update" or "make dist" will force an update.
 $(srcdir)/$(DOMAIN).pot:
 	$(MAKE) $(DOMAIN).pot-update
 
+# This target rebuilds a PO file if $(DOMAIN).pot has changed.
+# Note that a PO file is not touched if it doesn't need to be changed.
 $(POFILES): $(srcdir)/$(DOMAIN).pot
 	@lang=`echo $@ | sed -e 's,.*/,,' -e 's/\.po$$//'`; \
-	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
-	echo "$${cdcmd}$(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot"; \
-	cd $(srcdir) && $(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot
+	if test -f "$(srcdir)/$${lang}.po"; then \
+	  test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
+	  echo "$${cdcmd}$(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot"; \
+	  cd $(srcdir) && $(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot; \
+	else \
+	  $(MAKE) $${lang}.po-create; \
+	fi
 
 
 install: install-exec install-data
 install-exec:
 install-data: install-data-@USE_NLS@
-	if test "$(PACKAGE)" = "gettext"; then \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
 	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
-	  for file in $(DISTFILES.common); do \
+	  for file in $(DISTFILES.common) Makevars.template; do \
 	    $(INSTALL_DATA) $(srcdir)/$$file \
 			    $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	  for file in Makevars; do \
+	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
 	  done; \
 	else \
 	  : ; \
@@ -170,7 +216,7 @@ installdirs: installdirs-exec installdir
 installdirs: installdirs-exec installdirs-data
 installdirs-exec:
 installdirs-data: installdirs-data-@USE_NLS@
-	if test "$(PACKAGE)" = "gettext"; then \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
 	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
 	else \
 	  : ; \
@@ -215,8 +261,8 @@ uninstall: uninstall-exec uninstall-data
 uninstall: uninstall-exec uninstall-data
 uninstall-exec:
 uninstall-data: uninstall-data-@USE_NLS@
-	if test "$(PACKAGE)" = "gettext"; then \
-	  for file in $(DISTFILES.common); do \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
+	  for file in $(DISTFILES.common) Makevars.template; do \
 	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
 	  done; \
 	else \
@@ -235,10 +281,11 @@ uninstall-data-yes:
 
 check: all
 
-dvi info tags TAGS ID:
+info dvi ps pdf html tags TAGS ctags CTAGS ID:
 
 mostlyclean:
 	rm -f remove-potcdate.sed
+	rm -f stamp-poT
 	rm -f core core.* $(DOMAIN).po $(DOMAIN).1po $(DOMAIN).2po *.new.po
 	rm -fr *.o
 
@@ -250,35 +297,55 @@ maintainer-clean: distclean
 maintainer-clean: distclean
 	@echo "This command is intended for maintainers to use;"
 	@echo "it deletes files that may require special tools to rebuild."
-	rm -f $(GMOFILES)
+	rm -f stamp-po $(GMOFILES)
 
 distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
 dist distdir:
 	$(MAKE) update-po
 	@$(MAKE) dist2
 # This is a separate target because 'update-po' must be executed before.
-dist2: $(DISTFILES)
+dist2: stamp-po $(DISTFILES)
 	dists="$(DISTFILES)"; \
-	if test -f $(srcdir)/ChangeLog; then dists="$$dists ChangeLog"; fi; \
+	if test "$(PACKAGE)" = "gettext-tools"; then \
+	  dists="$$dists Makevars.template"; \
+	fi; \
+	if test -f $(srcdir)/$(DOMAIN).pot; then \
+	  dists="$$dists $(DOMAIN).pot stamp-po"; \
+	fi; \
+	if test -f $(srcdir)/ChangeLog; then \
+	  dists="$$dists ChangeLog"; \
+	fi; \
+	for i in 0 1 2 3 4 5 6 7 8 9; do \
+	  if test -f $(srcdir)/ChangeLog.$$i; then \
+	    dists="$$dists ChangeLog.$$i"; \
+	  fi; \
+	done; \
 	if test -f $(srcdir)/LINGUAS; then dists="$$dists LINGUAS"; fi; \
 	for file in $$dists; do \
 	  if test -f $$file; then \
-	    cp -p $$file $(distdir); \
+	    cp -p $$file $(distdir) || exit 1; \
 	  else \
-	    cp -p $(srcdir)/$$file $(distdir); \
+	    cp -p $(srcdir)/$$file $(distdir) || exit 1; \
 	  fi; \
 	done
 
 update-po: Makefile
 	$(MAKE) $(DOMAIN).pot-update
-	$(MAKE) $(UPDATEPOFILES)
+	test -z "$(UPDATEPOFILES)" || $(MAKE) $(UPDATEPOFILES)
 	$(MAKE) update-gmo
+
+# General rule for creating PO files.
+
+.nop.po-create:
+	@lang=`echo $@ | sed -e 's/\.po-create$$//'`; \
+	echo "File $$lang.po does not exist. If you are a translator, you can create it through 'msginit'." 1>&2; \
+	exit 1
 
 # General rule for updating PO files.
 
 .nop.po-update:
 	@lang=`echo $@ | sed -e 's/\.po-update$$//'`; \
-	if test "$(PACKAGE)" = "gettext"; then PATH=`pwd`/../src:$$PATH; fi; \
+	if test "$(PACKAGE)" = "gettext-tools"; then PATH=`pwd`/../src:$$PATH; fi; \
 	tmpdir=`pwd`; \
 	echo "$$lang:"; \
 	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
@@ -305,7 +372,7 @@ update-gmo: Makefile $(GMOFILES)
 update-gmo: Makefile $(GMOFILES)
 	@:
 
-Makefile: Makefile.in.in $(top_builddir)/config.status POTFILES.in
+Makefile: Makefile.in.in Makevars $(top_builddir)/config.status @POMAKEFILEDEPS@
 	cd $(top_builddir) \
 	  && CONFIG_FILES=$(subdir)/$@.in CONFIG_HEADERS= \
 	       $(SHELL) ./config.status
diff -r 4216c218ee44 -r e04165992166 po/Makevars
--- a/po/Makevars	Sat May 28 13:40:15 2005 +0000
+++ b/po/Makevars	Sat May 28 13:45:22 2005 +0000
@@ -20,6 +20,22 @@ XGETTEXT_OPTIONS = --keyword=_ --keyword
 # their copyright.
 COPYRIGHT_HOLDER = Free Software Foundation, Inc.
 
+# This is the email address or URL to which the translators shall report
+# bugs in the untranslated strings:
+# - Strings which are not entire sentences, see the maintainer guidelines
+#   in the GNU gettext documentation, section 'Preparing Strings'.
+# - Strings which use unclear terms or require additional context to be
+#   understood.
+# - Strings which make invalid assumptions about notation of date, time or
+#   money.
+# - Pluralisation problems.
+# - Incorrect English spelling.
+# - Incorrect formatting.
+# It can be your email address, or a mailing list address where translators
+# can write to without being subscribed, or the URL of a web page through
+# which the translators can contact you.
+MSGID_BUGS_ADDRESS =
+
 # This is the list of locale categories, beyond LC_MESSAGES, for which the
 # message catalogs shall be used.  It is usually empty.
 EXTRA_LOCALE_CATEGORIES =

